<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>《Android插件化》读书笔记（五）跨进程通信</title>
    <link href="/2023/02/21/%E3%80%8AAndroid%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <url>/2023/02/21/%E3%80%8AAndroid%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h1><blockquote><p>仅仅需要了解架构模型，Client、Server、ServiceManager。</p></blockquote><blockquote><p>四大组件底层都是基于Binder的。</p></blockquote><p>IPC。解决跨进程通信。Binder分为Client和Server两个进程，相对。</p><h2 id="Binder组成"><a href="#Binder组成" class="headerlink" title="Binder组成"></a>Binder组成</h2><p><img src="/2023/02/21/%E3%80%8AAndroid%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/Binder_1.png"></p><blockquote><p>SM负责把Binder Server注册到一个容器中。</p></blockquote><h2 id="Binder通信流程"><a href="#Binder通信流程" class="headerlink" title="Binder通信流程"></a>Binder通信流程</h2><p><img src="/2023/02/21/%E3%80%8AAndroid%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/Binder_2.png"></p><ul><li>Server在SM中注册；</li><li>Client需要调动Server的add方法，需要获取Server对象，<strong>SM把Server的一个Proxy返回给Client</strong>；</li><li>Client调用Proxy的方法，SM帮助调用Server的对应方法，并把结果返回。</li></ul><blockquote><p>主要由Binder驱动完成。</p></blockquote><h1 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h1><p>Android接口定义语言（Android interface definition Language），发布以及调用远程服务，实现<strong>跨进程通信</strong>。</p><h2 id="AIDLDemo"><a href="#AIDLDemo" class="headerlink" title="AIDLDemo"></a>AIDLDemo</h2><blockquote><p>Ctrl+F9，自动生成aidl代码，build -&gt; generated找。</p></blockquote><p>Service中MyService实现逻辑。onBind一定返回Mybinder，使得Client可以使用MyBinder的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TAG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;---MyService---&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">MyService</span><span class="hljs-params">()</span> &#123;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> IBinder <span class="hljs-title function_">onBind</span><span class="hljs-params">(Intent intent)</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Return the communication channel to the service.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mybinder</span>();<br>&#125;<br><br><span class="hljs-comment">// Stub；Alt+Enter自动实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mybinder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IMyAidlInterface</span>.Stub&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getStringFromService</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;Service was called by Client&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;777&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Client也需要新建aidl，但是不能新建aidl，会生成Client的p；Service p和Client p需要一致，Client new AIDL Folder即可，在其中new和Service的p一致的p。</p><p><img src="/2023/02/21/%E3%80%8AAndroid%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/AIDLDemo_1.png"></p><p>Client也需要先编译aidl；Client connection；必须显示Intent，Action、Package和Service保持一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">IMyAidlInterface</span> <span class="hljs-variable">myAidlInterface</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">TextView</span> <span class="hljs-variable">txt</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br><br>        txt = findViewById(R.id.txt);<br><br>        <span class="hljs-type">ServiceConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceConnection</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onServiceConnected</span><span class="hljs-params">(ComponentName componentName, IBinder iBinder)</span> &#123;<br>                myAidlInterface = IMyAidlInterface.Stub.asInterface(iBinder);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> myAidlInterface.getStringFromService();<br>                    txt.setText(s);<br>                &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onServiceDisconnected</span><span class="hljs-params">(ComponentName componentName)</span> &#123;<br><br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();<br>        intent.setAction(<span class="hljs-string">&quot;com.example.service.action&quot;</span>);<br>        intent.setPackage(<span class="hljs-string">&quot;com.example.aidlservice&quot;</span>);<br>        bindService(intent,connection,BIND_AUTO_CREATE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>安卓高版本权限缩进，需要使Client有权限进行访问。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.QUERY_ALL_PACKAGES&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">tools:ignore</span>=<span class="hljs-string">&quot;QueryAllPackagesPermission&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">queries</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.example.aidlservice&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">queries</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="AIDL类"><a href="#AIDL类" class="headerlink" title="AIDL类"></a>AIDL类</h2><blockquote><p>AIDL需要了解以下类，IBinder、IInterface、Binder、Proxy、Stub。</p></blockquote><h2 id="AIDL工作流程"><a href="#AIDL工作流程" class="headerlink" title="AIDL工作流程"></a>AIDL工作流程</h2><p>自定义aidl文件（.aidl），AS生成的类文件（.java）类图。</p><p><img src="/2023/02/21/%E3%80%8AAndroid%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/AIDLClass.png"></p><p>一个接口，两个类；放在一个AIDL文件中；当有多个AIDL类的时候，Stub和Proxy类就会重名，因此放在不同AIDL接口中。</p><p><img src="/2023/02/21/%E3%80%8AAndroid%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/AIDLClass_2.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">myAidlInterface = IMyAidlInterface.Stub.asInterface(iBinder);<br></code></pre></td></tr></table></figure><p>Stub的sum方法调用到Proxy的sum方法，进而调用另一个进程的sum方法。<strong>起决定作用的是Stub的asInterface方法和onTransact方法。</strong></p><h3 id="Client角度"><a href="#Client角度" class="headerlink" title="Client角度"></a>Client角度</h3><p>对于AIDL的使用者，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">myAidlInterface = IMyAidlInterface.Stub.asInterface(iBinder);<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> myAidlInterface.getStringFromService();<br></code></pre></td></tr></table></figure><p>asInterface方法的作用是判断参数，也就是IBinder对象，和自己是否在同一个进程；是，则直接使用；否，则把这个IBinder参数包装成一个Proxy对象，这时调用Stub的sum方法，间接调用Proxy的sum方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.example.aidlservice.IMyAidlInterface <span class="hljs-title function_">asInterface</span><span class="hljs-params">(android.os.IBinder obj)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> ((obj==<span class="hljs-literal">null</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    android.os.<span class="hljs-type">IInterface</span> <span class="hljs-variable">iin</span> <span class="hljs-operator">=</span> obj.queryLocalInterface(DESCRIPTOR);<br>    <span class="hljs-keyword">if</span> (((iin!=<span class="hljs-literal">null</span>)&amp;&amp;(iin <span class="hljs-keyword">instanceof</span> com.example.aidlservice.IMyAidlInterface))) &#123;<br>        <span class="hljs-keyword">return</span> ((com.example.aidlservice.IMyAidlInterface)iin);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">com</span>.example.aidlservice.IMyAidlInterface.Stub.Proxy(obj);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Proxy角度"><a href="#Proxy角度" class="headerlink" title="Proxy角度"></a>Proxy角度</h3><p>Proxy在自己的sum方法中，会使用Parcelable来准备数据，把函数名称、函数参数都写入<code>_data</code>，让<code>_reply</code>接收函数返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> java.lang.String <span class="hljs-title function_">getStringFromService</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> android.os.RemoteException<br>&#123;<br>    android.os.<span class="hljs-type">Parcel</span> <span class="hljs-variable">_data</span> <span class="hljs-operator">=</span> android.os.Parcel.obtain();<br>    android.os.<span class="hljs-type">Parcel</span> <span class="hljs-variable">_reply</span> <span class="hljs-operator">=</span> android.os.Parcel.obtain();<br>    java.lang.String _result;<br>    <span class="hljs-keyword">try</span> &#123;<br>        _data.writeInterfaceToken(DESCRIPTOR);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">_status</span> <span class="hljs-operator">=</span> mRemote.transact(Stub.TRANSACTION_getStringFromService, _data, _reply, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> getDefaultImpl().getStringFromService();<br>        &#125;<br>        _reply.readException();<br>        _result = _reply.readString();<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        _reply.recycle();<br>        _data.recycle();<br>    &#125;<br>    <span class="hljs-keyword">return</span> _result;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">boolean <span class="hljs-variable">_status</span> = mRemote.transact(Stub.TRANSACTION_getStringFromService, <span class="hljs-variable">_data</span>, <span class="hljs-variable">_reply</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="Server角度"><a href="#Server角度" class="headerlink" title="Server角度"></a>Server角度</h3><p>通过onTransact方法接收Client进程传过来的数据，包括函数名称、函数参数，找到对应的函数（这里是sum），把参数喂进去，得到结果，返回。经典的读数据 –&gt; 逻辑 –&gt; 写数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onTransact</span><span class="hljs-params">(<span class="hljs-type">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="hljs-type">int</span> flags)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException<br>&#123;<br>    java.lang.<span class="hljs-type">String</span> <span class="hljs-variable">descriptor</span> <span class="hljs-operator">=</span> DESCRIPTOR;<br>    <span class="hljs-keyword">switch</span> (code)<br>    &#123;<br>        <span class="hljs-keyword">case</span> INTERFACE_TRANSACTION:<br>            &#123;<br>                reply.writeString(descriptor);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        <span class="hljs-keyword">case</span> TRANSACTION_getStringFromService:<br>            &#123;<br>                data.enforceInterface(descriptor);<br>                java.lang.<span class="hljs-type">String</span> <span class="hljs-variable">_result</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getStringFromService();<br>                reply.writeNoException();<br>                reply.writeString(_result);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        <span class="hljs-keyword">default</span>:<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.onTransact(code, data, reply, flags);<br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>四大组件的启动和后续流程，都是在与AMS通信，基于Binder。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>插件化</tag>
      
      <tag>Design Patterns</tag>
      
      <tag>IPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Android插件化》读书笔记（四）Activity工作原理</title>
    <link href="/2023/02/21/%E3%80%8AAndroid%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89Activity%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <url>/2023/02/21/%E3%80%8AAndroid%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89Activity%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="AMS"><a href="#AMS" class="headerlink" title="AMS"></a>AMS</h1><p>管理Activity，作为Binder模型中的Server。</p><blockquote><p>Q：App的安装过程，为什么不直接把Apk解压缩到本地。</p><p>待解答。</p></blockquote><blockquote><p>Q：为什么Hook永远是在Binder Client端，也就是四大组件这边，而不是在AMS边进行Hook。</p><p>AMS要负责和所有App的四大组件进行通信，Hook易导致功能停止。</p><p>而在Client端做Hook，只影响Hook代码所在的App。</p></blockquote><h1 id="App启动"><a href="#App启动" class="headerlink" title="App启动"></a>App启动</h1><blockquote><p>Activity工作原理。</p></blockquote><h2 id="App启动简述"><a href="#App启动简述" class="headerlink" title="App启动简述"></a>App启动简述</h2><p>Launcher，为每个App的图标提供了启动这个App所需要的Intent信息。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">action：android<span class="hljs-selector-class">.intent</span><span class="hljs-selector-class">.action</span><span class="hljs-selector-class">.MAIN</span><br>category: android<span class="hljs-selector-class">.intent</span><span class="hljs-selector-class">.category</span><span class="hljs-selector-class">.LAUNCHER</span><br>cmp: 包名 + 首页Activity名<br></code></pre></td></tr></table></figure><blockquote><p>对应到AndvoidManifest文件中定义为首页的Activity的<code>&lt;intent-filter&gt;</code>。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sqf">&lt;<span class="hljs-built_in">action</span> android:<span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;android.intent.action.MAIN&quot;</span> /&gt;<br>&lt;category android:<span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;<br></code></pre></td></tr></table></figure></blockquote><p>这些信息是App安装（或Android系统启动）的时候，PackageManagerService（PMS）从Apk包的AndroidManifest文件中读取到的。</p><p>Launcher和App位于不同的进程，其通信通过Binder完成。强调通信过程后，由更详细的过程，以下分步骤。</p><h2 id="Launcher通知AMS"><a href="#Launcher通知AMS" class="headerlink" title="Launcher通知AMS"></a>Launcher通知AMS</h2><h3 id="点击图标"><a href="#点击图标" class="headerlink" title="点击图标"></a>点击图标</h3><p>点击<strong>App快捷图标</strong>，会调用Launcher的startActivitySafely方法，其实还是会调用startActivity方法，intent需要带着启动该App所需要的关键信息（该信息在App安装过程中，”记录“在Launcher的该App的快捷图标中）。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sqf">&lt;<span class="hljs-built_in">action</span> android:<span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;android.intent.action.MAIN&quot;</span> /&gt;<br>&lt;category android:<span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;<br>cmp：该App包名 + 首页Activity名<br></code></pre></td></tr></table></figure><p>而该App的AndroidManifest文件中，也在首页Activity的<code>&lt;intent-filter&gt;</code>指定action和category。</p><p><img src="/2023/02/21/%E3%80%8AAndroid%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89Activity%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/launcher2AMS.png"></p><p>startActivity，调用startActivityForResult。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// -1：不关心App是否启动成功的返回结果</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startActivity</span><span class="hljs-params">(Intent intent, ...)</span> &#123;<br>    startActivityForResult(intent, -<span class="hljs-number">1</span>, options);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Launcher-startActivityForResult"><a href="#Launcher-startActivityForResult" class="headerlink" title="Launcher startActivityForResult"></a>Launcher startActivityForResult</h3><p>startActivityForResult方法的实现中，调用Instrumentation的execStartActivity。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startActivityForResult</span><span class="hljs-params">(Intent intent, ...)</span> &#123;<br>    Instrumentation.<span class="hljs-type">ActivityResult</span> <span class="hljs-variable">ar</span> <span class="hljs-operator">=</span><br>        mInstrumentation.execStartActivity(<br>            <span class="hljs-built_in">this</span>, mMainThread.getApplicationThread(), mToken, <span class="hljs-built_in">this</span>,<br>            intent, requestCode, options);<br>&#125;<br></code></pre></td></tr></table></figure><p>mMainThread变量，ActivityThread类型。</p><blockquote><p>ActivityThread，主线程，是UI线程，在App启动时创建，代表了App应用程序。</p><p>Application，ActivityThread的上下文。</p></blockquote><blockquote><p>一般程序由开发者提供main函数作为入口；Android App的入口是AndroidManifest中定义默认启动Activity。</p><blockquote><p>Android的main函数在ActivityThread中。这个类是Android系统提供的底层类，不由开发者提供。</p></blockquote></blockquote><p>通过ActivityThread的getApplicationThread方法取到一个Binder对象，对象的类型为ApplicationThread，代表了Launcher所在的App进程。</p><p>mToken也是一个Binder对象，代表Launcher这个Activity也通过Instrumentation传给AMS。</p><p>AMS通过类似路由的机制，记录下Launcher”IP地址“（这两个参数）。</p><h3 id="Instrumentation-execStartActivity"><a href="#Instrumentation-execStartActivity" class="headerlink" title="Instrumentation execStartActivity"></a>Instrumentation execStartActivity</h3><p>帮助启动Activity。</p><p>这里借助Instrumentation做一个透传，借助Instrumentation，Activity把数据传递给ActivityManagerNative。</p><h3 id="AMN-getDefault"><a href="#AMN-getDefault" class="headerlink" title="AMN getDefault"></a>AMN getDefault</h3><p>AMN通过getDefault方法，从ServiceManager（一个容器类）中取得一个名为activity的对象，然后把它包装成一个ActivityManagerProxy对象（AMP），作为AMS的代理对象。</p><blockquote><p>AMN的getDefault方法返回类型为IActivityManager，而不是AMP。IActivityManager是一个实现了IInterface的接口，里面定义了四大组件所有的生命周期。</p></blockquote><p><img src="/2023/02/21/%E3%80%8AAndroid%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89Activity%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/AMNAMPClass.png"></p><p>AMN和AMP都实现了IActivityManager接口，AMS继承自AMN，<strong>AIDL</strong>。</p><h3 id="AMP-startActivity"><a href="#AMP-startActivity" class="headerlink" title="AMP startActivity"></a>AMP startActivity</h3><p>AMP的startActivity和AIDL的Proxy方法一样，写入数据到另一个进程，也就是AMS，然后等待AMS返回结果。</p><h2 id="AMS处理Launcher传过来的信息"><a href="#AMS处理Launcher传过来的信息" class="headerlink" title="AMS处理Launcher传过来的信息"></a>AMS处理Launcher传过来的信息</h2><blockquote><p>AMS大部分逻辑和开发者无关。</p></blockquote><p>Binder的Server端在做事情，过程如下。</p><p>Binder（也就是AMN&#x2F;AMP）和AMS通信，希望启动App，发送类型为START_ACTIVITY的请求给AMS，同时会告诉AMS要启动哪个Activity。</p><p>AMS检查App中的AndroidManifest文件，是否存在要启动的Activity。</p><p><img src="/2023/02/21/%E3%80%8AAndroid%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89Activity%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/IAPClass.png"></p><p>AMS通知Launcher，Launcher完成传递使命了，可以休眠了。Launcher以及它所在的进程在AMS这边保存为一个ActivityRecord对象，该对象里面有一个ApplicationThreadProxy，ApplicationThread的代理对象。</p><p>AMS通过ApplicationThreadProxy发送消息，而App端则通过ApplicationThread来接收这个消息。</p><h2 id="Launcher休眠并通知AMS"><a href="#Launcher休眠并通知AMS" class="headerlink" title="Launcher休眠并通知AMS"></a>Launcher休眠并通知AMS</h2><p><img src="/2023/02/21/%E3%80%8AAndroid%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89Activity%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/launcher2AMS2.png"></p><p>ApplicationThread（APT）接收到来自AMS的消息后，调用ActivityThread（主线程）的sendMessage方法，向Launcher的主线程消息队列发送一个PAUSE_ACTIVITY消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(<span class="hljs-type">int</span> what, Object obj, <span class="hljs-type">int</span> arg, ...)</span> &#123;<br>    <span class="hljs-keyword">if</span> (DEBUG_MESSAGES)<br>        Slog.v(TAG, <span class="hljs-string">&quot;SCHEDULE &quot;</span> + what + <span class="hljs-string">&quot; &quot;</span> + mH.codeToString(what)<br>               + <span class="hljs-string">&quot;: &quot;</span> + arg1 + <span class="hljs-string">&quot; / &quot;</span> + obj);<br>    <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> Message.obtain();<br>    msg.what = what;<br>    msg.obj = obj;<br>    msg.arg1 = arg1;<br>    msg.arg2 = arg2;<br>    <span class="hljs-keyword">if</span> (async) &#123;<br>        msg.setAsynchronous(<span class="hljs-literal">true</span>);<br>    &#125;<br>    mH.sendMessage(msg);<br>&#125;<br></code></pre></td></tr></table></figure><p>发送消息是通过一个名为<strong>H</strong>的Handler类的完成。AMS给Activity发送的所有消息，以及给其他三大组件发送的所有消息，都从H这里经过（switch … case …做处理）。</p><blockquote><p>那么可以在这里做插件化技术。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityThread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">H</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="hljs-string">&quot;&gt;&gt;&gt; handling: &quot;</span> + codeToString(msg.what));<br>        <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>            <span class="hljs-keyword">case</span> PAUSE_ACTIVITY:<br>                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;activityPause&quot;</span>);<br>                handlePauseActivity((IBinder)msg.obj, <span class="hljs-literal">false</span>, (msg.arg1&amp;<span class="hljs-number">1</span>) != <span class="hljs-number">0</span>, msg.arg2, (msg.arg1&amp;<span class="hljs-number">2</span>) != <span class="hljs-number">0</span>);<br>                maybeSnapshot();<br>                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>H对PAUSE_ACTIVITY消息的处理，是调用ActivityThread的handlePauseActivity方法，该方法</p><ul><li>ActivityThread里面有一个mActivities集合，保存当前App也就是Launcher中所有打开的Activity，把它找出来，让它休眠；</li><li>通过AMP通知AMS，已经休眠。</li></ul><blockquote><p>H和APT都是ActivityThread的内嵌类，无类文件。</p></blockquote><p>以上，Launcher的工作完成了。</p><h2 id="AMS启动新的进程"><a href="#AMS启动新的进程" class="headerlink" title="AMS启动新的进程"></a>AMS启动新的进程</h2><p>AMS接下来要启动App的首页，App不在后台进程中，所以要启动一个新的进程。Process.start方法，并且指定了ActivityThread的main函数为入口函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">pid</span> <span class="hljs-operator">=</span> Process.start(“android.app.ActivityThread”, mSimpleProcessManagement ? app.processName : gid, debugFl ...)<br></code></pre></td></tr></table></figure><h2 id="启动新的进程"><a href="#启动新的进程" class="headerlink" title="启动新的进程"></a>启动新的进程</h2><p>以ActivityThread的main函数作为入口。</p><p>启动新进程，其实就是启动一个新的App。</p><p><img src="/2023/02/21/%E3%80%8AAndroid%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89Activity%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/newThread.png"></p><p>在启动新进程的时候，为这个进程创建<br>ActivityThread对象，这就是我们耳熟能详的主线程（UI线程）。创建好UI线程后，立刻进入ActivityThread的main函数，</p><ul><li>创建一个主线程Looper，也就是MainLooper；</li><li>创建Application。</li></ul><p>主线程在收到BIND_APPLICATION消息后，根据传递过来的ApplicationInfo创建一个对应的LoadedApk对象（标志当前APK信息），然后创建ContextImpl对象（标志当前进程的环境），紧接着通过反射创建目标Application，并调用其attach方法，将ContextImpl对象设置为目标Application的上</p><h1 id="App内部的页面跳转"><a href="#App内部的页面跳转" class="headerlink" title="App内部的页面跳转"></a>App内部的页面跳转</h1><p>从ActivityA跳转到ActivityB，可以把ActivityA当作Launcher，这个过程不需要重新启动一个新的进程，可以简化流程。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《Android插件化》读书笔记（三）封装反射语法</title>
    <link href="/2023/02/20/%E3%80%8AAndroid%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%B0%81%E8%A3%85%E5%8F%8D%E5%B0%84%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/02/20/%E3%80%8AAndroid%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%B0%81%E8%A3%85%E5%8F%8D%E5%B0%84%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="对反射的简单封装"><a href="#对反射的简单封装" class="headerlink" title="对反射的简单封装"></a>对反射的简单封装</h1><p>对反射的简单封装如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AncenReflection</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">create</span><span class="hljs-params">(String className, Class[] paramTypes, Object[] paramValues)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(className);<br>            <span class="hljs-type">Constructor</span> <span class="hljs-variable">ctor</span> <span class="hljs-operator">=</span> cls.getDeclaredConstructor(paramTypes);<br><br>            <span class="hljs-keyword">return</span> ctor.newInstance(paramValues);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">invokeInstanceMethod</span><span class="hljs-params">(Object obj, String methodName, Class[] paramTypes, Object[] paramValues)</span> &#123;<br>        <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 调用private方法</span><br>            <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredMethod(methodName, paramTypes);<br>            method.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> method.invoke(obj, paramValues);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">invokeStaticMethod</span><span class="hljs-params">(String className, String methodName, Class[] paramTypes, Object[] paramValues)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(className);<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> cls.getDeclaredMethod(methodName, paramTypes);<br>            method.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> method.invoke(<span class="hljs-literal">null</span>, paramValues);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getFieldObject</span><span class="hljs-params">(String className, Object obj, String fieldName)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(className);<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> cls.getDeclaredField(fieldName);<br>            field.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> field.get(obj);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFieldObject</span><span class="hljs-params">(String className, Object obj, String fieldName, Object fieldVaule)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(className);<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> cls.getDeclaredField(fieldName);<br>            field.setAccessible(<span class="hljs-literal">true</span>);<br>            field.set(obj, fieldVaule);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">clsname</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;com.ancen.testreflection.TestClassCtor&quot;</span>);<br>    <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(clsname);<br>    Class[] p3 = &#123;<span class="hljs-type">int</span>.class, String.class&#125;;<br>    Object[] v3 = &#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Ancen&quot;</span>&#125;;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> AncenReflection.create(clsname, p3, v3);<br>    Class[] p4 = &#123;String.class&#125;;<br>    Object[] v4 = &#123;<span class="hljs-string">&quot;Ancen_2&quot;</span>&#125;;<br>    AncenReflection.invokeStaticMethod(clsname, <span class="hljs-string">&quot;work&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="对反射进一步封装"><a href="#对反射进一步封装" class="headerlink" title="对反射进一步封装"></a>对反射进一步封装</h1><ul><li>重载（参数数量；Class cls、String className）；</li><li>区分静态字段和实例字段；</li><li>简化获取字段和设置字段的方法（减少参数数量）。</li></ul><blockquote><p>代码附在最后。</p></blockquote><h1 id="jOOR"><a href="#jOOR" class="headerlink" title="jOOR"></a>jOOR</h1><ul><li><p>Reflect.java</p></li><li><p>ReflectException.java</p></li></ul><blockquote><p>只有两个类，可以直接拖进项目。</p></blockquote><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>onClass()：包裹一个类或者对象，表示在这个类或对象上进行反射，类的值可以是Class，也可以是完整的类名（包含包名信息）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @param name</span><br><span class="hljs-comment"> * A fully qualified class name.</span><br><span class="hljs-comment"> * @param classLoader</span><br><span class="hljs-comment"> * The class loader in whose context the class should be loaded.</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-type">Reflect</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> onClass(Object.class);<br><span class="hljs-type">Reflect</span> <span class="hljs-variable">r2</span> <span class="hljs-operator">=</span> onClass(<span class="hljs-string">&quot;java.lang.Object&quot;</span>);<br><span class="hljs-type">Reflect</span> <span class="hljs-variable">r3</span> <span class="hljs-operator">=</span> onClass(<span class="hljs-string">&quot;java.lang.Object&quot;</span>, ClassLoader.getSystemClassLoader());<br><br><span class="hljs-comment">// 等价于Class.forName()</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">Class</span> <span class="hljs-variable">j4</span> <span class="hljs-operator">=</span> onClass(<span class="hljs-string">&quot;android.widget.Button&quot;</span>).type();<br>&#125;<br><span class="hljs-keyword">catch</span> (ReflectException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="调用构造方法"><a href="#调用构造方法" class="headerlink" title="调用构造方法"></a>调用构造方法</h2><p>onCreate()：用来调用之前的类的构造方法，有两种重载，一种有参数，一种无参数；返回Reflect包裹体。可以通过get()获取返回值拿到构造的类的实例。</p><p>get()：获取（field和method返回）值相关，会进行类型转换，常与call组合使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TestClassCtor</span> <span class="hljs-variable">testClassCtor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestClassCtor</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> testClassCtor.getClass();<br><span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> temp.getName();<br><br><span class="hljs-comment">// public构造函数</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> onClass(temp).create().get();<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> onClass(temp).create(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;abc&quot;</span>).get();<br><br><span class="hljs-comment">// private构造函数</span><br><span class="hljs-type">TestClassCtor</span> <span class="hljs-variable">obj3</span> <span class="hljs-operator">=</span> onClass(TestClassCtor.class).create(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;abc&quot;</span>).get();<br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> obj3.getName();<br>Log.d(<span class="hljs-string">&quot;Ancen&quot;</span>, a);<br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">D/Ancen: abc</span><br></code></pre></td></tr></table></figure><h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><p>call()：方法调用，传入方法名和参数，如有返回值还需要调用get。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建对象</span><br><span class="hljs-type">TestClassCtor</span> <span class="hljs-variable">testClassCtor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestClassCtor</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> testClassCtor.getClass();<br><span class="hljs-type">Reflect</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> onClass(temp).create();<br><br><span class="hljs-comment">// 调用一个private实例方法</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> r.call(<span class="hljs-string">&quot;doSomething&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>).get();<br><span class="hljs-comment">// 调用一个public实例方法</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> r.call(<span class="hljs-string">&quot;getName&quot;</span>).get();<br><span class="hljs-comment">// 调用一个private静态方法</span><br>onClass(TestClassCtor.class).call(<span class="hljs-string">&quot;work&quot;</span>).get();<br><span class="hljs-comment">// 调用一个public静态方法</span><br>onClass(TestClassCtor.class).call(<span class="hljs-string">&quot;printAddress&quot;</span>).get();<br></code></pre></td></tr></table></figure><h2 id="访问字段"><a href="#访问字段" class="headerlink" title="访问字段"></a>访问字段</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取实例字段并修改</span><br><span class="hljs-type">Reflect</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> onClass(<span class="hljs-string">&quot;com.ancen.testreflection.TestClassCtor&quot;</span>)<br>    .create(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;abc&quot;</span>);<br>r.set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Ancen_2&quot;</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> r.get(<span class="hljs-string">&quot;name&quot;</span>);<br><br><span class="hljs-comment">// 获取静态字段并修改</span><br>onClass(<span class="hljs-string">&quot;com.ancen.testreflection.TestClassCtor&quot;</span>)<br>    .set(<span class="hljs-string">&quot;address&quot;</span>, <span class="hljs-string">&quot;ac&quot;</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> onClass(<span class="hljs-string">&quot;com.ancen.testreflection.TestClassCtor&quot;</span>)<br>    .get(<span class="hljs-string">&quot;address&quot;</span>);<br><br>Log.d(<span class="hljs-string">&quot;Ancen&quot;</span>, obj1.toString());<br>Log.d(<span class="hljs-string">&quot;Ancen&quot;</span>, obj2.toString());<br></code></pre></td></tr></table></figure><h2 id="对泛型的反射"><a href="#对泛型的反射" class="headerlink" title="对泛型的反射"></a>对泛型的反射</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取AMN的gDefault单例gDefault，gDefault是静态的</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">gDefault</span> <span class="hljs-operator">=</span> onClass(<span class="hljs-string">&quot;com.ancen.testreflection.AMN&quot;</span>).get(<span class="hljs-string">&quot;gDefault&quot;</span>);<br><br><span class="hljs-comment">// gDefault是一个android.util.Singleton对象</span><br><span class="hljs-comment">// 取出这个单例里面的mInstance字段</span><br><span class="hljs-comment">// mInstance是初始的ClassB2Interface对象</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">mInstance</span> <span class="hljs-operator">=</span> onClass(gDefault).get(<span class="hljs-string">&quot;mInstance&quot;</span>);<br><br><span class="hljs-comment">// 创建一个这个对象的代理对象ClassB2Mock, 然后替换这个字段</span><br>Class&lt;?&gt; classB2Interface = onClass(<span class="hljs-string">&quot;com.ancen.testreflection.ClassB2Interface&quot;</span>).type();<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @param ClassLoader loader</span><br><span class="hljs-comment"> * 用哪个类加载器去加载代理对象</span><br><span class="hljs-comment"> * @param Class&lt;?&gt;[] interfaces</span><br><span class="hljs-comment"> * 动态代理类需要实现的接口</span><br><span class="hljs-comment"> * @param reflect.InvocationHandler h</span><br><span class="hljs-comment"> * 动态代理方法在执行时，会调用h里面的invoke方法去执行</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> Proxy.newProxyInstance(<br>        Thread.currentThread().getContextClassLoader(),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[] &#123; classB2Interface &#125;,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassB2Mock</span>(mInstance));<br>onClass(gDefault).set(<span class="hljs-string">&quot;mInstance&quot;</span>, proxy);<br></code></pre></td></tr></table></figure><h2 id="jOOR缺陷"><a href="#jOOR缺陷" class="headerlink" title="jOOR缺陷"></a>jOOR缺陷</h2><p>jOOR在Android领域有个很大的缺陷，jOOR不支持反射final类型的字段。</p><blockquote><p>2023年做实验，已经支持了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Ancen&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实例字段</span><br><span class="hljs-type">Reflect</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> onClass(<span class="hljs-string">&quot;com.ancen.testreflection.User&quot;</span>).create();<br>obj.set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Ancen_2&quot;</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">newObj</span> <span class="hljs-operator">=</span> obj.get(<span class="hljs-string">&quot;name&quot;</span>);<br>Log.d(<span class="hljs-string">&quot;Ancen&quot;</span>, newObj.toString());<br><br><span class="hljs-comment">// 静态字段</span><br><span class="hljs-type">Reflect</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> onClass(<span class="hljs-string">&quot;com.ancen.testreflection.User&quot;</span>);<br>obj2.set(<span class="hljs-string">&quot;userId&quot;</span>, <span class="hljs-number">1</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">newObj2</span> <span class="hljs-operator">=</span> obj2.get(<span class="hljs-string">&quot;userId&quot;</span>);<br>Log.d(<span class="hljs-string">&quot;Ancen&quot;</span>, newObj2.toString());<br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">D/Ancen: Ancen_2</span><br><span class="hljs-section">D/Ancen: 1</span><br></code></pre></td></tr></table></figure><h1 id="对反射进一步封装（Code）"><a href="#对反射进一步封装（Code）" class="headerlink" title="对反射进一步封装（Code）"></a>对反射进一步封装（Code）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ancen.testreflection;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AncenReflection</span> &#123;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 构造函数</span><br><span class="hljs-comment">     * 无参</span><br><span class="hljs-comment">     * 一个参数</span><br><span class="hljs-comment">     * 多个参数</span><br><span class="hljs-comment">     * */</span><br><br>    <span class="hljs-comment">// 无参</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">create</span><span class="hljs-params">(String className)</span> &#123;<br>        Class[] paramTypes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;;<br>        Object[] paramValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;&#125;;<br>        <span class="hljs-keyword">return</span> create(className, paramTypes, paramValues);<br>    &#125;<br><br>    <span class="hljs-comment">// 无参</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">create</span><span class="hljs-params">(Class cls)</span> &#123;<br>        Class[] paramTypes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;;<br>        Object[] paramValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;&#125;;<br>        <span class="hljs-keyword">return</span> create(cls, paramTypes, paramValues);<br>    &#125;<br><br>    <span class="hljs-comment">// 一个参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">create</span><span class="hljs-params">(String className, Class paramType, Object paramValue)</span> &#123;<br>        Class[] paramTypes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;paramType&#125;;<br>        Object[] paramValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;paramValue&#125;;<br>        <span class="hljs-keyword">return</span> create(className, paramTypes, paramValues);<br>    &#125;<br><br>    <span class="hljs-comment">// 一个参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">create</span><span class="hljs-params">(Class cls, Class paramType, Object paramValue)</span> &#123;<br>        Class[] paramTypes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;paramType&#125;;<br>        Object[] paramValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;paramValue&#125;;<br>        <span class="hljs-keyword">return</span> create(cls, paramTypes, paramValues);<br>    &#125;<br><br>    <span class="hljs-comment">// 多个参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">create</span><span class="hljs-params">(String className, Class[] paramTypes, Object[] paramValues)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(className);<br>            <span class="hljs-type">Constructor</span> <span class="hljs-variable">ctor</span> <span class="hljs-operator">=</span> cls.getDeclaredConstructor(paramTypes);<br>            <span class="hljs-keyword">return</span> ctor.newInstance(paramValues);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 多个参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">create</span><span class="hljs-params">(Class cls, Class[] paramTypes, Object[] paramValues)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Constructor</span> <span class="hljs-variable">ctor</span> <span class="hljs-operator">=</span> cls.getDeclaredConstructor(paramTypes);<br>            <span class="hljs-keyword">return</span> ctor.newInstance(paramValues);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 调用实例方法</span><br><span class="hljs-comment">     * 无参</span><br><span class="hljs-comment">     * 一个参数</span><br><span class="hljs-comment">     * 多个参数</span><br><span class="hljs-comment">     * */</span><br><br>    <span class="hljs-comment">// 无参</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">invokeInstanceMethod</span><span class="hljs-params">(Object obj, String methodName)</span> &#123;<br>        Class[] paramTypes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;;<br>        Object[] paramValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;&#125;;<br>        <span class="hljs-keyword">return</span> invokeInstanceMethod(obj, methodName, paramTypes, paramValues);<br>    &#125;<br><br>    <span class="hljs-comment">// 一个参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">invokeInstanceMethod</span><span class="hljs-params">(Object obj, String methodName, Class paramType, Object paramValue)</span> &#123;<br>        Class[] paramTypes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;paramType&#125;;<br>        Object[] paramValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;paramValue&#125;;<br>        <span class="hljs-keyword">return</span> invokeInstanceMethod(obj, methodName, paramTypes, paramValues);<br>    &#125;<br><br>    <span class="hljs-comment">// 多个参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">invokeInstanceMethod</span><span class="hljs-params">(Object obj, String methodName, Class[] paramTypes, Object[] paramValues)</span> &#123;<br>        <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 调用private方法</span><br>            <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredMethod(methodName, paramTypes);<br>            method.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> method.invoke(obj, paramValues);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 调用静态方法</span><br><span class="hljs-comment">     * 无参</span><br><span class="hljs-comment">     * 一个参数</span><br><span class="hljs-comment">     * 多个参数</span><br><span class="hljs-comment">     * */</span><br><br>    <span class="hljs-comment">// 无参</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">invokeStaticMethod</span><span class="hljs-params">(String className, String methodName)</span> &#123;<br>        Class[] paramTypes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;;<br>        Object[] paramValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;&#125;;<br>        <span class="hljs-keyword">return</span> invokeStaticMethod(className, methodName, paramTypes, paramValues);<br>    &#125;<br><br>    <span class="hljs-comment">// 无参</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">invokeStaticMethod</span><span class="hljs-params">(Class cls, String methodName)</span> &#123;<br>        Class[] paramTypes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;;<br>        Object[] paramValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;&#125;;<br>        <span class="hljs-keyword">return</span> invokeStaticMethod(cls, methodName, paramTypes, paramValues);<br>    &#125;<br><br>    <span class="hljs-comment">// 一个参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">invokeStaticMethod</span><span class="hljs-params">(String className, String methodName, Class paramType, Object paramValue)</span> &#123;<br>        Class[] paramTypes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;paramType&#125;;<br>        Object[] paramValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;paramValue&#125;;<br>        <span class="hljs-keyword">return</span> invokeStaticMethod(className, methodName, paramTypes, paramValues);<br>    &#125;<br><br>    <span class="hljs-comment">// 一个参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">invokeStaticMethod</span><span class="hljs-params">(Class cls, String methodName, Class paramType, Object paramValue)</span> &#123;<br>        Class[] paramTypes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;paramType&#125;;<br>        Object[] paramValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;paramValue&#125;;<br>        <span class="hljs-keyword">return</span> invokeStaticMethod(cls, methodName, paramTypes, paramValues);<br>    &#125;<br><br>    <span class="hljs-comment">// 多个参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">invokeStaticMethod</span><span class="hljs-params">(String className, String methodName, Class[] paramTypes, Object[] paramValues)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(className);<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> cls.getDeclaredMethod(methodName, paramTypes);<br>            method.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> method.invoke(<span class="hljs-literal">null</span>, paramValues);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 多个参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">invokeStaticMethod</span><span class="hljs-params">(Class cls, String methodName, Class[] paramTypes, Object[] paramValues)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> cls.getDeclaredMethod(methodName, paramTypes);<br>            method.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> method.invoke(<span class="hljs-literal">null</span>, paramValues);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 调用静态方法</span><br><span class="hljs-comment">     * 区分静态和实例</span><br><span class="hljs-comment">     * 传入参数：String className；Class cls；Object obj</span><br><span class="hljs-comment">     * */</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getFieldObject</span><span class="hljs-params">(String className, Object obj, String fieldName)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(className);<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> cls.getDeclaredField(fieldName);<br>            field.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> field.get(obj);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getFieldObject</span><span class="hljs-params">(Class cls, Object obj, String fieldName)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> cls.getDeclaredField(fieldName);<br>            field.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> field.get(obj);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFieldObject</span><span class="hljs-params">(String className, Object obj, String fieldName, Object fieldValue)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(className);<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> cls.getDeclaredField(fieldName);<br>            field.setAccessible(<span class="hljs-literal">true</span>);<br>            field.set(obj, fieldValue);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFieldObject</span><span class="hljs-params">(Class cls, Object obj, String fieldName, Object fieldValue)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> cls.getDeclaredField(fieldName);<br>            field.setAccessible(<span class="hljs-literal">true</span>);<br>            field.set(obj, fieldValue);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFieldObject</span><span class="hljs-params">(Object obj, String fieldName, Object fieldValue)</span> &#123;<br>        setFieldObject(obj.getClass(), obj, fieldName, fieldValue);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getStaticFieldObject</span><span class="hljs-params">(String className, String fieldName)</span> &#123;<br>        <span class="hljs-keyword">return</span> getFieldObject(className, <span class="hljs-literal">null</span>, fieldName);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getStaticFieldObject</span><span class="hljs-params">(Class cls, String fieldName)</span> &#123;<br>        <span class="hljs-keyword">return</span> getFieldObject(cls, <span class="hljs-literal">null</span>, fieldName);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getStaticFieldObject</span><span class="hljs-params">(Object obj, String fieldName)</span> &#123;<br>        <span class="hljs-keyword">return</span> getFieldObject(obj.getClass(), <span class="hljs-literal">null</span>, fieldName);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStaticFieldObject</span><span class="hljs-params">(String classname, String fieldName, Object fieldValue)</span> &#123;<br>        setFieldObject(classname, <span class="hljs-literal">null</span>, fieldName, fieldValue);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStaticFieldObject</span><span class="hljs-params">(Class cls, String fieldName, Object fieldValue)</span> &#123;<br>        setFieldObject(cls, <span class="hljs-literal">null</span>, fieldName, fieldValue);<br>    &#125;<br><br>    <span class="hljs-comment">// 暂时不允许通过实例访问setStaticFieldObject来设置静态变量</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>插件化</tag>
      
      <tag>Java</tag>
      
      <tag>反射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Head First Design Patterns》读书笔记（一）欢迎来到设计模式</title>
    <link href="/2023/02/19/%E3%80%8AHead-First-Design-Patterns%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/19/%E3%80%8AHead-First-Design-Patterns%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>当涉及维护时，为了复用（reuse）目的而是用继承，结局不一定好；子类不同方法都需要特意维护。用接口，则代码无法复用（接口不具有实现代码），方法修改时，所有子类都需要修改。</p></blockquote><p>采用良好的OO软件设计原则。<strong>找出应用中可能需要变化的地方，把它们独立出来，不要和那些不需要变化的代码混在一起。</strong>总是封装可能会变化的部分，以便以后可以轻松修改此部分。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Design Patterns</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Android第一行代码》读书笔记（二）UI</title>
    <link href="/2023/02/19/%E3%80%8AAndroid%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89UI/"/>
    <url>/2023/02/19/%E3%80%8AAndroid%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89UI/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《Android第一行代码》读书笔记（一）Activity</title>
    <link href="/2023/02/18/%E3%80%8AAndroid%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89Activity/"/>
    <url>/2023/02/18/%E3%80%8AAndroid%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89Activity/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《Android插件化》读书笔记（二）Java原生反射</title>
    <link href="/2023/02/18/%E3%80%8AAndroid%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Java%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%B0%84/"/>
    <url>/2023/02/18/%E3%80%8AAndroid%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Java%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h1><blockquote><p>Java原生语法。</p></blockquote><p>class（包括interface）的本质是数据类型（Type）。由JVM在执行过程中动态加载的。JVM在第一次读取到一种class类型时，将其加载进内存。<strong>每加载一种类，JVM就为其创建一个Class类型的实例，并关联起来。</strong></p><blockquote><p>这里的Class类型也是一个名叫Class的class。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Class</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-title function_">Class</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>以String类为例，当JVM加载String类时，它首先读取String.class文件到内存，然后，为String类创建一个Class实例并关联起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>(String);<br></code></pre></td></tr></table></figure><blockquote><p>这个Class实例是JVM内部创建的，Class类的构造方法是private，只有JVM能创建Class实例，自己的Java程序是无法创建Class实例的。</p></blockquote><p><strong>JVM持有的每个Class实例都指向一个数据类型（class或interface）</strong>。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs coq">┌───────────────────────────┐<br>│      <span class="hljs-keyword">Class</span> <span class="hljs-keyword">Instance</span>       │──────&gt; String<br>├───────────────────────────┤<br>│name = <span class="hljs-string">&quot;java.lang.String&quot;</span>  │<br>└───────────────────────────┘<br>┌───────────────────────────┐<br>│      <span class="hljs-keyword">Class</span> <span class="hljs-keyword">Instance</span>       │──────&gt; Random<br>├───────────────────────────┤<br>│name = <span class="hljs-string">&quot;java.util.Random&quot;</span>  │<br>└───────────────────────────┘<br>┌───────────────────────────┐<br>│      <span class="hljs-keyword">Class</span> <span class="hljs-keyword">Instance</span>       │──────&gt; Runnable<br>├───────────────────────────┤<br>│name = <span class="hljs-string">&quot;java.lang.Runnable&quot;</span>│<br>└───────────────────────────┘<br></code></pre></td></tr></table></figure><p>一个Class实例包含了该class的所有完整信息。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gradle">┌───────────────────────────┐<br>│      <span class="hljs-keyword">Class</span> Instance       │──────&gt; String<br>├───────────────────────────┤<br>│name = <span class="hljs-string">&quot;java.lang.String&quot;</span>  │<br>├───────────────────────────┤<br>│<span class="hljs-keyword">package</span> = <span class="hljs-string">&quot;java.lang&quot;</span>      │<br>├───────────────────────────┤<br>│<span class="hljs-keyword">super</span> = <span class="hljs-string">&quot;java.lang.Object&quot;</span> │<br>├───────────────────────────┤<br>│<span class="hljs-keyword">interface</span> = CharSequence...│<br>├───────────────────────────┤<br>│field = value[],hash,...   │<br>├───────────────────────────┤<br>│method = indexOf()...      │<br>└───────────────────────────┘<br></code></pre></td></tr></table></figure><blockquote><p>可见，通过class的Class实例就可以获取到该实例对应的class的所有信息；且由上述可知，JVM为每个加载的class都创建了对应的Class实例，即class的Class实例存在且可获取。</p></blockquote><p><strong>这种通过Class实例获取class信息的方法称为反射（Reflection）。</strong></p><h2 id="获得Class实例"><a href="#获得Class实例" class="headerlink" title="获得Class实例"></a>获得Class实例</h2><p>由以下方法获取class的Class实例；静态方法Class.forName()最常用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// class的实例变量-&gt;class的Class实例</span><br><span class="hljs-comment">// 通过getClass，每个类都有这个函数</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> str.getClass();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// class的字符串类名-&gt;class的Class实例</span><br><span class="hljs-comment">// 这种方式最常见，通过静态方法Class.forName()</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br><span class="hljs-type">Class</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;android.widget.Button&quot;</span>);<br><span class="hljs-comment">// 通过getSuperClass获得父类，每个类都有这个函数</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">c5</span> <span class="hljs-operator">=</span> c3.getSuperclass();  <span class="hljs-comment">// 得到TextView</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// class-&gt;class的Class实例</span><br><span class="hljs-comment">// 通过.class静态属性</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">c6</span> <span class="hljs-operator">=</span> String.class;<br><span class="hljs-type">Class</span> <span class="hljs-variable">c7</span> <span class="hljs-operator">=</span> java.lang.String.class;<br><span class="hljs-type">Class</span> <span class="hljs-variable">c8</span> <span class="hljs-operator">=</span> MainActivity.InnerClass.class;<br><span class="hljs-type">Class</span> <span class="hljs-variable">c9</span> <span class="hljs-operator">=</span> <span class="hljs-type">int</span>.class;<br><span class="hljs-type">Class</span> <span class="hljs-variable">c10</span> <span class="hljs-operator">=</span> <span class="hljs-type">int</span>[].class;<br><span class="hljs-comment">// 基本类型包装类的TYPE语法</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">c11</span> <span class="hljs-operator">=</span> Boolean.TYPE;<br><span class="hljs-type">Class</span> <span class="hljs-variable">c12</span> <span class="hljs-operator">=</span> Byte.TYPE;<br><span class="hljs-type">Class</span> <span class="hljs-variable">c13</span> <span class="hljs-operator">=</span> Character.TYPE;<br><span class="hljs-type">Class</span> <span class="hljs-variable">c14</span> <span class="hljs-operator">=</span> Short.TYPE;<br><span class="hljs-type">Class</span> <span class="hljs-variable">c15</span> <span class="hljs-operator">=</span> Integer.TYPE;<br><span class="hljs-type">Class</span> <span class="hljs-variable">c16</span> <span class="hljs-operator">=</span> Long.TYPE;<br><span class="hljs-type">Class</span> <span class="hljs-variable">c17</span> <span class="hljs-operator">=</span> Float.TYPE;<br><span class="hljs-type">Class</span> <span class="hljs-variable">c18</span> <span class="hljs-operator">=</span> Double.TYPE;<br><span class="hljs-type">Class</span> <span class="hljs-variable">c19</span> <span class="hljs-operator">=</span> Void.TYPE;<br></code></pre></td></tr></table></figure><blockquote><p>得到类和对象的类型，主要用于<strong>Proxy.newProxyInstance</strong>。</p></blockquote><p>数组（例如String[]）也是一种类，而且不同于String.class，它的类名是<code>[Ljava.lang.String;</code>。JVM为每一种基本类型如int也创建了Class实例，通过int.class访问。</p><h2 id="使用Class实例"><a href="#使用Class实例" class="headerlink" title="使用Class实例"></a>使用Class实例</h2><p>可以通过获取的Class实例来创建对应类型的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取String的Class实例:</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> String.class;<br><span class="hljs-comment">// 创建一个String实例:</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (String) cls.newInstance();<br></code></pre></td></tr></table></figure><p>上述代码相当于new String()。通过Class.newInstance()可以创建类实例，<strong>它的局限是：只能调用public的无参数构造方法</strong>，带参数的构造方法，或者非public的构造方法都无法通过Class.newInstance()被调用。</p><h2 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h2><p>JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。<strong>利用JVM动态加载class的特性，可以在运行期根据条件加载不同的实现类。</strong></p><h1 id="调用构造函数"><a href="#调用构造函数" class="headerlink" title="调用构造函数"></a>调用构造函数</h1><blockquote><p>反射到类的构造函数很重要；下述流程中，存在以下重要步骤：<strong>通过字符串反射出一个类，然后通过反射获取到类的构造函数，执行构造函数得到类的实例。从类的实例出发，通过反射进一步得到实例所有字段和方法。</strong></p></blockquote><p>Class类提供了以下几个方法Constructor。</p><ul><li><p>getConstructors()：获取所有public的Constructor；</p></li><li><p>getDeclaredConstructors()：获取所有Constructor；</p></li><li><p>getConstructor(Class…)：获取某个public的Constructor；</p></li><li><p>getDeclaredConstructor(Class…)：获取某个Constructor。</p></li></ul><blockquote><p>调用非public的Constructor时，必须首先通过setAccessible(true)设置允许访问。setAccessible(true)可能会失败。</p></blockquote><h2 id="获取全部构造函数"><a href="#获取全部构造函数" class="headerlink" title="获取全部构造函数"></a>获取全部构造函数</h2><p>getDeclaredConstructors()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClassCtor</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestClassCtor</span><span class="hljs-params">()</span> &#123;<br>        name = <span class="hljs-string">&quot;Ancen&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestClassCtor</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestClassCtor</span><span class="hljs-params">(<span class="hljs-type">int</span> a, String b)</span> &#123;<br>        name = b;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">doSOmething</span><span class="hljs-params">(String d)</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;doSomething&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;abcd&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;work&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printAddress</span><span class="hljs-params">()</span> &#123;<br>        System.out.print(address);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TestClassCtor</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestClassCtor</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> r.getClass();<br><span class="hljs-comment">// 获取指定类的类名</span><br><span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> temp.getName();<br><br><span class="hljs-comment">// 获取类的所有ctor，不分public还是private</span><br>Constructor[] theConstructors = temp.getDeclaredConstructors();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; theConstructors.length; i++) &#123;<br>    <span class="hljs-comment">// 输出修饰域和方法名称</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> theConstructors[i].getModifiers();<br>    System.out.print(Modifier.toString(mod) + <span class="hljs-string">&quot; &quot;</span> + className + <span class="hljs-string">&quot;(&quot;</span>);<br><br>    <span class="hljs-comment">// 获取指定构造方法的参数的集合</span><br>    Class[] parameterTypes = theConstructors[i].getParameterTypes();<br>    <span class="hljs-comment">// 输出打印参数列表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; parameterTypes.length; j++) &#123;<br>        System.out.print(parameterTypes[j].getName());<br>        <span class="hljs-keyword">if</span> (parameterTypes.length &gt; j + <span class="hljs-number">1</span>) &#123;<br>            System.out.print(<span class="hljs-string">&quot;, &quot;</span>);<br>        &#125;<br>    &#125;<br>    System.out.print(<span class="hljs-string">&quot;)&quot;</span> + <span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">TestClassCtor</span><span class="hljs-params">(<span class="hljs-type">int</span>, java.lang.String)</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">TestClassCtor</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">TestClassCtor</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure><blockquote><p>参考获取Method对象获取所有信息的方法，构造方法也是方法。</p></blockquote><h2 id="获取某个构造函数"><a href="#获取某个构造函数" class="headerlink" title="获取某个构造函数"></a>获取某个构造函数</h2><p>getDeclaredConstructor()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取类的ctor：TestClassCtor()；无参构造函数</span><br><span class="hljs-type">Constructor</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> temp.getDeclaredConstructor();<br>System.out.print(c1 + <span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-type">Constructor</span> <span class="hljs-variable">c1_1</span> <span class="hljs-operator">=</span> temp.getConstructor();<br>System.out.print(c1_1 + <span class="hljs-string">&quot;\n&quot;</span>);<br><br><span class="hljs-comment">// 获取类的ctor：TestClassCtor(int a)</span><br>Class[] p2 = &#123; <span class="hljs-type">int</span>.class &#125;;<br><span class="hljs-type">Constructor</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> temp.getDeclaredConstructor(p2);<br>System.out.print(c2 + <span class="hljs-string">&quot;\n&quot;</span>);<br><br><span class="hljs-comment">// 获取类的ctor：TestClassCtor(int a, String b)</span><br>Class[] p3 = &#123; <span class="hljs-type">int</span>.class, String.class &#125;;<br><span class="hljs-type">Constructor</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> temp.getDeclaredConstructor(p3);<br>System.out.print(c3 + <span class="hljs-string">&quot;\n&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">TestClassCtor</span><span class="hljs-params">()</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">TestClassCtor</span><span class="hljs-params">()</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">TestClassCtor</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">TestClassCtor</span><span class="hljs-params">(<span class="hljs-type">int</span>,java.lang.String)</span><br></code></pre></td></tr></table></figure><h2 id="调用构造函数-1"><a href="#调用构造函数-1" class="headerlink" title="调用构造函数"></a>调用构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;TestClassCtor&quot;</span>);<br><br><span class="hljs-comment">// 含参</span><br>Class[] p3 = &#123; <span class="hljs-type">int</span>.class, String.class &#125;;<br><span class="hljs-type">Constructor</span> <span class="hljs-variable">ctor</span> <span class="hljs-operator">=</span> r.getDeclaredConstructor(p3);<br>ctor.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">// Object obj = ctor.newInstance(1, &quot;abc&quot;);</span><br><span class="hljs-type">TestClassCtor</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> (TestClassCtor) ctor.newInstance(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;abcde&quot;</span>);<br>obj.printAddress();<br><br><span class="hljs-comment">// 无参</span><br><span class="hljs-type">Constructor</span> <span class="hljs-variable">ctor2</span> <span class="hljs-operator">=</span> r.getDeclaredConstructor();<br><span class="hljs-comment">// Object obj2 = ctor2.newInstance();</span><br><span class="hljs-type">TestClassCtor</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> (TestClassCtor) ctor2.newInstance();<br>obj2.printAddress();<br><br><span class="hljs-comment">// 也可以使用Class的newInstance方法，但Class仅提供默认无参的实例化方法</span><br><span class="hljs-comment">// 提示，Java9，类型的newInstance()方法已经被弃用</span><br><span class="hljs-comment">// Object obj4 = r.newInstance();</span><br></code></pre></td></tr></table></figure><h1 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h1><p>Class类提供了以下几个方法来获取Method。</p><ul><li>Method getMethod(name, Class…)：获取某个public的Method（包括父类）；</li><li>Method getDeclaredMethod(name, Class…)：获取当前类的某个Method（不包括父类）；</li><li>Method[] getMethods()：获取所有public的Method（包括父类）；</li><li>Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类）。</li></ul><h2 id="获取类的私有方法并调用"><a href="#获取类的私有方法并调用" class="headerlink" title="获取类的私有方法并调用"></a>获取类的私有方法并调用</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> d</span>) &#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个对象</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;TestClassCtor&quot;</span>);<br>Class[] p3 = &#123; <span class="hljs-type">int</span>.class, String.class &#125;;<br><span class="hljs-type">Constructor</span> <span class="hljs-variable">ctor</span> <span class="hljs-operator">=</span> r.getDeclaredConstructor(p3);<br>ctor.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ctor.newInstance(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;abc&quot;</span>);<br><br><span class="hljs-comment">// 调用方法</span><br>Class[] p4 = &#123; String.class &#125;;<br><span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> r.getDeclaredMethod(<span class="hljs-string">&quot;doSOmething&quot;</span>, p4);<br>method.setAccessible(<span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 参数先写死，下面有通用的函数getMethodParamObject</span><br>Object argList[] = &#123; <span class="hljs-string">&quot;a&quot;</span> &#125;;<br><span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(obj, argList);<br></code></pre></td></tr></table></figure><blockquote><p>一个Method对象包含一个方法的所有信息：</p><ul><li>getName()：返回方法名称，例如：”getScore”；</li><li>getReturnType()：返回方法返回值类型，也是一个Class实例，例如：String.class；</li><li>getParameterTypes()：返回方法的参数类型，是一个Class数组，例如：{String.class, int.class}；</li><li>getModifiers()：返回方法的修饰符，它是一个int，不同的bit表示不同的含义。</li></ul></blockquote><h2 id="获取类的静态私有方法并调用"><a href="#获取类的静态私有方法并调用" class="headerlink" title="获取类的静态私有方法并调用"></a>获取类的静态私有方法并调用</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span>()</span> &#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个对象</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;TestClassCtor&quot;</span>);<br><br><span class="hljs-comment">// 调用方法</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> r.getDeclaredMethod(<span class="hljs-string">&quot;work&quot;</span>); <span class="hljs-comment">// 在指定类中获取指定的方法</span><br>method.setAccessible(<span class="hljs-literal">true</span>);<br>method.invoke(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><blockquote><p><strong>使用反射调用方法时，仍然遵循多态原则</strong>：即总是调用实际类型的重写方法（如果存在）。从父类Class实例拿到的方法，作用在子类实例上，还是会调用子类的重写方法。</p></blockquote><h1 id="访问字段"><a href="#访问字段" class="headerlink" title="访问字段"></a>访问字段</h1><p>Class类提供了以下几个方法来获取字段。</p><ul><li>Field getField(name)：根据字段名获取某个public的field（包括父类）；</li><li>Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）；</li><li>Field[] getFields()：获取所有public的field（包括父类）；</li><li>Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）。</li></ul><h2 id="获取类的私有字段并修改"><a href="#获取类的私有字段并修改" class="headerlink" title="获取类的私有字段并修改"></a>获取类的私有字段并修改</h2><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> <span class="hljs-keyword">name</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个对象</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.testreflection.TestClassCtor&quot;</span>);<br>Class[] p3 = &#123;<span class="hljs-type">int</span>.class, String.class&#125;;<br><span class="hljs-type">Constructor</span> <span class="hljs-variable">ctor</span> <span class="hljs-operator">=</span> r.getDeclaredConstructor(p3);<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ctor.newInstance(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;abc&quot;</span>);<br><br><span class="hljs-comment">// 获取name字段，private</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> r.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>field.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 获取指定实例的指定字段的值</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">fieldObject</span> <span class="hljs-operator">=</span> field.get(obj);<br><span class="hljs-comment">// 设置指定实例的指定字段的值，只对当前实例有效</span><br>field.set(obj, <span class="hljs-string">&quot;ancen&quot;</span>);<br><br><span class="hljs-type">TestClassCtor</span> <span class="hljs-variable">testClassCtor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestClassCtor</span>(<span class="hljs-number">100</span>);<br>testClassCtor.getName(); <span class="hljs-comment">// 仍然返回null，并没有修改</span><br></code></pre></td></tr></table></figure><blockquote><p>一个Field对象包含了一个字段的所有信息：</p><ul><li>getName()：返回字段名称，例如，”name”；</li><li>getType()：返回字段类型，也是一个Class实例，例如，String.class；</li><li>getModifiers()：返回字段的修饰符。</li></ul><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">byte</span>[] value;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Field f = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">DeclaredField(<span class="hljs-string">&quot;value&quot;</span>)</span>;<br>f.get<span class="hljs-constructor">Name()</span>; <span class="hljs-comment">// &quot;value&quot;</span><br>f.get<span class="hljs-constructor">Type()</span>; <span class="hljs-comment">// class [B 表示byte[]类型</span><br><span class="hljs-built_in">int</span> m = f.get<span class="hljs-constructor">Modifiers()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Modifier</span>.</span></span>is<span class="hljs-constructor">Final(<span class="hljs-params">m</span>)</span>; <span class="hljs-comment">// true</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Modifier</span>.</span></span>is<span class="hljs-constructor">Public(<span class="hljs-params">m</span>)</span>; <span class="hljs-comment">// false</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Modifier</span>.</span></span>is<span class="hljs-constructor">Protected(<span class="hljs-params">m</span>)</span>; <span class="hljs-comment">// false</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Modifier</span>.</span></span>is<span class="hljs-constructor">Private(<span class="hljs-params">m</span>)</span>; <span class="hljs-comment">// true</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Modifier</span>.</span></span>is<span class="hljs-constructor">Static(<span class="hljs-params">m</span>)</span>; <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="获取类的静态私有字段并修改"><a href="#获取类的静态私有字段并修改" class="headerlink" title="获取类的静态私有字段并修改"></a>获取类的静态私有字段并修改</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个对象</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.testreflection.TestClassCtor&quot;</span>);<br><br><span class="hljs-comment">// 获取address静态字段，private static</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> r.getDeclaredField(<span class="hljs-string">&quot;address&quot;</span>);<br>field.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">fieldObject</span> <span class="hljs-operator">=</span> field.get(<span class="hljs-literal">null</span>);<br>field.set(fieldObject, <span class="hljs-string">&quot;abcd&quot;</span>);<br><br><span class="hljs-comment">// 静态变量，一次修改，终生受用</span><br>TestClassCtor.printAddress();<br></code></pre></td></tr></table></figure><h1 id="获取继承关系"><a href="#获取继承关系" class="headerlink" title="获取继承关系"></a>获取继承关系</h1><h2 id="获取父类Class"><a href="#获取父类Class" class="headerlink" title="获取父类Class"></a>获取父类Class</h2><p>getSuperclass()获取父类的class；getInterfaces()获取当前类直接实现的接口类型（并不包括其父类实现的接口类型），返回值是Class[]。</p><blockquote><p>getInterfaces()只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型。</p></blockquote><h2 id="判断继承关系"><a href="#判断继承关系" class="headerlink" title="判断继承关系"></a>判断继承关系</h2><p>判断一个实例是否是某个类型时，正常情况下，使用instanceof操作符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">123</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">isDouble</span> <span class="hljs-operator">=</span> n <span class="hljs-keyword">instanceof</span> Double; <span class="hljs-comment">// false</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isInteger</span> <span class="hljs-operator">=</span> n <span class="hljs-keyword">instanceof</span> Integer; <span class="hljs-comment">// true</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isNumber</span> <span class="hljs-operator">=</span> n <span class="hljs-keyword">instanceof</span> Number; <span class="hljs-comment">// true</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isSerializable</span> <span class="hljs-operator">=</span> n <span class="hljs-keyword">instanceof</span> java.io.Serializable; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>如果是两个Class实例，要判断一个向上转型是否成立，可以调用isAssignableFrom()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Integer i = ?</span><br><span class="hljs-comment">// true，因为Integer可以赋值给Integer</span><br>Integer.class.isAssignableFrom(Integer.class); <br><span class="hljs-comment">// Number n = ?</span><br><span class="hljs-comment">// true，因为Integer可以赋值给Number</span><br>Number.class.isAssignableFrom(Integer.class); <br><span class="hljs-comment">// Object o = ?</span><br><span class="hljs-comment">// true，因为Integer可以赋值给Object</span><br>Object.class.isAssignableFrom(Integer.class); <br><span class="hljs-comment">// Integer i = ?</span><br><span class="hljs-comment">// false，因为Number不能赋值给Integer</span><br>Integer.class.isAssignableFrom(Number.class); <br></code></pre></td></tr></table></figure><h1 id="对泛型类的反射（实例）"><a href="#对泛型类的反射（实例）" class="headerlink" title="对泛型类的反射（实例）"></a>对泛型类的反射（实例）</h1><p>Android系统源码中存在大量泛型，所以插件化技术离不开对泛型进行反射，比如单例模式（Singleton）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T mInstance;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> T <span class="hljs-title function_">create</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (mInstance == <span class="hljs-literal">null</span>) &#123;<br>                mInstance = create();<br>            &#125;<br>            <span class="hljs-keyword">return</span> mInstance;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Singleton是一个抽象类，实例化时，先实现create这个抽象方法。例如，ActivityManagerNative（AMN），和Singleton有关的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ClassB2Interface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AMN</span> &#123;<br>    <span class="hljs-comment">// gDefault是AMN的静态私有变量，Singleton类型</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton&lt;ClassB2Interface&gt; gDefault = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>&lt;ClassB2Interface&gt;() &#123;<br>        <span class="hljs-comment">// 要实现create方法，返回一个ClassB2类型的对象</span><br>        <span class="hljs-keyword">protected</span> ClassB2Interface <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">ClassB2</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassB2</span>();<br>            b2.id = <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">return</span> b2;<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class="hljs-comment">// getDefault()方法获取create方法创建的ClassB2对象</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> ClassB2Interface <span class="hljs-title function_">getDefault</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> gDefault.get();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassB2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClassB2Interface</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> id;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;doSomething&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">ActivityManager am;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// gDefault是一个android.util.Singleton对象; 我们取出这个单例里面的字段</span><br>    Class&lt;?&gt; singleton = Class.forName(<span class="hljs-string">&quot;Singleton&quot;</span>);<br>    <span class="hljs-type">Field</span> <span class="hljs-variable">mInstanceField</span> <span class="hljs-operator">=</span> singleton.getDeclaredField(<span class="hljs-string">&quot;mInstance&quot;</span>);<br>    mInstanceField.setAccessible(<span class="hljs-literal">true</span>);<br><br>    <span class="hljs-comment">// 获取AMN的gDefault单例gDefault，gDefault是静态的</span><br>    Class&lt;?&gt; activityManagerNativeClass = Class.forName(<span class="hljs-string">&quot;AMN&quot;</span>);<br>    <span class="hljs-type">Field</span> <span class="hljs-variable">gDefaultField</span> <span class="hljs-operator">=</span> activityManagerNativeClass.getDeclaredField(<span class="hljs-string">&quot;gDefault&quot;</span>);<br>    gDefaultField.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">gDefault</span> <span class="hljs-operator">=</span> gDefaultField.get(<span class="hljs-literal">null</span>);<br><br>    <span class="hljs-comment">// 进一步得到AMN的gDefault对象里面的ClassB2类型对象rawB2Object</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">rawB2Object</span> <span class="hljs-operator">=</span> mInstanceField.get(gDefault);<br><br>    <span class="hljs-comment">// 创建一个这个对象的代理对象ClassB2Mock, 然后替换这个字段</span><br>    <span class="hljs-comment">// ClassB2Mock是对rawB2Object的动态代理</span><br>    Class&lt;?&gt; classB2Interface = Class.forName(<span class="hljs-string">&quot;ClassB2Interface&quot;</span>);<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> Proxy.newProxyInstance(<br>        Thread.currentThread().getContextClassLoader(),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[] &#123; classB2Interface &#125;,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassB2Mock</span>(rawB2Object));<br>    <span class="hljs-comment">// 把AMN中的gDefault字段的，设置为代理对象proxy</span><br>    mInstanceField.set(gDefault, proxy);<br><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ClassB2Mock中</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object o, Method method, Object[] objects)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><span class="hljs-comment">// 代理额外打印了一行日志</span><br>    Log.e(<span class="hljs-string">&quot;Ancen&quot;</span>, method.getName());<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;doSomething&quot;</span>.equals(method.getName())) &#123;<br>        print();<br>    &#125;<br>    <span class="hljs-keyword">return</span> method.invoke(mBase, objects);<br>&#125;<br></code></pre></td></tr></table></figure><p>经过Hook，AMN.getDefault().doSomething()将执行ClassB2Mock里面的逻辑。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>插件化</tag>
      
      <tag>Java</tag>
      
      <tag>反射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Android插件化》读书笔记（一）插件化技术</title>
    <link href="/2023/02/17/%E3%80%8AAndroid%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E6%8F%92%E4%BB%B6%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/02/17/%E3%80%8AAndroid%E6%8F%92%E4%BB%B6%E5%8C%96%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E6%8F%92%E4%BB%B6%E5%8C%96%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h1><p>Android安装应用，本身只是开辟进程，然后使用ClassLoader加载classes.dex（Java代码字节码）至进程中，执行对应的组件。同理，可以类似执行一个Apk中的代码。</p><p>插件化使Apk中的代码（Android组件）能够免安装运行，收益很大。</p><ul><li>减少安装Apk的体积，按需下载模块；</li><li>动态更新插件；</li><li>宿主和插件分开编译，提升开发效率。</li></ul><blockquote><p>拥有Native应用一样的性能，又能获取诸如Web应用一样的收益。</p></blockquote><h1 id="插件化历史"><a href="#插件化历史" class="headerlink" title="插件化历史"></a>插件化历史</h1><ul><li>静态代理，dynamic-load-apk最早使用ProxyActivity这种静态代理技术，由ProxyActivity去控制插件中PluginActivity的生命周期；that框架；</li><li>动态替换，实现原理都是上趋近于选择尽量少的Hook（但是早期没有，早期Hook了非常多Android底层源码），并通过在manifest中预埋一些组件实现对四大组件的动态插件化；</li><li>容器化框架，VirtualApp能够完全模拟App的运行环境，能够实现App的免安装运行和双开技术。Atlas是阿里的结合组件化和热修复技术的一个App基础框架，号称是一个容器化框架。</li></ul><h1 id="组件化与插件化"><a href="#组件化与插件化" class="headerlink" title="组件化与插件化"></a>组件化与插件化</h1><p>组件化，将一个App分成多个模块，每个模块都是一个组件（module），开发过程中可以让这些组件相互依赖或独立编译、调试部分组件，但是这些组件最终会合并成一个完整的Apk发布到应用市场。</p><p>插件化，将整个App拆分成很多模块，每个模块都是一个Apk（组件化的每个模块是一个lib），最终打包的时候将宿主Apk和插件Apk分开打包，只需发布宿主Apk到应用市场，插件Apk通过动态按需下发到宿主Apk。</p><h1 id="插件化用途"><a href="#插件化用途" class="headerlink" title="插件化用途"></a>插件化用途</h1><p>修复线上bug（最多）；增加新功能（相对来说，不着急）；游戏领域；ABTest等。</p><p>设想，各个业务模块提供打包好的Apk文件，放在宿主App的assets目录下。发版后，某个模块有更新，只需重新打包这个模块的代码，生成增量包，放到服务器上供用户下载。</p><h1 id="插件化技术难点"><a href="#插件化技术难点" class="headerlink" title="插件化技术难点"></a>插件化技术难点</h1><p>插件Apk运行，找到插件Apk的存放位置，然后解析加载Apk里的代码。</p><p>执行Java代码外，Android系统四大组件需要在系统中注册，具体是在Android系统的ActivityManagerService（AMS）和PackageManagerService（PMS）中注册的。必要性在于四大组件的解析和启动都需要依赖AMS和PMS。欺骗系统，使其承认一个未安装的Apk中的组件，让宿主动态加载执行插件Apk中Android组件是插件化最大的难点。</p><blockquote><p>Q：四大组件都需要插件化技术吗？</p><p>该根据App对四大组件的依赖程度，来选择合适的插件化技术。四大组件全都实现插件化固然是好的，但是如果App中主要是Activity，那么选择静态代理that框架就够了。</p></blockquote><p>另外，应用资源引用（特指R中引用的资源，layout、values、…）也是问题。设想，在宿主进程中使用反射加载了一个插件Apk后，代码中的R对应的id却无法引用到正确的资源。</p><p>All in all，做到插件化需要，</p><ul><li>加载并执行插件Apk中的代码（ClassLoader Injection）；</li><li>使系统能调用插件Apk中的组件（Runtime Container）；</li><li>正确识别插件Apk中的资源（Resource Injection）；资源合并、资源冲突。</li></ul><h1 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h1><p>使Android或iOS中的每个控件，在RN中都能找到相对应的控件。RN基于JavaScript编写，打包后放到服务器。</p><p>RN最大程度地实现了跨平台；JavaScript前端；快速迭代、快速上线。</p><h1 id="Google-Play"><a href="#Google-Play" class="headerlink" title="Google Play"></a>Google Play</h1><p>Google Play官方市场不允许插件化App的存在，审核会不通过。</p><blockquote><p>国外开发人员相对关注用户体验；Material Design；函数式编程；代码的优雅、实用、健壮、复用。存疑。</p></blockquote><h1 id="双开和虚拟机"><a href="#双开和虚拟机" class="headerlink" title="双开和虚拟机"></a>双开和虚拟机</h1><p>插件化的未来，虚拟机技术。在Android系统，也可以支持安装一个或多个虚拟机。</p><blockquote><p>双开，同时打开一个App的多个分身的技术。</p></blockquote><p>以上是问题一。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>插件化</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
