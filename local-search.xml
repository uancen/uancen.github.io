<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HJ C++ STL Note 2 STL Design Patterns</title>
    <link href="/2023/03/06/HJ-C++-STL-Note-2-STL-Design-Patterns/"/>
    <url>/2023/03/06/HJ-C++-STL-Note-2-STL-Design-Patterns/</url>
    
    <content type="html"><![CDATA[<h1 id="OOP-amp-GP"><a href="#OOP-amp-GP" class="headerlink" title="OOP &amp; GP"></a>OOP &amp; GP</h1><p>Object-Oriented Programming和Generic Programming是STL容器设计中使用的两种设计模式。</p><p><img src="/2023/03/06/HJ-C++-STL-Note-2-STL-Design-Patterns/OOP.png" alt></p><p>OOP的目的是将<strong>数据</strong>和<strong>方法</strong>绑定在一起，例如对list容器进行排序使用list的sort方法，sort已经放在list里了。</p><p><img src="/2023/03/06/HJ-C++-STL-Note-2-STL-Design-Patterns/GP.png" alt></p><p>GP的目的是将<strong>数据</strong>和<strong>方法</strong>分离开来，例如对vector容器进行排序使用std::sort方法，sort被设计在Algorithms里了，则这里全局的设计，使用Iterator得到范围，<code>sort(c.begin(), c.end());</code>。</p><blockquote><p>标准库没有太涉及OOP，没有复杂的继承关系。</p></blockquote><p><img src="/2023/03/06/HJ-C++-STL-Note-2-STL-Design-Patterns/min.png" alt="image-20230306094342814"></p><p>举例，min和max，闭门造车，&lt;的事情，min并不关心，而由T自己决定（操作符重载）。</p><p><strong>Q：list为什么不能使用全局设计？</strong></p><p><img src="/2023/03/06/HJ-C++-STL-Note-2-STL-Design-Patterns/OOP.png" alt></p><p>全局sort调用的_introsort_loop，其中迭代器进行了+-/，传进来的迭代器必须是Random的，而List的迭代器是不能跳来跳去的，只能++，所以List不能使用全局设计。 </p><p><img src="/2023/03/06/HJ-C++-STL-Note-2-STL-Design-Patterns/algorithm.png" alt></p><p>max有两个版本，对于第一个版本，字符串有字典形式的比大小，string的比大小使用该默认版本；第二个版本，其中第三个参数接收一个Compare，在这里自定义比大小的方式，比的是size。</p><h1 id="运算符重载-amp-模板特化"><a href="#运算符重载-amp-模板特化" class="headerlink" title="运算符重载 &amp; 模板特化"></a>运算符重载 &amp; 模板特化</h1><h2 id="Operator-Overloading"><a href="#Operator-Overloading" class="headerlink" title="Operator Overloading"></a>Operator Overloading</h2><p><img src="/2023/03/06/HJ-C++-STL-Note-2-STL-Design-Patterns/oo1.png" alt></p><p><img src="/2023/03/06/HJ-C++-STL-Note-2-STL-Design-Patterns/oo2.png" alt></p><p><img src="/2023/03/06/HJ-C++-STL-Note-2-STL-Design-Patterns/oo3.png" alt="image-20230306102017986"></p><p>一定会重载对指针定义的所有动作，以上列出来了4个，但仍有很多。</p><h2 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h2><ul><li>类模板</li><li>函数模板</li><li>成员模板</li></ul><h2 id="Specialization"><a href="#Specialization" class="headerlink" title="Specialization"></a>Specialization</h2><p><img src="/2023/03/06/HJ-C++-STL-Note-2-STL-Design-Patterns/spec.png" alt></p><p>设计类模板，有一个泛化版本了；但对于独特type，有一个更好的处理方法，则可以使用Specialization。</p><p>以上例子仅仅用来演示Specialization语法；分别指定int和double时的特定语法；template后面的&lt;&gt;变为空。</p><p><img src="/2023/03/06/HJ-C++-STL-Note-2-STL-Design-Patterns/spec2.png" alt></p><p>_STL_TEMPLATE_NULL实际上就是template&lt;&gt;，hash这个类模板在以下传入类型时，特化。</p><blockquote><p>以上是全特化Full。</p></blockquote><h2 id="Partial-Specialization"><a href="#Partial-Specialization" class="headerlink" title="Partial Specialization"></a>Partial Specialization</h2><p><img src="/2023/03/06/HJ-C++-STL-Note-2-STL-Design-Patterns/pspec.png" alt></p><p>左边，两个模板参数，绑定了一个模板参数；指定接受参数为bool，有特化实现，bool容易想到是更精简的空间。</p><p>右边范围偏特化，泛化接收任意type，而如果绑定的是指针，则有偏特化实现，而如果绑定的是const pointer，也有偏特化实现。</p>]]></content>
    
    
    <categories>
      
      <category>Course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HJ C++ STL Note 1 STL Test</title>
    <link href="/2023/03/01/HJ-C++-STL-Note-1-STL-Test/"/>
    <url>/2023/03/01/HJ-C++-STL-Note-1-STL-Test/</url>
    
    <content type="html"><![CDATA[<h1 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h1><blockquote><p>STL是GP最成功的作品，深入STL即是深入探索泛型编程。</p></blockquote><p>C++ Standard Library；注意命名空间，所有组件封装于std，所以常常把std命名空间全部打开，也可以部分打开。</p><p><img src="/2023/03/01/HJ-C++-STL-Note-1-STL-Test/header.png" alt></p><p>Standard Template Library，占据C++ Standard Library约70%，分为六大组件。</p><blockquote><p>C++不同编译器、开发工具下，标准库一样。</p></blockquote><p><img src="/2023/03/01/HJ-C++-STL-Note-1-STL-Test/six.png" alt></p><p>容器帮忙解决内存的问题，其背后需要分配器支持；对容器的操作，有些操作容器本身做，更多独立为模板函数，变成Algorithms。</p><blockquote><p>数据在容器里，而操作数据的函数却在算法里，即不在其本身class中，基本思想就和OO不一致。</p></blockquote><p>算法希望处理容器的数据，迭代器作为桥梁，迭代器是泛化的指针。仿函数，作用是一个函数。Adapter帮助转换，对容器、仿函数、迭代器做转换。</p><p><img src="/2023/03/01/HJ-C++-STL-Note-1-STL-Test/six2.png" alt></p><p>vector第二个参数可以不写，即选择默认分配器，allocator本身也是模板，分配的是int；count_if计算符合当前条件的元素有几个；头尾得到两个iterator；仿函数less用来比大小，但是需要拿每个元素和40比，使用bind2nd，即绑定第二参数；not1，则从<40变为>=40。</40变为></p><blockquote><p>容器的选择，取决于数据的分布程度和操作类型。</p></blockquote><p><img src="/2023/03/01/HJ-C++-STL-Note-1-STL-Test/range.png" alt></p><p>所有容器表示头和尾，begin指向第一个元素，end指向最后一个元素的下一个位置，因此是前闭后开空间。for loop格式如上。习惯写法。</p><p><img src="/2023/03/01/HJ-C++-STL-Note-1-STL-Test/range2.png" alt></p><p>现在这样for range了；auto后的elem其实就是iterator；auto可以自行推导，但是不是万能的，尽量还是明晰变量类型；加上引用，可以更改原元素。</p><p><img src="/2023/03/01/HJ-C++-STL-Note-1-STL-Test/ite.png" alt></p><p>auto可以自行推导。</p><h1 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h1><blockquote><p>Program = Data Structures + Algorithm.</p></blockquote><p><img src="/2023/03/01/HJ-C++-STL-Note-1-STL-Test/container.png" alt></p><p>容器大致分为Sequence Container、Associative Container、Unordered Containers（C++ 11新出现）；但不是好分法，Unordered Containers实际上也是Associative Container，底层是HashTable。</p><p>标准库提供的链表实际上是双向链表。</p><p>红黑树，高度平衡二分树；set、map基本都使用红黑树来做；set、map不同只在于key、key-value；multi则代表key可重复。</p><h2 id="helper"><a href="#helper" class="headerlink" title="helper"></a>helper</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">container_helper</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">container_helper</span>()&#123;&#125;;<br>    <span class="hljs-comment">// 成员函数</span><br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">get_a_target_long</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">string <span class="hljs-title">get_a_target_string</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">compareLongs</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">compareStrings</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span></span>;<br>&#125;;<br><br><span class="hljs-comment">// 从console中读入一个 long</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">container_helper::get_a_target_long</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">long</span> target = <span class="hljs-number">0</span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;target (0~&quot;</span> &lt;&lt; RAND_MAX &lt;&lt; <span class="hljs-string">&quot;): &quot;</span>;<br>    cin &gt;&gt; target;<br>    <span class="hljs-keyword">return</span> target;<br>&#125;<br><br><span class="hljs-comment">// 从console中读入一个 string</span><br><span class="hljs-function">string <span class="hljs-title">container_helper::get_a_target_string</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">long</span> target = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">10</span>];<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;target (0~&quot;</span> &lt;&lt; RAND_MAX &lt;&lt; <span class="hljs-string">&quot;): &quot;</span>;<br>    cin &gt;&gt; target;<br>    <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-number">10</span>, <span class="hljs-string">&quot;%d&quot;</span>, target);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>(buf);<br>&#125;<br><br><span class="hljs-comment">// 比较 long</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">container_helper::compareLongs</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (*(<span class="hljs-type">long</span> *)a - *(<span class="hljs-type">long</span> *)b);<br>&#125;<br><br><span class="hljs-comment">// 比较 string</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">container_helper::compareStrings</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (*(string *)a &gt; *(string *)b)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*(string *)a &lt; *(string *)b)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><p>C++11中将数组抽象成了一个模板类array。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 必须要告诉多大</span><br>array&lt;<span class="hljs-type">long</span>, ASIZE&gt; c;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">c.<span class="hljs-built_in">size</span>();<br>c.<span class="hljs-built_in">front</span>();<br>c.<span class="hljs-built_in">back</span>();<br>c.<span class="hljs-built_in">data</span>(); <span class="hljs-comment">// 返回指向数组第一个元素的指针</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 最后一个参数告诉怎么比</span><br>std::<span class="hljs-built_in">qsort</span>(c.<span class="hljs-built_in">data</span>(), ASIZE, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">long</span>), container_helper::compareLongs);<br><span class="hljs-type">long</span> *pItem = (<span class="hljs-type">long</span> *)::<span class="hljs-built_in">bsearch</span>(&amp;target, (c.<span class="hljs-built_in">data</span>()), ASIZE, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">long</span>),<br></code></pre></td></tr></table></figure><p><img src="/2023/03/01/HJ-C++-STL-Note-1-STL-Test/array_test.png" alt></p><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><blockquote><p>测试程序希望在单独的空间（namespace）里。</p></blockquote><p>vector的底层是一段连续的内存空间，当容器满时进行扩容，将容器大小扩容为原来的两倍，即“两倍增长”。容易知道，capacity必定大于size。</p><p>try catch来应对内存不够的情况，尤其在元素数量是输入的情况下。</p><p>::find是一个模板函数，属于“算法”，这是全局的。</p><blockquote><p>auto来简写iterator类型；找到了，解参考取值。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;string&gt; c;<br>c.<span class="hljs-built_in">push_back</span>();<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">c.<span class="hljs-built_in">size</span>();<br>c.<span class="hljs-built_in">front</span>();<br>c.<span class="hljs-built_in">back</span>();<br>c.<span class="hljs-built_in">data</span>();<br>c.<span class="hljs-built_in">capacity</span>();<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> pItem = <span class="hljs-built_in">find</span>(c.<span class="hljs-built_in">begin</span>(), c.<span class="hljs-built_in">end</span>(), target);<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(c.<span class="hljs-built_in">begin</span>(), c.<span class="hljs-built_in">end</span>());<br>string *pItem =<br>            (string *)::<span class="hljs-built_in">bsearch</span>(&amp;target, (c.<span class="hljs-built_in">data</span>()), c.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">sizeof</span>(string),<br>                                helper.compareStrings);<br></code></pre></td></tr></table></figure><p><img src="/2023/03/01/HJ-C++-STL-Note-1-STL-Test/vector_test.png" alt></p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>双向链表；第二个参数总是使用默认的分配器；vector的成长总是缓慢的，因为它在扩容后，还有拷贝的过程；list则是一个萝卜一个坑。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">c.<span class="hljs-built_in">sort</span>();<br></code></pre></td></tr></table></figure><p>sort是算法的一个；但是这里没有呼叫全局sort，这里调用的是list类成员函数sort；对于该容器，容器本身实现的sort的性能一般比标准库中的算法sort更好。</p><blockquote><p>forward_list是C++11标准引入的，其前身是gcc中的slist；是单向链表。</p></blockquote><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p><img src="/2023/03/01/HJ-C++-STL-Note-1-STL-Test/deque.png" alt></p><p>deque双端插入和删除；但是其底层是<strong>分段连续</strong>的，只是对于使用者来说造成了一种连续的假象。</p><blockquote><p>++进行操作符重载，来进行段间跨越。</p></blockquote><p>两端开口，如果容量不够用，则继续分配buffer，并有指针指向纪录；每次扩充多少，有关于效率问题；vector的“两倍增长”已经是权衡后的方案，但仍然会有浪费；然而总有tradeoff，空间利用率高了，时间上就会下滑。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(c.<span class="hljs-built_in">begin</span>(), c.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><blockquote><p>deque没有sort()，使用全局即可。</p></blockquote><h2 id="stack-amp-queue"><a href="#stack-amp-queue" class="headerlink" title="stack &amp; queue"></a>stack &amp; queue</h2><p>底层都是通过deque实现；从设计模式上说，这两种容器本质上是deque的适配器。</p><p><img src="/2023/03/01/HJ-C++-STL-Note-1-STL-Test/sq.png" alt></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// stack</span><br>c.<span class="hljs-built_in">push</span>();<br>c.<span class="hljs-built_in">pop</span>();<br>c.<span class="hljs-built_in">size</span>();<br>c.<span class="hljs-built_in">top</span>();<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// queue</span><br>c.<span class="hljs-built_in">push</span>();<br>c.<span class="hljs-built_in">pop</span>();<br>c.<span class="hljs-built_in">size</span>();<br>c.<span class="hljs-built_in">front</span>();<br>c.<span class="hljs-built_in">back</span>();<br></code></pre></td></tr></table></figure><h2 id="multiset-amp-multimap"><a href="#multiset-amp-multimap" class="headerlink" title="multiset &amp; multimap"></a>multiset &amp; multimap</h2><blockquote><p>以上介绍的都是Sequence Containers，而以下都是Associated Containers，可以理解为小型的“关联数据库”，查找非常快。</p><p>stack和queue不会提供iterator，否则会破坏其结构上的特性。</p></blockquote><p>底层是使用红黑树实现的。树本身遵守一定规则，所以只能insert。</p><blockquote><p>multiset允许重复元素，因此重复的也放入，size等同于insert的数量。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">c.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">string</span>(buf));<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> pItem = <span class="hljs-built_in">find</span>(c.<span class="hljs-built_in">begin</span>(), c.<span class="hljs-built_in">end</span>(), target);<br><span class="hljs-keyword">auto</span> pItem = c.<span class="hljs-built_in">find</span>(target); <span class="hljs-comment">// 快很多</span><br></code></pre></td></tr></table></figure><p>对于放进去的时间复杂度没有要求，着重于查找要快，则考虑multiset &amp; multimap。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">c.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">long</span>, string&gt;(i, buf));<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> pItem = c.<span class="hljs-built_in">find</span>(target);<br></code></pre></td></tr></table></figure><p><strong>因为multimap支持重复的key，因此不能使用重载的<code>[]</code>运算符进行插入</strong>。</p><h2 id="unordered-multiset-amp-unordered-multimap"><a href="#unordered-multiset-amp-unordered-multimap" class="headerlink" title="unordered_multiset &amp; unordered_multimap"></a>unordered_multiset &amp; unordered_multimap</h2><p>底层使用哈希表实现。bucket一定比元素多，单bucket的链表不可以太长；当元素数量大于bucket，bucket就要扩充，而元素打散重新挂。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">c</span>.bucket_count()<br><span class="hljs-keyword">c</span>.max_bucket_count()<br></code></pre></td></tr></table></figure><p>后面会涉及load_factor。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">c.load_factor<span class="hljs-comment">()</span><br>c.max_load_factor<span class="hljs-comment">()</span><br></code></pre></td></tr></table></figure><h2 id="set-amp-map"><a href="#set-amp-map" class="headerlink" title="set &amp; map"></a>set &amp; map</h2><p>不允许重复元素，碰到重复则不放。</p><p>值得注意的是，map允许<code>[]</code>赋值了，内部自动组装为pair。由于key没有重复，map全部放入了，1000000。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">c[i] = <span class="hljs-built_in">string</span>(buf);<br></code></pre></td></tr></table></figure><h1 id="Allocator"><a href="#Allocator" class="headerlink" title="Allocator"></a>Allocator</h1><p><img src="/2023/03/01/HJ-C++-STL-Note-1-STL-Test/alloc.png" alt></p><p>gcc额外定义的分配器均位于<code>__gnu_cxx</code>命名空间下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span>    <span class="hljs-comment">// 內含 std::allocator</span></span><br><span class="hljs-comment">// 欲使用 std::allocator 以外的 allocator,得自行 #include &lt;ext\...&gt;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __GNUC__</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ext\array_allocator.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ext\mt_allocator.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ext\debug_allocator.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ext\pool_allocator.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ext\bitmap_allocator.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ext\malloc_allocator.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ext\new_allocator.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>list举例使用分配器，list给出不同分配器作为参数，push_back时则自然会使分配器工作。</p><blockquote><p>分配器常常作为第二参数。</p></blockquote><p>分配器一般用于构建容器，不会直接使用。因为分配器想要直接使用也不好用，使用free关键字时不需要指定回收内存的大小，<strong>而分配器的deallocate函数需要指定回收内存大小</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *p;<br>allocator&lt;<span class="hljs-type">int</span>&gt; alloc1;<br>p = alloc1.<span class="hljs-built_in">allocate</span>(<span class="hljs-number">1</span>);<br>alloc1.<span class="hljs-built_in">deallocate</span>(p, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebServer Note 2 Thread Synchronization</title>
    <link href="/2022/07/06/WebServer-Note-2-Thread-Synchronization/"/>
    <url>/2022/07/06/WebServer-Note-2-Thread-Synchronization/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Resource Acquisition is Initialization.</p><p>将资源和对象的生命周期绑定，智能指针是最好的例子。</p></blockquote><h1 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h1><p>实现多线程同步，通过锁机制，确保任一时刻只能有一个线程能进入关键代码段。</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>locker.h，对Linux下三种锁进行封装，将锁的创建于销毁函数封装在类的构造与析构函数中，实现RAII机制。</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>PV操作；假设有信号量SV。信号量的取值可以是任何自然数；最简单的信号量是二进制信号量，只有0和1两个值。</p><blockquote><p>P，如果SV的值大于0，则将其减一；若SV的值为0，则挂起执行。</p><p>V，如果有其他进行因为等待SV而挂起，则唤醒；若没有，则将SV值加一。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">sem</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">sem</span>() &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * @description  sem_init() initializes the unnamed semaphore at the</span><br><span class="hljs-comment">         * address pointed to by sem.</span><br><span class="hljs-comment">         * @param &#123;sem_t *&#125; address</span><br><span class="hljs-comment">         * @param &#123;int&#125; pshared pshared indicates whether this semaphore is to</span><br><span class="hljs-comment">         * be shared between the threads of a process, or between processes.</span><br><span class="hljs-comment">         * @param &#123;int&#125; value</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sem_init</span>(&amp;m_sem, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">sem</span>(<span class="hljs-type">int</span> num) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sem_init</span>(&amp;m_sem, <span class="hljs-number">0</span>, num) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();<br>        &#125;<br>    &#125;<br><br>    ~<span class="hljs-built_in">sem</span>() &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * @description sem_destroy() destroys the semaphore at the address</span><br><span class="hljs-comment">         * pointed to by sem.</span><br><span class="hljs-comment">         * @param address</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sem_destroy</span>(&amp;m_sem) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * @description sem_wait() decrements (locks) the semaphore pointed to</span><br><span class="hljs-comment">         * by sem.</span><br><span class="hljs-comment">         * If the semaphore&#x27;s value is greater than zero, then the</span><br><span class="hljs-comment">         * decrementproceeds, and the function returns, immediately.  If the</span><br><span class="hljs-comment">         * semaphore currently has the value zero, then the call blocks until</span><br><span class="hljs-comment">         * either it becomes possible to perform the decrement (i.e., the</span><br><span class="hljs-comment">         * semaphore value rises above zero), or a signal handler interrupts the</span><br><span class="hljs-comment">         * call.</span><br><span class="hljs-comment">         * @param address</span><br><span class="hljs-comment">         * @return return 0 on success; return -1 on error</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sem_wait</span>(&amp;m_sem) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">post</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * @description sem_post() increments (unlocks) the semaphore pointed to</span><br><span class="hljs-comment">         * by sem. If the semaphore&#x27;s value consequently becomes greater than</span><br><span class="hljs-comment">         * zero, then another process or thread blocked in a sem_wait call</span><br><span class="hljs-comment">         * will be woken up and proceed to lock the semaphore.</span><br><span class="hljs-comment">         * @param address</span><br><span class="hljs-comment">         * @return return 0 on success; return -1 on error</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sem_post</span>(&amp;m_sem) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">sem_t</span> m_sem;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><p>互斥锁；保护关键代码段，以确保独占式访问。当进入关键代码段，获得互斥锁将其加锁；离开关键代码段，唤醒等待该互斥锁的线程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">locker</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">locker</span>() &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * @param mutexattr The pthread_mutex_init() function initialises the</span><br><span class="hljs-comment">         * mutex referenced by mutex with attributes specified by attr. If attr</span><br><span class="hljs-comment">         * is NULL, the default mutex attributes are used; the effect is the</span><br><span class="hljs-comment">         * same as passing the address of a default mutex attributes object.</span><br><span class="hljs-comment">         * Upon successful initialisation, the state of the mutex becomes</span><br><span class="hljs-comment">         * initialised and unlocked.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_mutex_init</span>(&amp;m_mutex, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();<br>        &#125;<br>    &#125;<br>    ~<span class="hljs-built_in">locker</span>() &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;m_mutex) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_mutex_lock</span>(&amp;m_mutex) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;m_mutex) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">pthread_mutex_t</span> *<span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> &amp;m_mutex; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">pthread_mutex_t</span> m_mutex;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>线程间通信；当某个共享数据达到某个值时，唤醒等待这个共享数据的线程。条件变量的封装值得一提；首先提示，以下注释中pthread_cond_wait必须在加锁的条件下使用，本身是没有问题的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 条件变量的使用机制需要配合锁来使用</span><br><span class="hljs-comment">// 内部会有一次加锁和解锁</span><br><span class="hljs-comment">// 封装起来会使得更加简洁</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// wait前必须上锁</span><br>    <span class="hljs-comment">// 即pthread_cond_wait必须在加锁的条件下使用</span><br>    <span class="hljs-built_in">pthread_mutex_lock</span>(m_mutex);<br>    ret = <span class="hljs-built_in">pthread_cond_wait</span>(&amp;m_cond, m_mutex);<br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(m_mutex);<br>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于这种写法，即将mutex隐藏在cond类中，可以理解，但是不能正常使用。</p><blockquote><p>Q：mutex用来保护什么？</p></blockquote><p>通常在程序里，使用条件变量来表示等待”某一条件”的发生。虽然名叫”条件变量”，但是它本身并不保存条件状态，本质上条件变量仅仅是一种通讯机制：当有一个线程在wait某一条件变量的时候，会将当前的线程挂起，直到另外的线程发送信号notify通知其解除阻塞状态。</p><p>所以需要使用额外的共享变量保存条件状态；而由于这个变量会同时被不同的线程访问，因此需要一个额外的mutex保护它。</p><blockquote><p>A condition variable is always used in conjunction with a mutex. The mutex provides mutual exclusion for accessing the shared variable, while the condition variable is used to signal changes in the variable’s state.</p></blockquote><p>条件变量总是结合mutex使用，条件变量就共享变量的状态改变发出通知，<strong>mutex用来保护这个共享变量的</strong>。</p><blockquote><p><strong>为什么pthread_cond_wait()需要mutex参数？</strong></p></blockquote><p>则在wait的封装中使用mutex参数。使用条件变量的接口实现一个简单的生产者-消费者模型，avail就是保存条件状态的共享变量，它对生产者线程、消费者线程均可见。不考虑错误处理，先看生产者实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>avail++;<br><span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br><br><span class="hljs-built_in">pthread_cond_signal</span>(&amp;cond); <span class="hljs-comment">/* Wake sleeping consumer */</span><br></code></pre></td></tr></table></figure><p>因为avail对两个线程都可见，因此对其修改均应该在mutex的保护之下，再来看消费者线程实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (;;)<br>&#123;<br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>    <span class="hljs-keyword">while</span> (avail == <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);<br><br>    <span class="hljs-keyword">while</span> (avail &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">/* Do something */</span><br>        avail--;<br>    &#125;<br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>&#125;<br></code></pre></td></tr></table></figure><p>当”avail==0”时，消费者线程会阻塞在pthread_cond_wait()函数上。如果pthread_cond_wait()仅需要一个pthread_cond_t参数的话，此时mutex已经被锁，要是不先将mutex变量解锁，那么其他线程（如生产者线程）永远无法访问avail变量，也就无法继续生产，消费者线程会一直阻塞下去。因此pthread_cond_wait()需要传递给它一个pthread_mutex_t类型的变量。</p><p>pthread_cond_wait()函数分为3个部分：</p><ol><li>解锁互斥量mutex；</li><li>阻塞调用线程，直到当前的条件变量收到通知；</li><li>重新锁定互斥量mutex。</li></ol><p>其中1和2是原子操作，也就是说在pthread_cond_wait()调用线程陷入阻塞之前其他的线程无法获取当前的mutex，也就不能就该条件变量发出通知。</p><blockquote><p>虚假唤醒：判断条件放在了while中，而不是if，这是因为pthread_cond_wait()阻塞在条件变量上的时候，即使其他的线程没有就该条件变量发出通知notify()或者notifyAll()，条件变量也有可能会自己醒来，即pthread_cond_wait()函数返回，因此需要重新检查一下共享变量上的条件成不成立，<strong>确保条件变量是真的收到了通知</strong>，否则继续阻塞等待。</p></blockquote><p>回到条件变量的封装问题。</p><p>从以上分析，可知pthread_cond_wait()使用时，必须遵守的几个法则：</p><ol><li>必须结合mutex使用，mutex用于保护共享变量，而不是保护pthread_cond_wait()的某些内部操作；</li><li>mutex上锁后，才能调用pthread_cond_wait()；</li><li>条件状态判断要放在while()循环里，然后再pthread_cond_wait()。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">cond</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;m_mutex);<br>        ret = <span class="hljs-built_in">pthread_cond_wait</span>(&amp;m_cond, &amp;m_mutex);<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;m_mutex);<br>        <span class="hljs-keyword">return</span> ret == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">signal</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pthread_cond_signal</span>(&amp;m_cond) == <span class="hljs-number">0</span>;<br>    &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">pthread_mutex_t</span> m_mutex;<br>    <span class="hljs-type">pthread_cond_t</span> m_cond;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这段代码中，wait()函数直接将mutex隐藏到其实现里边，这里的mutex完全没发挥作用，没有保护任何的东西，仅仅是为了适配pthread_cond_wait()接口。</p><p>参考C++11标准库的接口设计，将mutex放出来，在wait的时候当参数传入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *m_mutex)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// pthread_mutex_lock(m_mutex);</span><br>    ret = <span class="hljs-built_in">pthread_cond_wait</span>(&amp;m_cond, m_mutex);<br>    <span class="hljs-comment">// pthread_mutex_unlock(m_mutex);</span><br>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebServer Note 1 Backgroud</title>
    <link href="/2022/07/01/WebServer-Note-1-Backgroud/"/>
    <url>/2022/07/01/WebServer-Note-1-Backgroud/</url>
    
    <content type="html"><![CDATA[<h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p>基于Linux的轻量级多线程网络服务器。</p><h3 id="网络服务器"><a href="#网络服务器" class="headerlink" title="网络服务器"></a>网络服务器</h3><ul><li>一个服务器软件（程序），或者是运行这个服务器软件的硬件（计算机）。</li><li>功能：通过HTTP协议与客户端（通常是浏览器）进行通信，来接收，存储，处理来自客户端的HTTP请求，并对其请求做出HTTP响应，返回给客户端其请求的内容（文件、网页等）或返回一个Error信息。</li></ul><h3 id="用户与网络服务器的通信方式"><a href="#用户与网络服务器的通信方式" class="headerlink" title="用户与网络服务器的通信方式"></a>用户与网络服务器的通信方式</h3><ul><li>通常用户使用web浏览器与相应服务器进行通信。</li><li>在浏览器中键入“域名” 或 “IP地址：端口号” 。</li></ul><h1 id="预计目标"><a href="#预计目标" class="headerlink" title="预计目标"></a>预计目标</h1><ul><li>「请求-响应」</li><li>压力测试</li></ul>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UCSB CS291A Note 1 PCSS</title>
    <link href="/2022/04/01/UCSB-CS291A-Note-1-PCSS/"/>
    <url>/2022/04/01/UCSB-CS291A-Note-1-PCSS/</url>
    
    <content type="html"><![CDATA[<h1 id="SM"><a href="#SM" class="headerlink" title="SM"></a>SM</h1><h2 id="本影与半影"><a href="#本影与半影" class="headerlink" title="本影与半影"></a>本影与半影</h2><p><img src="/2022/04/01/UCSB-CS291A-Note-1-PCSS/shadowsintro.png" alt></p><p>精准光源（punctual light source），生成硬阴影（hard shadows）；面光源产生软阴影（soft shadows），阴影 = 本影 + 半影。</p><h2 id="2-pass-Algorithm"><a href="#2-pass-Algorithm" class="headerlink" title="2-pass Algorithm"></a>2-pass Algorithm</h2><p>简而言之，第一次从light看向场景渲染生成深度图，第二次：从camera处看场景（进行渲染），这个过程使用深度图判断物体是否处于阴影中。</p><h3 id="1st"><a href="#1st" class="headerlink" title="1st"></a>1st</h3><p>render from light, to get the depth texture.</p><p>Code: create a virtual camera at the light source→MVP→to get the depth buffer from the light’s point-of-view→output a depth texture.</p><blockquote><p>深度图记录的是，每个像素中他们各自看到的最浅的深度即最近物体的距离。</p></blockquote><h3 id="2nd"><a href="#2nd" class="headerlink" title="2nd"></a>2nd</h3><p>render from eye, project visible points in eye view back to light source, to compute the distance from each fragment to the light source.</p><p>compare, to get visible or blocked.</p><blockquote><p>注意透视投影后的z（z after MVP）和实际到light的距离（linear distance）是不一样的，一致即可。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span> depthInShadowMap &lt; PositionToLight.z<br>    <span class="hljs-keyword">return</span> blocked<br><span class="hljs-keyword">return</span> visible<br></code></pre></td></tr></table></figure><blockquote><p>Visualizing Shadow Mapping</p><ul><li>position-&gt;NDC[0,1]</li><li>(255.0,255.0,255.0) * position.z</li></ul><p><img src="/2022/04/01/UCSB-CS291A-Note-1-PCSS/visual.png" alt></p></blockquote><h2 id="pros-amp-cons"><a href="#pros-amp-cons" class="headerlink" title="pros &amp; cons"></a>pros &amp; cons</h2><h3 id="pros"><a href="#pros" class="headerlink" title="pros"></a>pros</h3><p>快；使用记录的深度图。</p><h3 id="cons"><a href="#cons" class="headerlink" title="cons"></a>cons</h3><p>cons1: self-occlusion/self-shadowing</p><blockquote><p>表现类似于摩尔纹。</p></blockquote><p><img src="/2022/04/01/UCSB-CS291A-Note-1-PCSS/selfocclusion1.png" alt></p><p>在SM下，场景是离散的小片；会导致这样一种现象：从camera看向场景的小片时，该小片连向light，会被误认为被前面的小片遮挡，产生错误的阴影；容易知道，light incident从上向下，问题最小，light incident接近和地面平行时（grazing angle），self-occlusion最严重。</p><p>解决方法：使记录深度明显得比实际深度小；具体方法：使一个点深度大于记录深度的值超过一个阈值时，才认为这个点在阴影内；Adding a variable bias (slope scale based depth bias)。</p><blockquote><p>但是bias会引入detached shadow issue，表现为阴影偏移（Peter Panning）。</p></blockquote><p><img src="/2022/04/01/UCSB-CS291A-Note-1-PCSS/selfocclusion2.png" alt></p><p>使bias与接收器对光的角度成比例（normal incident影响小而horizontal incident影响大）；slope scale based depth bias = factorSlope * slope + constantBias；slope: determined by the normal。</p><blockquote><p>RTR does not trust in COMPLEXITY.</p></blockquote><p>cons2: Aliasing</p><p>the resolution of the Shadow Map，对场景具有分辨率的表现。</p><p>解决方法：Cascaded Shadow Map（工业界）。</p><h2 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h2><blockquote><p>详细说下SM背后的数学，为后面内容做准备。</p></blockquote><p>An important approximation through RTR, by the way, care more about “approximately equal”.</p><p>$\int_{\Omega} f(x) g(x) \mathrm{d} x \approx \frac{\int_{\Omega} f(x) \mathrm{d} x}{\int_{\Omega} \mathrm{d} x} \cdot \int_{\Omega} g(x) \mathrm{d} x$</p><p>两个函数乘积的积分 ≈ 两个函数积分的乘积，肯定不正确，但希望给出限定条件下，近似正确；分母的含义，是一个归一化常数。</p><p>对以上近似，有结果近似正确的条件：g(x)积分的support较小（实际积分范围较小）；或者g(x)在积分域上足够smooth光滑（变动不大），并不是指连续性，而是低频。</p><p>rendering equation <strong>with explicit visibility</strong>, </p><p>$L_o\left(\mathrm{p}, \omega_o\right)=\int_{\Omega^{+}} L_i\left(\mathrm{p}, \omega_i\right) f_r\left(\mathrm{p}, \omega_i, \omega_o\right) \cos \theta_i V\left(\mathrm{p}, \omega_i\right) \mathrm{d} \omega_i$</p><p>拆出V项，有以上“好”的近似，可以得到</p><p>$L_o\left(\mathrm{p}, \omega_o\right) \approx \frac{\int_{\Omega^{+}} V\left(\mathrm{p}, \omega_i\right) \mathrm{d} \omega_i}{\int_{\Omega^{+}} \mathrm{d} \omega_i} \cdot \int_{\Omega^{+}} L_i\left(\mathrm{p}, \omega_i\right) f_r\left(\mathrm{p}, \omega_i, \omega_o\right) \cos \theta_i \mathrm{~d} \omega_i$</p><p>前半项是做归一化处理的visibility，后半项是shading；对于每一点的结果，是计算出的shading×visibility的结果，正是做SM的思路。</p><p>保证该近似（计算）正确的条件：控制积分域足够小，也就是只有点光源或者方向光源；shading部分smooth→brdf的变化足够小→假设一个面光源，即保证光源各处的radience变化也不大，且brdf diffuse。</p><blockquote><p>两个条件具备一个即可，Ambient Occlusion还会用到该思路。</p></blockquote><h1 id="PCF"><a href="#PCF" class="headerlink" title="PCF"></a>PCF</h1><h2 id="软阴影"><a href="#软阴影" class="headerlink" title="软阴影"></a>软阴影</h2><blockquote><p>SM只给出硬阴影。</p></blockquote><p><img src="/2022/04/01/UCSB-CS291A-Note-1-PCSS/soft.png" alt></p><p>半影区域上看向面光源，部分遮挡，部分未遮挡。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>percentage closer filter，其实起初是对阴影边界反走样（抗锯齿）的方法，后买你发现可以用在软阴影的实现上。具体实现：filtering（其实这里只是求了个平均） the results of shadow comparisons。</p><blockquote><p>not filter the shadow map；和模糊了的深度做出来深度测试仍然是非0即1的，没有意义；当然也不是在最后的结果上做模糊出效果。</p></blockquote><p>SM的基本思想：判断一个点是否在阴影中，从shading point连向light然后跟Shadow map对应的这一点深度比较判断是否在阴影内；那么在PCF中，仍然要进行比较，来判断是否在阴影中，这里把其投影到light之后不再只找其对应的单个像素，而是找其周围一圈像素，把周围像素比较的结果加起来平均，得到一个0~1之间的数，用于得到结果。</p><blockquote><p>可以加权。</p></blockquote><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>对范围内的像素分别进行深度值比较，对比较的结果（01值）进行加权平均（这时候不再是非0即1的了）。</p><p>PCF filter size，small→sharper，large→softer；而软阴影实际上就是对硬阴影做大的filter；在不同的位置将硬阴影转化为软阴影，且不同位置不同filter_size，和遮挡物距离（blocker distance）相关。</p><h1 id="PCSS"><a href="#PCSS" class="headerlink" title="PCSS"></a>PCSS</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>Percentage Closer Soft Shadows，Filter size应该和blocker distance相关；blocker distance: relative average projected blocker depth。</p><p><img src="/2022/04/01/UCSB-CS291A-Note-1-PCSS/blockerdistance.png" alt></p><p>W_Penumbra代表“软”的程度，部分由光源决定。当遮挡物靠近接受物（平面），容易想到，“软”的范围也会变小。</p><p>数学形式如下，一个简单的相似三角形。</p><p>$w_{\text {Penumbra }}=\left(d_{\text {Receiver }}-d_{\text {Blocken }}\right) \cdot w_{\text {Light }} / d_{\text {Blocker }}$</p><blockquote><p>需要filter的大小，取决于light和blocker，而blocker的形状可能会有区别，所以要average，对于shading point，要看一定范围有多少遮挡，对这些做average。</p><p>面光源生成SM的问题，实际上是模拟为点光源（例如camera放在面中间），生成。</p></blockquote><h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><p>Step1: Blocker Search</p><p>getting the average blocker depth <strong>in a certain region</strong></p><p>Step2: Penumbra estimation</p><p>use the average blocker depth to determine <strong>filter size</strong></p><p>Step3: PCF</p><p>给出硬阴影该Filter多大，就完全转化为PCF问题了。</p><blockquote><p>本质：求出了阴影中需要做PCF的半影部分后再进行PCF的计算；动态设置了PCF的搜索范围→动态调节了半影范围，也就是实现了硬阴影部分清晰，软阴影部分模糊。</p></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="遮挡物距离光源的距离"><a href="#遮挡物距离光源的距离" class="headerlink" title="遮挡物距离光源的距离"></a>遮挡物距离光源的距离</h3><p>如何确定一个blocker距离光源的位置？</p><p>直观上，如果比较结果显示该点被阻挡，那么所记录深度应该就是遮挡物深度；从shading point连向点光源，取周围区域判断是否在阴影中（in a certain region）即可。</p><p>然而，blocker可能是物体（有一定深度区别），所以不能直接使用shadow map中对应单个点的深度来代表blcoker距离，如果该点的深度与周围点的深度差距较大（例如表面陡峭或者对应点正好有一个孔洞），选择使用平均遮挡距离（average blocker depth）。</p><p>求blocker距离（平均遮挡距离）的具体方法：把目标shading point转换到light space找到shading point在shadow map上对应的像素；如果shading point的深度大于这个shadow map上点对应的深度，那么该像素所对应的点是一个Blocker，<strong>取shadow map上这个像素周围的一些像素</strong>，找出能够挡住shading point的点的像素，求其平均深度值作为blocker的深度。</p><blockquote><p>但是这里仍然需要一个“范围”，需要使用blocker distance去确定filter size，然而blocker distance本身的计算就需要一个”范围”，转进到下个问题。</p></blockquote><h3 id="遮挡物查询的范围"><a href="#遮挡物查询的范围" class="headerlink" title="遮挡物查询的范围"></a>遮挡物查询的范围</h3><p>如何确定一个大概的范围判断是否是Blocker呢？</p><p>即确认“取shadow map上这个像素周围的一些像素，找出能够挡住shading point的点的像素”这一步的寻找范围大小。两种方法，取固定大小范围；heuristics: depends on the light size and receiver’s distance from the light。</p><p><img src="/2022/04/01/UCSB-CS291A-Note-1-PCSS/blockerrange.png" alt></p><blockquote><p>认为SM放在近平面上。</p></blockquote><p>计算shadow map的时候在光源处设置过相机，并把shadow map放在由相机看向场景形成的视锥中的近截面上；将光源shading point相连，在shadow map上截出来的面就是要查询计算平均遮挡距离的部分。这部分的深度求一个均值，就是Blocker到光源的平均遮挡距离。</p><p>这种方法make sense在于离光源越远，遮挡物也会更多，所以需要在Shadow map上的一个小区域内查找blocker；离光源越近，遮挡物会少，所以需要在Shadow map上的一个大区域内查找blocker；且近的物体相对变大，其自身形状也需求大范围的检查。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>确定Blocker需要一遍访问次数；PCF又要对这个特定区域走一遍；对于多光源，需要逐个处理；且线性时间。存在各种方法处理。</p><h2 id="数学原理-1"><a href="#数学原理-1" class="headerlink" title="数学原理"></a>数学原理</h2><blockquote><p>Also a deeper look at PCF.</p></blockquote><p>Filter / Convolution</p><p>$[w * f] (p)=\sum_{q \in \mathcal{N}(p)} w(p, q) f(q)$</p><p>对于f做卷积w，定义为对任意像素p，取邻域N(p)任意点q，点q值按pq值（距离）作加权并写回，也就是<strong>加权平均</strong>。</p><p>In PCSS</p><p>$V(x)=\sum_{q \in \mathcal{N}(p)} w(p, q) \cdot \chi^{+}\left[D_{\mathrm{SM}}(q)-D_{\text {scene }}(x)\right]$</p><p>对</p><p>右边：CHI函数：符号函数（阶梯函数）</p><p>变量&gt;0，那么值为1</p><p>&lt;0，那么值为0</p><p>即阴影比较的结果</p><p>左边：权值/其实不加权也可以</p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Graphics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UCSB CS180 Note 1 Transformation</title>
    <link href="/2021/07/01/UCSB-CS180-Note-1-Transformation/"/>
    <url>/2021/07/01/UCSB-CS180-Note-1-Transformation/</url>
    
    <content type="html"><![CDATA[<h1 id="变换基础"><a href="#变换基础" class="headerlink" title="变换基础"></a>变换基础</h1><h2 id="二维变换"><a href="#二维变换" class="headerlink" title="二维变换"></a>二维变换</h2><p>二维变换；线性变换==矩阵运算，缩放、反射、切变、旋转。</p><p>$\begin{aligned}<br>x^{\prime} &amp; =a x+b y \\<br>y^{\prime} &amp; =c x+d y \\<br>\end{aligned}$</p><p>$\begin{aligned}<br>{\left[\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime}<br>\end{array}\right] } &amp; =\left[\begin{array}{ll}<br>a &amp; b \\<br>c &amp; d<br>\end{array}\right]\left[\begin{array}{l}<br>x \\<br>y<br>\end{array}\right] \\<br>\mathbf{x}^{\prime} &amp; =\mathbf{M} \mathbf{x}<br>\end{aligned}$</p><h2 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h2><blockquote><p>Homogeneous coordinates。</p></blockquote><h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>Q：为什么要引入齐次坐标？</p><p>A：平移变换不是线性变换，无法统一到二维操作中。</p><p>$\left[\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime}<br>\end{array}\right]=\left[\begin{array}{ll}<br>a &amp; b \\<br>c &amp; d<br>\end{array}\right]\left[\begin{array}{l}<br>x \\<br>y<br>\end{array}\right]+\left[\begin{array}{l}<br>t_x \\<br>t_y<br>\end{array}\right]$</p><blockquote><p>但是不希望把平移当做一种特殊的情况去考虑。</p></blockquote><p>所以引入齐次坐标：可以把线性变换和平移（二者合起来就是仿射变换），用同一种形式去表示。</p><h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>二维的点、向量，增加一个维度。</p><p>$\begin{aligned}<br>&amp; 2 D \text { point } &amp; =(x, y, 1)^T \\<br>&amp; 2 D \text { vector } &amp; =(x, y, 0)^T<br>\end{aligned}$</p><p>二维点这样表示很”好”，增加了一个“1”的维度，可以表示平移变换，统一了线性变换和平移变换。</p><p>$\left(\begin{array}{c}<br>x^{\prime} \\<br>y^{\prime} \\<br>w^{\prime}<br>\end{array}\right)=\left(\begin{array}{ccc}<br>1 &amp; 0 &amp; t_x \\<br>0 &amp; 1 &amp; t_y \\<br>0 &amp; 0 &amp; 1<br>\end{array}\right) \cdot\left(\begin{array}{l}<br>x \\<br>y \\<br>1<br>\end{array}\right)=\left(\begin{array}{c}<br>x+t_x \\<br>y+t_y \\<br>1<br>\end{array}\right)$</p><blockquote><p>增加维度“1”、“0”的理解：</p><ol><li>向量表示一个方向，具有平移不变性，也因此向量增加的维度是“0”；向量做任何平移变换操作时，就可以保证符合平移不变性。</li><li>更深层次的理解，增加维度的“0”、“1”是有意义的。</li></ol></blockquote><p>齐次坐标下的二维点。</p><p>$\left(\begin{array}{c}<br>x \\<br>y \\<br>w<br>\end{array}\right) \text { is the } 2 \mathrm{D} \text { point }\left(\begin{array}{c}<br>x / w \\<br>y / w \\<br>1<br>\end{array}\right), w \neq 0$</p><h3 id="How"><a href="#How" class="headerlink" title="How"></a>How</h3><h4 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h4><p>$\mathbf{S}\left(s_x, s_y\right)=\left(\begin{array}{ccc}<br>s_x &amp; 0 &amp; 0 \\<br>0 &amp; s_y &amp; 0 \\<br>0 &amp; 0 &amp; 1<br>\end{array}\right)$</p><h4 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h4><p>$\mathbf{T}\left(t_x, t_y\right)=\left(\begin{array}{ccc}<br>1 &amp; 0 &amp; t_x \\<br>0 &amp; 1 &amp; t_y \\<br>0 &amp; 0 &amp; 1<br>\end{array}\right)$</p><h4 id="Rotation"><a href="#Rotation" class="headerlink" title="Rotation"></a>Rotation</h4><p>$\mathbf{R}(\alpha)=\left(\begin{array}{ccc}<br>\cos \alpha &amp; -\sin \alpha &amp; 0 \\<br>\sin \alpha &amp; \cos \alpha &amp; 0 \\<br>0 &amp; 0 &amp; 1<br>\end{array}\right)$</p><h2 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h2><blockquote><p>Affine Transformation。</p></blockquote><p>线性变换+平移变换；齐次坐标下，先线性后平移。</p><p>$\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime}<br>\end{array}\right)=\left(\begin{array}{ll}<br>a &amp; b \\<br>c &amp; d<br>\end{array}\right) \cdot\left(\begin{array}{l}<br>x \\<br>y<br>\end{array}\right)+\left(\begin{array}{l}<br>t_x \\<br>t_y<br>\end{array}\right)$</p><p>$\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime} \\<br>1<br>\end{array}\right)=\left(\begin{array}{ccc}<br>a &amp; b &amp; t_x \\<br>c &amp; d &amp; t_y \\<br>0 &amp; 0 &amp; 1<br>\end{array}\right) \cdot\left(\begin{array}{l}<br>x \\<br>y \\<br>1<br>\end{array}\right)$</p><h2 id="逆变换"><a href="#逆变换" class="headerlink" title="逆变换"></a>逆变换</h2><blockquote><p>Inverse transform。</p></blockquote><p><img src="/2021/07/01/UCSB-CS180-Note-1-Transformation/inversetransform.png" alt></p><h2 id="组合变换"><a href="#组合变换" class="headerlink" title="组合变换"></a>组合变换</h2><p>复杂的变换都是由简单的组合而来；变换的顺序很重要；<strong>矩阵乘法无交换律</strong>。</p><blockquote><p>e.g. 一个不在原点的做旋转</p><p>先变换到原点→旋转→转换回原来位置</p></blockquote><h2 id="三维变换"><a href="#三维变换" class="headerlink" title="三维变换"></a>三维变换</h2><p>$\begin{aligned}<br>&amp; 3 D \text { point }=(x, y, z, 1)^T \\<br>&amp; 3 D \text { vector }=(x, y, z, 0)^T<br>\end{aligned}$</p><p>齐次坐标下，三维变换。</p><p>$\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime} \\<br>z^{\prime} \\<br>1<br>\end{array}\right)=\left(\begin{array}{lllc}<br>a &amp; b &amp; c &amp; t_x \\<br>d &amp; e &amp; f &amp; t_y \\<br>g &amp; h &amp; i &amp; t_z \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{array}\right) \cdot\left(\begin{array}{l}<br>x \\<br>y \\<br>z \\<br>1<br>\end{array}\right)$</p><h3 id="Scale-1"><a href="#Scale-1" class="headerlink" title="Scale"></a>Scale</h3><p>$\mathbf{S}\left(s_x, s_y, s_z\right)=\left(\begin{array}{cccc}<br>s_x &amp; 0 &amp; 0 &amp; 0 \\<br>0 &amp; s_y &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; s_z &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{array}\right)$</p><h3 id="Translation-1"><a href="#Translation-1" class="headerlink" title="Translation"></a>Translation</h3><p>$\mathbf{T}\left(t_x, t_y, t_z\right)=\left(\begin{array}{cccc}<br>1 &amp; 0 &amp; 0 &amp; t_x \\<br>0 &amp; 1 &amp; 0 &amp; t_y \\<br>0 &amp; 0 &amp; 1 &amp; t_z \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{array}\right)$</p><h3 id="Rotation-1"><a href="#Rotation-1" class="headerlink" title="Rotation"></a>Rotation</h3><h4 id="around-axis"><a href="#around-axis" class="headerlink" title="around axis"></a>around axis</h4><p>$\begin{aligned}<br>&amp; \mathbf{R}_x(\alpha)=\left(\begin{array}{cccc}<br>1 &amp; 0 &amp; 0 &amp; 0 \\<br>0 &amp; \cos \alpha &amp; -\sin \alpha &amp; 0 \\<br>0 &amp; \sin \alpha &amp; \cos \alpha &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{array}\right) \\<br>&amp; \mathbf{R}_y(\alpha)=\left(\begin{array}{cccc}<br>\cos \alpha &amp; 0 &amp; \sin \alpha &amp; 0 \\<br>0 &amp; 1 &amp; 0 &amp; 0 \\<br>-\sin \alpha &amp; 0 &amp; \cos \alpha &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{array}\right) \\<br>&amp; \mathbf{R}_z(\alpha)=\left(\begin{array}{cccc}<br>\cos \alpha &amp; -\sin \alpha &amp; 0 &amp; 0 \\<br>\sin \alpha &amp; \cos \alpha &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; 1 &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{array}\right)<br>\end{aligned}$</p><p><img src="/2021/07/01/UCSB-CS180-Note-1-Transformation/rotationaroundaxis.png" alt></p><h4 id="Eular-Angle"><a href="#Eular-Angle" class="headerlink" title="Eular Angle"></a>Eular Angle</h4><p>$\mathbf{R}_{x y z}(\alpha, \beta, \gamma)=\mathbf{R}_x(\alpha) \mathbf{R}_y(\beta) \mathbf{R}_z(\gamma)$</p><p>A rotation by q about an arbitrary axis can be decomposed into the concatenation of rotations about the x, y, and z axes。</p><blockquote><p>Note that rotations do not commute。</p><p>Eular angle: composing rotations</p><ul><li>pitch(up&amp;&amp;down)</li><li>yaw(left&amp;&amp;right)</li><li>roll(rolling)</li></ul><p>As regard to a camera, only concern about it’s pitch and yaw.</p></blockquote><p><img src="/2021/07/01/UCSB-CS180-Note-1-Transformation/flighteular.png" alt></p><h4 id="Rodrigues-Rotation"><a href="#Rodrigues-Rotation" class="headerlink" title="Rodrigues Rotation"></a>Rodrigues Rotation</h4><p>Rotation by angle $\alpha$ around axis $n$</p><p>$\mathbf{R}(\mathbf{n}, \alpha)=\cos (\alpha) \mathbf{I}+(1-\cos (\alpha)) \mathbf{n n}^T+\sin (\alpha) \underbrace{\left(\begin{array}{ccc}<br>0 &amp; -n_z &amp; n_y \\<br>n_z &amp; 0 &amp; -n_x \\<br>-n_y &amp; n_x &amp; 0<br>\end{array}\right)}_{\mathbf{N}}$</p><blockquote><p>n是旋转轴，alpha是旋转角度；默认n过原点，不是，则移到原点，再移回去。</p></blockquote><p><img src="/2021/07/01/UCSB-CS180-Note-1-Transformation/Rrotation.png" alt></p><blockquote><ol><li>Move fixed point to origin;</li><li>Rotate;</li><li>Move fixed point back.</li></ol></blockquote><h4 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h4><p>解决欧拉角Gimbal Lock的问题。</p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Graphics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HJ C++ OOP Note 9 Conversion Function</title>
    <link href="/2021/05/01/HJ-C++-OOP-Note-9-Conversion-Function/"/>
    <url>/2021/05/01/HJ-C++-OOP-Note-9-Conversion-Function/</url>
    
    <content type="html"><![CDATA[<h1 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h1><p>转换函数是类成员函数，用来将对象类型转换为其他类型。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * type 要转换成的类型</span><br><span class="hljs-comment"> * const 转换函数只是转换对象类型，并不会（也不应该）改变对象内的任何成员，设为const</span><br><span class="hljs-comment"> * &#123;&#125; 没有参数，转换不需要参数</span><br><span class="hljs-comment"> * @return 没有返回类型，返回类型就是转换成的类型</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/2021/05/01/HJ-C++-OOP-Note-9-Conversion-Function/conversion.png" alt></p><p>如果后面场合有把Fraction当作double使用，编译器会认为很合理（实际上认为也是合理的，才会这么做）；调用（黄色部分）即可；return type不用给出， 默认由名称里的类型给定。</p><blockquote><p>转换函数通常是const的，因为并不会改变数据。</p><p>Q：编译器如何编译<code>double d = 4 + f;</code>？</p><p>A：首先找有没有全局的<code>operator+(type, Fraction)</code>函数，找到则编译通过（type 为整型或浮点型都可以）；如果走不通，则看<code>f</code>能否转成整型或浮点型（类中是否有相应的conversion function），可以则编译通过。</p><p>只要认为合理，也可以给出转换成其他类型的转换函数。</p></blockquote><h2 id="标准库用到转换函数的地方"><a href="#标准库用到转换函数的地方" class="headerlink" title="标准库用到转换函数的地方"></a>标准库用到转换函数的地方</h2><p><img src="/2021/05/01/HJ-C++-OOP-Note-9-Conversion-Function/conversion2.png" alt></p><blockquote><p>bool模板偏特化。</p></blockquote><p><code>operator[]</code>对中括号做重载，取出第100个位置bool值，传回来bool，却传回蓝色的类型reference。</p><blockquote><p>设计模式：Proxy。</p></blockquote><p>合乎想像的是，蓝色类型reference果然有向bool转换的转换函数。</p><h1 id="转换构造函数"><a href="#转换构造函数" class="headerlink" title="转换构造函数"></a>转换构造函数</h1><p>non-explicit-one-argument constructor；没有explicit的可单传入实参构造函数。one-argument，只需要一个实参（其实是可以多parameter的，其他参数给出默认值即可）；non-explicit，构造函数没有加关键字explicit。</p><h2 id="转换功能"><a href="#转换功能" class="headerlink" title="转换功能"></a>转换功能</h2><p>和上述转换函数方向相反；（没有explicit的可单传入实参构造函数）可以用于把double转换为Fraction类型。</p><p><img src="/2021/05/01/HJ-C++-OOP-Note-9-Conversion-Function/neoa.png" alt></p><blockquote><p>Q：编译器如何编译<code>d2 = f + 4;</code>？</p><p>编译器找到Fraction重载的<code>operator+</code>函数，发现函数参数为Fraction，于是看看4可不可以转成Fraction（隐式转换），由于Fraction有一个non-explicit-one-argument constructor，因此转换成功，该行编译成功。</p></blockquote><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p>当转换函数和无explicit的可单传入实参构造函数同时出现。</p><p><img src="/2021/05/01/HJ-C++-OOP-Note-9-Conversion-Function/neoa2.png" alt></p><blockquote><p>Q：是否可以编译通过？</p><p>不可以！两条路径可行，所以编译器不知道走哪条路径。</p></blockquote><h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p><img src="/2021/05/01/HJ-C++-OOP-Note-9-Conversion-Function/eoa.png" alt></p><p>explicit的可单传入实参构造函数；explicit告诉编译器不可以把3自动变为（隐式转换为）1/3；该构造函数只能以构造函数的形式调用；这里4无法转换，报错转换失败。</p><blockquote><p>explicit只有用在构造函数前面。Cpp面向对象高级编程（下）-学习笔记（一）转换函数.md</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HJ C++ OOP Note 8 Classes</title>
    <link href="/2021/04/08/HJ-C++-OOP-Note-8-Classes/"/>
    <url>/2021/04/08/HJ-C++-OOP-Note-8-Classes/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Object Oriented Programming</p><ul><li>Inheritance</li><li>Composition</li><li>Delegation</li></ul></blockquote><h1 id="Composition"><a href="#Composition" class="headerlink" title="Composition"></a>Composition</h1><blockquote><p>has-a.</p></blockquote><h2 id="复合关系"><a href="#复合关系" class="headerlink" title="复合关系"></a>复合关系</h2><p><img src="/2021/04/08/HJ-C++-OOP-Note-8-Classes/composition.png" alt></p><p>黄色表示这个class queue中，有一个这种sequence类东西；且默认为<code>deque&lt;T&gt;</code>类型，即这个sequence是<code>deque&lt;T&gt;</code>；从C开始存在这种关系</p><blockquote><p>图，黑色菱形，即表示Composition。</p></blockquote><p><img src="/2021/04/08/HJ-C++-OOP-Note-8-Classes/adapter.png" alt></p><p>deque中可能有很多接口，但是queue只开放这几个，queue的所有功能都是通过deque来完成的，这种模式叫做<strong>Adapter模式</strong>，字如其名，改造适配。</p><p>该例子是个特例，并不是所有的Composition都是这样（实现全部挂钩），只要拥有即可；有了<code>Container</code>就有<code>Componenet</code>，生命是一起的；复合就是一种结构中包含其他类型或者结构。</p><p><img src="/2021/04/08/HJ-C++-OOP-Note-8-Classes/sizeof.png" alt></p><p>内存角度解释Composition，queue中的 c 所占的空间为40Bytes；后面的图为deque内部以及 Itr 类内部的数据，明白地显示了为什么 c 的大小为 40Bytes。</p><h2 id="复合关系下的构造和析构"><a href="#复合关系下的构造和析构" class="headerlink" title="复合关系下的构造和析构"></a>复合关系下的构造和析构</h2><p><img src="/2021/04/08/HJ-C++-OOP-Note-8-Classes/compositionctordtor.png" alt></p><blockquote><p>构造函数间不可越俎代庖。</p></blockquote><p>左边拥有右边，左边叫做Container，右边叫做Component。</p><p>红色的部分是编译器自动加上的，并非程序员写的；可能内部的Component有多个构造函数，但是编译器不知道需要哪个，所以就调用一个默认的构造函数，如果这并不是你期望的，那就需要自己在Comtainer的构造函数的初始列位置写上要调用的构造函数。</p><blockquote><p>构造函数总是调用默认的构造函数，如果需要其他构造函数需要自己写、参数。</p></blockquote><h1 id="Delegation"><a href="#Delegation" class="headerlink" title="Delegation"></a>Delegation</h1><blockquote><p>Composition by reference.</p></blockquote><p><img src="/2021/04/08/HJ-C++-OOP-Note-8-Classes/hb.png" alt></p><p>指针rep指向另外一个StringRepclass，左边只是有一个指针指向右边（composition by reference）；Delegation又叫Composition by reference，因为也是拥有，只是拥有的只是个指针；也可以说，两个类之间用指针相连，就叫做 Delegation。</p><p>因为需要右边的时候才创建右边，所以左右两边的生命不同步。</p><p>String类中的所有操作都是通过rep指针来实现的，这种方式叫做pointer to implementation（pimpl），指针指向实现功能的类；这种设计的好处是，右边无论怎么变化都不影响左边，这种手法又叫做“编译防火墙”。</p><p>另一个名称叫做Handle&amp;&amp;Body，左边是Handle，右边是Body；意思是左边只负责对外的接口；而右边负责实现各种功能；之后指针其实可以指向不同的实现类（弹性），客户端可以不受影响且左边可以不用重复编译。</p><p>这种做法另一个目的是为了做共享reference counting，三个String对象 a、b和c，都在用字符串”Hello”，三个对象共享 “Hello”，现在 n 是 3。内容一样才能共享。</p><blockquote><p>如果 a 想修改字符串的内容，但是不影响 b 和 c，那就拷贝一份让 a 去更改，然后就只剩下 b和 c 共享字符串。这是copy-on-write，就是写的时候copy一份副本让你去写。</p></blockquote><h1 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h1><blockquote><p>is a.</p></blockquote><p><img src="/2021/04/08/HJ-C++-OOP-Note-8-Classes/inheritance.png" alt></p><p>public继承：is a关系；这里只有data，还没有函数，这里子类继承了父类的数据（两个指针）。</p><h2 id="继承关系下的构造与析构"><a href="#继承关系下的构造与析构" class="headerlink" title="继承关系下的构造与析构"></a>继承关系下的构造与析构</h2><p><img src="/2021/04/08/HJ-C++-OOP-Note-8-Classes/inheritance2.png" alt></p><p>子类的对象中有父类的成分；父类的析构函数必须是virtual的，否则会出现undefined behavior；红色部分是编译器添加的；谁先谁后已经是编译器完成了，程序员不用操心。</p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p><img src="/2021/04/08/HJ-C++-OOP-Note-8-Classes/virtual1.png" alt></p><p>语法，在函数前加上virtual；函数继承，继承的是调用权，子类可以调用父类的函数；子类是否需要重新定义，看virtual类型。</p><h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><p><img src="/2021/04/08/HJ-C++-OOP-Note-8-Classes/virtual2.png" alt></p><p>输入文件名称后，按下开始键后，程序会收到一个文件名；程序要检测file name是否正确，是否有不合法字符；到硬盘中查找file是否存在；如果存在，则将该文件打开，并读出来。</p><h3 id="Template-Method"><a href="#Template-Method" class="headerlink" title="Template Method"></a>Template Method</h3><p>上面的这个流程所有的软件都是一样的，除了最后将文件读出来有所区别；将这个框架写成模板，即CDocument类，其中读内容动作没法做，所以只在父类定义虚函数Serialize，这里可以设计为纯虚函数，也可以设计为默认定义的函数，也可以是空函数。</p><p><img src="/2021/04/08/HJ-C++-OOP-Note-8-Classes/virtual3.png" alt></p><p>子类对象调用父类函数OnFileOpen()，子类中没有函数OnFileOpen()，myDoc.OnFileOpen()实际调用CDocument::OnFileOpen(&amp;myDoc)，所以才能找到CDocument类中的OnFileOpen函数。</p><p><code>CDocument::OnFileOpen(&amp;myDoc);</code>中传入了myDoc的地址，该地址也传入OnFileOpen；调用Serialize的时候，编译器通过this进行调用，即this-&gt;Serialize()，而this就是myDoc，也就调用了CMyDoc类的Serialized()函数。</p><p>myDoc.OnFileOpen()的执行流程：</p><ol><li>调用CDocument的OnFileOpen函数；</li><li>在OnFileOpen函数里调用了CMyDoc的Serialize()函数；</li><li>执行完了Seriazlize()函数后又回到OnFileOpen()函数中继续执行；</li><li>OnFileOpen函数执行完毕后，回到main函数中。</li></ol><p>过程如图中的灰色线所示。将关键动作Serialize延缓到了子类中执行。将OnFileOpen()这个函数的这种做法叫做<strong>Template Method</strong>模式。</p><blockquote><p>Java语言中的函数称为Method。</p><p>框架，将相同功能的确定的写好，留下不能确定的部分设计为虚函数，留给子类实现。</p></blockquote><h3 id="代码模拟"><a href="#代码模拟" class="headerlink" title="代码模拟"></a>代码模拟</h3><p>模拟该过程的代码。</p><p><img src="/2021/04/08/HJ-C++-OOP-Note-8-Classes/virtual4.png" alt></p><h1 id="Inheritance-Composition"><a href="#Inheritance-Composition" class="headerlink" title="Inheritance + Composition"></a>Inheritance + Composition</h1><h2 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h2><p>两种情况：Derived继承Base后，复合Component；Derived继承，复合Component的Base。</p><p><img src="/2021/04/08/HJ-C++-OOP-Note-8-Classes/ic1.png" alt></p><blockquote><p>第二种比较好想，Componet→Base→Derived，析构Derived→Base→Componet。</p></blockquote><p>第一种以重要性记忆，Base在前，先构造后析构。</p><p><img src="/2021/04/08/HJ-C++-OOP-Note-8-Classes/ic2.png" alt></p><h1 id="Delegation-Inheritance"><a href="#Delegation-Inheritance" class="headerlink" title="Delegation + Inheritance"></a>Delegation + Inheritance</h1><h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><p><img src="/2021/04/08/HJ-C++-OOP-Note-8-Classes/di1.png" alt></p><p>Document，多开窗口，打开同一文件；或者对于一个数据，多种View查看；要求数据变化，则多窗口下或者多视角下，同时发生变化。</p><p><img src="/2021/04/08/HJ-C++-OOP-Note-8-Classes/di2.png" alt></p><p>抽象出Observer，且使使用者Subject可以拥有多个Observer；Subject vector容器放指向Observer的指针，注意到Observer可被继承，即可以派生出多种功能的Observer，均可被放在Subject容器中。</p><p>Subject提供注册、注销、遍历通知的功能；遍历通知，遍历调用update即可。</p><blockquote><p>这就是OOP。</p></blockquote><h2 id="Composite"><a href="#Composite" class="headerlink" title="Composite"></a>Composite</h2><p><img src="/2021/04/08/HJ-C++-OOP-Note-8-Classes/di4.png" alt></p><p>希望写一个目录系统；Primitive代表文件，Composite代表文件夹，可以容纳多个文件，但同时也可以容纳文件夹；对于Component设计为，Primitive-is a-Component，Composite-is a-Component；于是，Composite不写死为放Primitive或者Composite（都可以放），而是放Component。</p><blockquote><p>以上，都是放指针，不额外说明。</p><p>add设计同理，加文件和文件夹都可以；add不可以设置为纯虚函数，Primitive无法做add的动作。</p></blockquote><h2 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h2><p><img src="/2021/04/08/HJ-C++-OOP-Note-8-Classes/di5.png" alt></p><p>希望树状继承体系，可以创建未来才会出现的子类；设计一个框架，客户买后，才会派生子类；无法new，因为不知道类名，希望派生类有原型，框架看到后作为蓝本，进而创建。</p><p>原型，子类中安排一个静态对象，类型为class自己；每个子类将原型登记到框架端，则框架相对的需要准备空间；子类构造函数设为私有，自己创建一份，可以调用，构造函数内的addPrototype将指针放到prototypes里；子类设计clone，可以new自己，框架端通过原型调用clone函数，没有原型则无法调用；设想clone可以设置为静态函数，使框架直接调用，问题在于静态函数调用需要classname，而框架不知道类名。</p><p>子类有一些负担，私有构造函数等，但为了和框架搭配，是值得的。</p><p><img src="/2021/04/08/HJ-C++-OOP-Note-8-Classes/pt1.png" alt></p><p>clone纯虚函数，要求子类必须给出，容器数组放原型。class里静态的data必须在类外做定义（给内存）。findAddClone让框架端在容器里找原型（实际可能是靠名称找），找到之后调用该原型的clone。</p><p><img src="/2021/04/08/HJ-C++-OOP-Note-8-Classes/pt2.png" alt></p><p>clone实现，总是new自己；原型，静态自己，创建在私有区域，创建出来时候调用构造函数，这里把自己放在框架容器内；两个构造函数，即#带参构造函数有什么用，框架利用原型clone时，需要new，这里使用的构造函数，不能再把对象放上去，因为框架容器只放原型，于是再写#带参构造函数，同时该构造函数仍然不打算让外界创建，希望让原型使用，所以private或者protected，又希望其和初始构造函数区别，带一个参数，但实际上完全没有使用。</p>]]></content>
    
    
    <categories>
      
      <category>Course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HJ C++ OOP Note 7 Template</title>
    <link href="/2021/04/07/HJ-C++-OOP-Note-7-Template/"/>
    <url>/2021/04/07/HJ-C++-OOP-Note-7-Template/</url>
    
    <content type="html"><![CDATA[<blockquote><p>T：还没有决定是什么；使用时进行绑定；编译器会对代码进行替换。</p></blockquote><h1 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h1><p><img src="/2021/04/07/HJ-C++-OOP-Note-7-Template/template1.png" alt></p><p>template和typename都是关键字，<code>template&lt;typename T&gt;</code>告诉编译器当前类型还没有绑定；用法：<code>complex&lt;double&gt;</code>，编译器会将代码中的 T 替换为double；虽然模板会造成代码膨胀，但这是必须的。、</p><h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><p><img src="/2021/04/07/HJ-C++-OOP-Note-7-Template/function.png" alt></p><p>此处的<code>template &lt;class T&gt;</code> 中的class和typename是一样的；不像类模板必须明确指出T的实际类型。</p><p>function template会自动做实参的推导；&lt;操作符重载会自动参考Stone类的方法：有没有定义小于的函数；设计是合理的，比大小必然是&lt;，而具体比较实现则由T类负责，责任分开。</p><h1 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h1><p><img src="/2021/04/07/HJ-C++-OOP-Note-7-Template/namespace.png" alt></p><p>所有事物被包括在命名空间内，使不会被同名；标准库所有内容包括在在命名空间std内。</p><p>使用方法：<code>using namespace std;</code>等同于把封锁全部打开，不用写全名；<code>using std::cout</code>一条一条指定声明；全部使用全名。</p>]]></content>
    
    
    <categories>
      
      <category>Course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HJ C++ OOP Note 6 Memory</title>
    <link href="/2021/04/06/HJ-C++-OOP-Note-6-Memory/"/>
    <url>/2021/04/06/HJ-C++-OOP-Note-6-Memory/</url>
    
    <content type="html"><![CDATA[<h1 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h1><h2 id="对象相关"><a href="#对象相关" class="headerlink" title="对象相关"></a>对象相关</h2><blockquote><p>局部对象，定义在作用域内的对象，不再单独说明。</p></blockquote><h3 id="静态对象"><a href="#静态对象" class="headerlink" title="静态对象"></a>静态对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&#123;<br><span class="hljs-function"><span class="hljs-type">static</span> Complex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个对象前面加上static修饰符后，即变成所谓的静态对象（static object），其生命在作用域（scope）结束之后仍然存在，直到整个程序的结束。</p><h3 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>&#123;...&#125;;<br>...<br><span class="hljs-function">Complex <span class="hljs-title">c3</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义在任何作用域或者说大括号之外的对象。</p><blockquote><p><strong>一个对象的存在和消失取决于构造函数和析构函数何时被调用。</strong></p></blockquote><p>c3就是所谓的global object，其生命在整个程序结束之后才结束，也可以把它视为一种static object，其作用域是整个程序。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>对于全局对象，程序一开始，其构造函数就先被执行（比程序进入点更早）；程序即将结束前其析构函数被执行。</p><p>对于静态对象，当对象诞生时其构造函数被执行；当程序将结束时其析构函数才被执行，但比全局对象的析构函数早一步执行。</p><p>对于局部对象，当对象诞生时，其构造函数被执行；当离开作用域时，其析构函数被执行；对于new出来的局部对象，当对象诞生时其构造函数被执行，析构函数则在对象被delete时执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>&#123;...&#125;;<br>...<br>&#123;<br><span class="hljs-comment">// Complex(3)是该函数体内的临时对象，其所占用的空间从heap中new得到</span><br><span class="hljs-comment">// 也就是动态分配得到，p指向这块空间</span><br>Complex* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Complex</span>(<span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>静态全局对象和一般的全局对象的区别就是一般的全局对象在程序的其他文件中可以通过关键字extern来调用，而static声明的全局变量则只能在本文件中使用。</p></blockquote><h2 id="栈空间"><a href="#栈空间" class="headerlink" title="栈空间"></a>栈空间</h2><p><strong>stack，是存在于某作用域（scope）的一块内存空间（memory space）</strong>，例如调用函数，函数本身即会形成一个stack用来放置它所接收的参数，以及返回地址。</p><p>在函数本体（function body）内声明的任何变量，其所使用的内存块都取自上述stack。</p><h2 id="栈对象"><a href="#栈对象" class="headerlink" title="栈对象"></a>栈对象</h2><blockquote><p>以下主要说栈对象的生命周期。</p></blockquote><p>栈对象（stack object），其声明在作用域（scope）结束之际结束。这种作用域内的对象（object），又叫做local object，因为它会被自动清理（意思是析构函数被自动调用）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>&#123;...&#125;;<br>...<br>&#123;<br><span class="hljs-comment">// c1所占用的空间来自于stack</span><br><span class="hljs-function">Complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>举例，当离开作用域{}的时候，c1的生命自然就消失了， 即从栈中获得的内存，离开作用域的时候会自动释放（析构函数被自动调用）。</p><h2 id="堆空间"><a href="#堆空间" class="headerlink" title="堆空间"></a>堆空间</h2><p>Heap，所谓system heap，是指由操作系统提供的一块global内存空间，程序可动态分配（dynamic allocated）从其中获得若干区块（blocks）。new去取，去动态获得，但是同时也要兼任起动态释放的责任。</p><h2 id="堆对象"><a href="#堆对象" class="headerlink" title="堆对象"></a>堆对象</h2><p>当离开作用域{}的时候，动态分配的内存不会消失，即从堆中动态取得的内存不会自动消失，需要手动释放（delete）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>&#123;...&#125;;<br>...<br>&#123;<br>Complex *p = <span class="hljs-keyword">new</span> Complex;<br>...<br><span class="hljs-keyword">delete</span> p;<br>&#125;<br><span class="hljs-comment">// B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>&#123;...&#125;;<br>...<br>&#123;<br>Complex *p = <span class="hljs-keyword">new</span> Complex;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>A：p所指向的便是heap object，因为是动态从操作系统某个地方分配的内存，其生命周期在它被delete之际（此时默认析构函数或者手写析构函数被调用）结束。</p><p>B：会出现内存泄露（memory leak），因为当作用域结束后，<strong>p所指向的heap object仍然存在，但是指针p的生命却结束了</strong>，作用域之外再也看不到p，也就没机会delete p。</p><h1 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h1><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>先分配memory，再调用ctor。</p><p><img src="/2021/04/06/HJ-C++-OOP-Note-6-Memory/new.png" alt></p><p>编译器new分解为三个步骤，分配内存→指针转型→调用构造函数。</p><p>调用构造函数中，指针来调用成员函数，pc实际上是传入的隐藏参数this，是分配的内存的起始位置，构造函数中进行赋值操作。</p><h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>先调用dtor，再释放memory。</p><p><img src="/2021/04/06/HJ-C++-OOP-Note-6-Memory/delete.png" alt></p><p>class without point members，析构函数不做事情，马上就要delete，清理是做无用功。</p><p><img src="/2021/04/06/HJ-C++-OOP-Note-6-Memory/delete2.png" alt></p><p>class with point members，先调用析构函数，析构函数把字符串里动态分配的内容叉掉，其次释放内存，把字符串（是个指针）本身叉掉delete。</p><h2 id="memory-block"><a href="#memory-block" class="headerlink" title="memory block"></a>memory block</h2><p>即动态分配所得的内存块。</p><p><img src="/2021/04/06/HJ-C++-OOP-Note-6-Memory/block.png" alt></p><p>图中为内存结构，在VC中，分配的内存空间大小都是16的倍数，第一个图中是调试模式下，每个格表示4Bytes，Complex对象占8个字节，调试模式占32+4，cookie占4×2，计算得到的结果是52Bytes，不是16的倍数，所以补充12个Bytes的填补字节（pad部分），凑到64。</p><p>所以看似得到只是两个double的大小，但是用了64。</p><blockquote><p>cookie，记录整块给出的大小，系统回收时了解回收多大。</p></blockquote><p>最后一个byte标注是否给出（本来是40→加上标注变为41）：开头和结尾的<code>00000041</code>，其中的 <code>4</code>是64的16进制，<code>1</code>表示这块空间已经给出去了，<code>0</code>表示这块空间空闲。</p><p>如果没有debug（调试模式），就只有对象大小+cookie大小了：8+（4×2）=16。</p><h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><p>当动态分配的是数组。</p><p><img src="/2021/04/06/HJ-C++-OOP-Note-6-Memory/array.png" alt></p><p>最后又加了4：因为是数组，要记录这是数组。</p><p><img src="/2021/04/06/HJ-C++-OOP-Note-6-Memory/arraynew.png" alt></p><blockquote><p>21h代表一个16进制的数（32+1：已经使用）；3代表新创建了3个字符串。</p></blockquote><p>array new一定要搭配array delete，在使用指针新建字符数组的情况下，在手动释放内存的时候，如果<code>delete[] p;</code>写成了<code>delete p;</code>会造成内存泄露；因为3次析构函数各自负责把各自分配的动态内存叉掉，没有[]，则只会调用一次析构函数。</p><p>值得注意的是，错误用法<code>delete p;</code>导致出现的内存泄漏是String类中的指针指向的空间，而非指针本身。</p><p>如果是Complex 数组对象，因为其中没有指针，所以就算是使用<code>delete p;</code>也是没有问题的。但是为了万无一失，如果使用了array new 一定要搭配 array delete。</p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>包括静态对象和静态函数。</p><p><img src="/2021/04/06/HJ-C++-OOP-Note-6-Memory/static.png" alt></p><p>非static函数通过传入的this指针找到要处理的对象。如上所示：c1调用real()；c1的地址即指针就是this pointer，所以c1和c2虽然调用相同函数，但是给到不同数据。</p><p>成员函数只有一份，但是需要处理很多对象，所以需要人告诉他处理什么（this），成员函数里需要使用this（黄色），可写可不写。</p><p>static函数没有this指针，只能处理静态数据；当数据只需要一份、只能唯一值时，需要定义为静态；静态函数没有this pointer，不可以访问处理多个对象，显然只可以存取处理静态数据。</p><p><img src="/2021/04/06/HJ-C++-OOP-Note-6-Memory/static2.png" alt></p><p>静态数据需要在类外进行声明；调用静态函数有两种方法，通过对象或者class name调用。</p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>把构造函数放在private。</p><p><img src="/2021/04/06/HJ-C++-OOP-Note-6-Memory/singleton2.png" alt></p><p>有的class只希望产生一个对象；A类对象在private里已经有一个了；且A的构造函数放在private中，外界无法使用。设计静态函数getInstance，使外界可以得到唯一的A；再从这个唯一对象调用类函数。</p><p><img src="/2021/04/06/HJ-C++-OOP-Note-6-Memory/singleton1.png" alt></p><p>但是版本1有一个问题，即外界不需要时，A仍然存在；所以把静态自己放在getInstance中，当有人调用getInstance时，才会创建；且有人用后，该对象持续存在。</p>]]></content>
    
    
    <categories>
      
      <category>Course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HJ C++ OOP Note 5 Big Three</title>
    <link href="/2021/04/05/HJ-C++-OOP-Note-5-Big-Three/"/>
    <url>/2021/04/05/HJ-C++-OOP-Note-5-Big-Three/</url>
    
    <content type="html"><![CDATA[<blockquote><p>类的分类，即类中是否有指针成员；若类中有指针，如果只是简单的拷贝，那就是指针拷贝，两个指针指向的是同一个空间，所以不能直接拷贝。因此，如果类中有指针，一定要自己写拷贝构造。</p><p>以下介绍classes with point members。</p></blockquote><h1 id="三大函数"><a href="#三大函数" class="headerlink" title="三大函数"></a>三大函数</h1><p><img src="/2021/04/05/HJ-C++-OOP-Note-5-Big-Three/image.png" alt></p><p>拷贝构造和拷贝赋值，如果没写，编译器会默认写；但是，编译器只是“忠实”逐字节拷贝，导致编译器提供的拷贝赋值只是拷贝了对象的指针，没有真正拷贝对象。</p><p><img src="/2021/04/05/HJ-C++-OOP-Note-5-Big-Three/bigthree1.png" alt></p><p>m_data指向字符串，因为不明确字母个数，动态分配；明显不可以用编译器默认的函数。</p><h1 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h1><p>接受自己类型；是构造函数。析构函数~；死亡时调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* cstr=<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp; str = <span class="hljs-number">0</span>);<br>    String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String&amp; str);<br>    ~<span class="hljs-built_in">String</span>();<br>    <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">get_cstr</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_data&#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* m_data;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-title">String::String</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* cstr=<span class="hljs-number">0</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 首先要创建字符串</span><br><span class="hljs-comment">// 检查指针是否是0</span><br>    <span class="hljs-keyword">if</span> (cstr)<br>    &#123;<br><span class="hljs-comment">// 看存进来多大+1结束符号</span><br>        m_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(cstr) + <span class="hljs-number">1</span>];<br><span class="hljs-comment">// 拷贝到开辟的空间里</span><br>        <span class="hljs-built_in">strcpy</span>(m_data, cstr);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br><span class="hljs-comment">// 放结束符号</span><br>        m_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];<br>        *m_data = <span class="hljs-string">&#x27;\0&#x27;</span>;  <span class="hljs-comment">//这里也许可以这样写：*m_data=&#x27;&#x27;;(网友观点)</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 对象死亡之前调用</span><br><span class="hljs-keyword">inline</span><br>String::~<span class="hljs-built_in">String</span>()<br>&#123;<br><span class="hljs-comment">// 释放动态分配的内存</span><br>    <span class="hljs-keyword">delete</span>[] m_data;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/04/05/HJ-C++-OOP-Note-5-Big-Three/bigthree2.png" alt></p><blockquote><p>得到字符串长度的方法：结束符号、前置长度。cpp采用结束符号，在为字符串分配内存的时候，都要多分配一个字节，用来存放结束符’\0’。</p></blockquote><p>检查传进来是否是空值；放置。存在指针，做了动态分配，对象死亡前析构函数必须释放分配的动态内存。s1、s2、p这三个字符串都会调用<code>String(const char* str = 0)</code>这个构造函数，离开作用域之后都会调用析构函数；s1和s2离开作用域自动调用析构函数；p是指针，delete释放掉。</p><h1 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h1><p>操作符重载；赋值动作，且参数为自己类型。</p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p><img src="/2021/04/05/HJ-C++-OOP-Note-5-Big-Three/bigthree3.png" alt></p><p>classes with point members必须有拷贝构造函数和拷贝赋值操作。以上并不是想要的，希望有相同内容，且操作很危险。首先，b的内存泄露，其次。</p><p>这是<strong>浅拷贝</strong>，执行<code>b=a;</code>后，本来是想把a的字符串值赋给b，但是这样只会让b指向同一块内存（所包含的内容），还会造成这样一个后果，假如改变a，b也会跟着改变，因为它们指向相同的内容。</p><p>此时b叫做a的别名（alias），在编程里面，别名的存在是一件危险的事情。</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p><img src="/2021/04/05/HJ-C++-OOP-Note-5-Big-Three/bigthree4.png" alt></p><p>传进来参数，不会去改动，所以用const修饰参数；<code>String s2(s1)</code>：以s1为蓝本创建s2；分配空间，把内容拷贝过去。</p><h1 id="拷贝赋值函数"><a href="#拷贝赋值函数" class="headerlink" title="拷贝赋值函数"></a>拷贝赋值函数</h1><p><img src="/2021/04/05/HJ-C++-OOP-Note-5-Big-Three/bigthree5.png" alt></p><blockquote><p>左边清空，创建和右边一样大的空间，拷贝。</p><p>第2行里面的&amp;代表对象的引用，第4行里面的&amp;代表取地址。</p></blockquote><h2 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">String s2 = s1;<br></code></pre></td></tr></table></figure><p>首先检测自我赋值（有可能看起来不像，但是确实是，例如指针名称变动），如果没有检测，会出现不好的结果。</p><p>检测：首先对象自己s2是会有this pointer传进来的，str是右边s1传进来内容；看是否相等，自己赋值给自己直接return。</p><blockquote><p>不检测自我赋值，不好的结果。</p><p><img src="/2021/04/05/HJ-C++-OOP-Note-5-Big-Three/bad.png" alt></p><p>拷贝赋值操作语句：<code>a=b;</code>如果指针a和b本来就指向同一块内存空间，杀掉a之后，相当于把b指向的内容也杀掉了，所以没办法做第2步了。</p></blockquote><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p><img src="/2021/04/05/HJ-C++-OOP-Note-5-Big-Three/bigthree6.png" alt></p><p>杀掉自己（右边内容）；开辟和赋值过来的对象一样大小的空间；字符串复制（到左边）。</p>]]></content>
    
    
    <categories>
      
      <category>Course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HJ C++ OOP Note 4 Operator Overloading</title>
    <link href="/2021/04/04/HJ-C++-OOP-Note-4-Operator-Overloading/"/>
    <url>/2021/04/04/HJ-C++-OOP-Note-4-Operator-Overloading/</url>
    
    <content type="html"><![CDATA[<h1 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h1><blockquote><p>可以重载为成员函数或者是非成员函数。</p></blockquote><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><p>在C++里面，操作符是一种函数，这是C++的一大特点。</p><p><img src="/2021/04/04/HJ-C++-OOP-Note-4-Operator-Overloading/operator1.png" alt></p><blockquote><p>操作符重载的原因：因为函数库中没有两个复数直接相加的函数，只有实数和实数相加的函数。</p></blockquote><p>对于成员函数+=：c2调用了+=（+=作用在c2身上），c2需要写出函数来进行正确调用；c2就是this，或者说this此时就指向了c2（this是一个指针），c2的地址传入了this。</p><blockquote><p>任何函数都隐藏this参数。</p><p>_doapl：再次调用 _dopal；也许是其他地方也要使用，所以写成单独的方法。</p></blockquote><h2 id="非成员函数"><a href="#非成员函数" class="headerlink" title="非成员函数"></a>非成员函数</h2><blockquote><p>无隐含参数this（指针）。</p><p><strong>类外区域</strong>，主要有成员函数、全局函数。</p><p><img src="/2021/04/04/HJ-C++-OOP-Note-4-Operator-Overloading/outclassbody.png" alt></p><blockquote><p>两个全局函数（没有class的名称），目的是取得复数的实部、虚部。</p></blockquote></blockquote><p>为了应付用户的3种可能用法，需要在类区域（class body）外写3个对应的处理加法的函数；以下123仅用作标识。</p><p><img src="/2021/04/04/HJ-C++-OOP-Note-4-Operator-Overloading/operator2.png" alt></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="尽量return-by-reference"><a href="#尽量return-by-reference" class="headerlink" title="尽量return by reference"></a>尽量return by reference</h2><p>写一个函数一般考量两个点，这两点影响着程序执行的效率：参数传递要不要by reference；返回值传递要不要by reference。</p><p>如果return by reference，传递者无需知道接收端是以by reference还是by value的形式接受object。</p><p><img src="/2021/04/04/HJ-C++-OOP-Note-4-Operator-Overloading/return.png" alt></p><p>返回<code>*ths</code>（也就是一个object、返回值），接收用complex&amp;接收；但是其实<code>*ths</code>处不需要管接收用什么接收。</p><blockquote><p>当然还是引用接收好，快。</p></blockquote><h2 id="返回值是写void还是写一个具体类型"><a href="#返回值是写void还是写一个具体类型" class="headerlink" title="返回值是写void还是写一个具体类型"></a>返回值是写void还是写一个具体类型</h2><p><img src="/2021/04/04/HJ-C++-OOP-Note-4-Operator-Overloading/returnwhat.png" alt></p><p>返回值是写void还是写一个具体类型；如果使用者只是这样调用+=这个重载函数：c2+=c1，那么返回类型complex&amp;写成void是没有问题的。</p><p>但如果这样调用：c3+=c2+=c1，返回void类型的话，就有问题了；希望c1先加到c2上，再将上述操作的返回值加到c3上。</p><h1 id="临时对象"><a href="#临时对象" class="headerlink" title="临时对象"></a>临时对象</h1><blockquote><p>temp object。</p></blockquote><p><img src="/2021/04/04/HJ-C++-OOP-Note-4-Operator-Overloading/temp.png" alt></p><p>这些函数绝对不可以return by reference，因为，它们返回的必定是个local object，出去就不存在了，所以一定要return by value。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// （类名后面+小括号）</span><br><span class="hljs-built_in">typename</span>();<br></code></pre></td></tr></table></figure><p>这是一个特殊语法，是创建临时对象的特殊语法。举例，函数体中的complex()就是在创建临时对象，临时对象的生命周期就是这创建的那一行，到下一行生命就结束了。</p><p><img src="/2021/04/04/HJ-C++-OOP-Note-4-Operator-Overloading/operator3.png" alt></p><blockquote><p>第一个正号操作，返回的是原来的东西，没有产生新的东西（新的local object，而下面代码中取反的操作产生了新的东西），那完全可以retrun by reference啊，这个是标准库里面的东西，那么厉害的人会注意不到这一点吗？有可能。这里其实可以retrun by reference。complex后面可以加个&amp;。（错误观点！）</p></blockquote><p>因为传入的参数是const类型的引用，如果将返回值改成引用，相当于将const类型转换为非const类型，这在编译上是通不过的。</p><h1 id="输出操作符重载"><a href="#输出操作符重载" class="headerlink" title="输出操作符重载"></a>输出操作符重载</h1><blockquote><p>单独拿出来，举例。</p></blockquote><p><img src="/2021/04/04/HJ-C++-OOP-Note-4-Operator-Overloading/output.png" alt></p><blockquote><p>运算符永远是作用在左边的对象上，没有作用在右边上的。</p></blockquote><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>参数传递，均是pass by reference；x没有改变，const，但是os传进来需要改变，每一次输出都在改变状态，不可以const；“&lt;&lt;”是双目运算符，需要提供2个参数。</p><h2 id="返回值传递"><a href="#返回值传递" class="headerlink" title="返回值传递"></a>返回值传递</h2><p>返回值传递，return by reference；如果不是连续输出，函数的返回值类型可以设计成void，如果使用连续输出，函数的返回值类型不能是void类型；返回类型前不可以加”const”，因为连续输出的时候被丢到屏幕上的东西一直在变，即每有一个新的输出变量“os”的状态就会发生变化（也是由于这个原因，ostream&amp; os的前面不可以加const修饰符），相当于一个变量的值一直在发生变化。</p><h2 id="成员函数-1"><a href="#成员函数-1" class="headerlink" title="成员函数"></a>成员函数</h2><p>&lt;&lt;不可以写成成员函数，操作符重载一定左边上，正常使用习惯是&lt;&lt;作用到左边的cout身上；如果写成成员函数，<code>c1 &lt;&lt; cout;</code>，不符合使用习惯。</p><blockquote><p>任何一个操作都可以设置为成员函数或者全局函数；看情况。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HJ C++ OOP Note 3 Reference</title>
    <link href="/2021/04/03/HJ-C++-OOP-Note-3-Reference/"/>
    <url>/2021/04/03/HJ-C++-OOP-Note-3-Reference/</url>
    
    <content type="html"><![CDATA[<h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><h2 id="参数传递-1"><a href="#参数传递-1" class="headerlink" title="参数传递"></a>参数传递</h2><blockquote><p>pass by value vs. pass by reference（to const）</p></blockquote><p><img src="/2021/04/03/HJ-C++-OOP-Note-3-Reference/pass.png" alt></p><p>pass by value，压到函数的栈中（整包传过去），尽量不要，字节数（可能比较大）不定；pass by reference，C可以传指针，C++传reference（引用在底层就是指针）。</p><blockquote><p>引用，方法内改变则会影响原值，如果只是为了传输的速度，不希望进行改变，就用pass by reference to const。</p><p>一般来说，基础数据类型传值，自定义类型传引用。</p></blockquote><h2 id="返回值传递"><a href="#返回值传递" class="headerlink" title="返回值传递"></a>返回值传递</h2><blockquote><p>pass by value or pass by reference(to const)</p></blockquote><p><img src="/2021/04/03/HJ-C++-OOP-Note-3-Reference/returnby.png" alt></p><p>同上，考虑到效率，pass by reference。</p><h2 id="不能返回局部变量的引用"><a href="#不能返回局部变量的引用" class="headerlink" title="不能返回局部变量的引用"></a>不能返回局部变量的引用</h2><p>函数之间在进行参数传递和值传递的时候，都是要尽量传递引用；但是有一种情况不能传递引用，这就是值被赋给一个函数内的临时变量的时候，因为临时变量的生命周期只在函数内，不在函数外。</p><p>举例，ths本来就在，是非临时变量，所以可以传引用。</p><p><img src="/2021/04/03/HJ-C++-OOP-Note-3-Reference/cannot.png" alt></p><h1 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h1><p>声明后，可以自由取得该声明所在类的私有变量。</p><p><img src="/2021/04/03/HJ-C++-OOP-Note-3-Reference/friend1.png" alt></p><p><img src="/2021/04/03/HJ-C++-OOP-Note-3-Reference/friend2.png" alt></p>]]></content>
    
    
    <categories>
      
      <category>Course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HJ C++ OOP Note 2 Ctor</title>
    <link href="/2021/04/02/HJ-C++-OOP-Note-2-Ctor/"/>
    <url>/2021/04/02/HJ-C++-OOP-Note-2-Ctor/</url>
    
    <content type="html"><![CDATA[<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>C++在利用类名创建一个对象的时候，有一个函数会被自动调用，这个函数就是构造函数。</p><p>构造函数的特点：</p><ul><li>没有返回值类型，也不需要有；</li><li>构造函数的函数名必须和类名一致；</li><li>构造函数的参数可以有默认值；</li><li>用创建实例的时候传递进来的参数值去初始化私有变量；只有构造函数才有初始列表，使用初始列表进行数据的初始化比使用赋值进行值的设定的效率更高。</li></ul><p><img src="/2021/04/02/HJ-C++-OOP-Note-2-Ctor/ctor.png" alt></p><blockquote><p>本类中没有指针变量，一般这种没有指针的类多半不需要写析构函数。</p></blockquote><h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><blockquote><p>构造函数可以有很多个。</p></blockquote><p>重载（overloading），创建对象可以多种构造方法。</p><blockquote><p>Q：为什么可以有同名函数？</p><p>编译器编译后的函数名称不同。</p></blockquote><p><img src="/2021/04/02/HJ-C++-OOP-Note-2-Ctor/overloading.png" alt></p><h2 id="构造函数的重载"><a href="#构造函数的重载" class="headerlink" title="构造函数的重载"></a>构造函数的重载</h2><p>在使用类创建对象的时候，有多少个想法就可以创建多少个”<strong>形状不同</strong>“的构造函数，形状不同指的是函数参数个数不同。</p><h2 id="非构造函数的重载"><a href="#非构造函数的重载" class="headerlink" title="非构造函数的重载"></a>非构造函数的重载</h2><p>编译器会把它们编译成名字不同的函数。</p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>构造函数放在private区，不能被外界直接调用的；也就是无法在外界创造对象；单例模式。</p><p><img src="/2021/04/02/HJ-C++-OOP-Note-2-Ctor/singleton1.png" alt></p><p>Singleton单键（外界只可以用一份）；构造函数位于private中；外界不可以创建，外界需要（自己在内部准备了一份），外界需要通过A的getInstance取到该单个对象。</p><p><img src="/2021/04/02/HJ-C++-OOP-Note-2-Ctor/singleton2.png" alt></p><h1 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h1><blockquote><p>const member functions。</p></blockquote><p><img src="/2021/04/02/HJ-C++-OOP-Note-2-Ctor/const.png" alt></p><p>const修饰成员函数，要在如上图的位置；修饰不会改变数据内容的函数；const对象一定只能调用const方法。</p><blockquote><p>关于不会改变数据内容的函数加const的解释，上面这两个函数只是把函数的实部和虚部拿出来，并不是写，不写就不会改变私有数据，所以可以定义成常量成员函数。</p></blockquote><h2 id="const函数"><a href="#const函数" class="headerlink" title="const函数"></a>const函数</h2><p>所谓常量成员函数就是不改变私有数据的成员函数，表面上看的话就是函数名和作用域之间加上const修饰符的函数，加const就意味着不打算改变私有数据。</p><p>换而言之，不改变私有数据就一定要加上const；能加就加，因为不加的话可能会产生不希望的后果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">const</span> complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>举例，这里const表示创建复数对象的时候，数据不可以被改变；但是假如调用函数real()的时候，real()函数前面没有加const，就会产生矛盾，因为没有用const修饰的函数意味着进来的数据有可能被改变。</p><h2 id="const成员"><a href="#const成员" class="headerlink" title="const成员"></a>const成员</h2><p>const修饰成员函数其实修饰的是隐式参数this指针，因此（由对象产生的）传入参数需要和this指针匹配，即const对象所调用的方法传入的是const对象指针，而非对象指针。也因此，const对象不可以调用非const成员函数。</p>]]></content>
    
    
    <categories>
      
      <category>Course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HJ C++ OOP Note 1 Header</title>
    <link href="/2021/04/01/HJ-C++-OOP-Note-1-Header/"/>
    <url>/2021/04/01/HJ-C++-OOP-Note-1-Header/</url>
    
    <content type="html"><![CDATA[<h1 id="C-vs-C"><a href="#C-vs-C" class="headerlink" title="C vs. C++"></a>C vs. C++</h1><h2 id="C-vs-C-1"><a href="#C-vs-C-1" class="headerlink" title="C vs. C++"></a>C vs. C++</h2><p>C面向过程而C++面向对象。</p><blockquote><p>C++面向对象的关键：类的引入；类的封装性、继承性、多态性简化了程序编写，提到了代码重用率。</p></blockquote><p>C的目的：比汇编方便易用，同时不要损失汇编的表达能力；因此简单容易编译，灵活贴近底层。</p><p>C++的目的：提高编程人员的生产率，哪怕代价是增加编译器的复杂度；提高编程人员生产率的方法有如下几种：提高抽象层次、支持模块化编程、自动化代码生成。</p><blockquote><p>C++不仅仅是面向对象，其目的也在于支持泛型编程。</p></blockquote><h2 id="Object-Oriented"><a href="#Object-Oriented" class="headerlink" title="Object Oriented"></a>Object Oriented</h2><p>Object Based：面对的是单一的class的设计；Object Oriented：面对的是多重classes的设计，classes和classes之间的关系。</p><p>Classes的两个经典分类：Class without pointer members、Class with pointer member。</p><p><img src="/2021/04/01/HJ-C++-OOP-Note-1-Header/classes.png" alt></p><blockquote><p>String数据内部只有一个指针，采用动态分配内存，该指针就指向动态分配的内存。</p></blockquote><h2 id="C-programs"><a href="#C-programs" class="headerlink" title="C++ programs"></a>C++ programs</h2><p><img src="/2021/04/01/HJ-C++-OOP-Note-1-Header/programs.png" alt></p><blockquote><p>延伸文件名不一定是.h或.cpp，也可能是.hpp（头文件和主程序放在一个文件中实现）。</p></blockquote><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>向左cout“丢”（&lt;&lt;）即可</p><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><h2 id="防范式声明"><a href="#防范式声明" class="headerlink" title="防范式声明"></a>防范式声明</h2><p>防止此头文件被重复包含。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _COMPLEX_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _COMPLEX_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="Header布局"><a href="#Header布局" class="headerlink" title="Header布局"></a>Header布局</h2><p><img src="/2021/04/01/HJ-C++-OOP-Note-1-Header/headerlayout.png" alt></p><h1 id="后续内容"><a href="#后续内容" class="headerlink" title="后续内容"></a>后续内容</h1><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>如果把私有数据的类型写死了，定义示例的时候，数据类型受到限制。所以需要写一个模板类（含模板的类）。T写成什么都可以。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span>(T r = <span class="hljs-number">0</span>, T i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span>(r), <span class="hljs-built_in">im</span>(i)<br>    &#123;<br>    &#125;<br>    complex &amp;<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> complex &amp;);<br>    <span class="hljs-function">T <span class="hljs-title">real</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125;<br>    <span class="hljs-function">T <span class="hljs-title">imag</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    T re, im;<br><br>    <span class="hljs-keyword">friend</span> complex &amp;__doapl(complex *, <span class="hljs-type">const</span> complex &amp;);<br>&#125;;<br><br>&#123;<br>    <span class="hljs-function">complex&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2.5</span>, <span class="hljs-number">1.5</span>)</span></span>;<br>    <span class="hljs-function">complex&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>)</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><blockquote><p>使用时绑定类型。</p></blockquote><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-type">double</span> i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span>(r), <span class="hljs-built_in">im</span>(i) &#123;&#125;<br>    complex &amp;<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> complex &amp;);<br>    complex &amp;<span class="hljs-keyword">operator</span>-=(<span class="hljs-type">const</span> complex &amp;);<br>    complex &amp;<span class="hljs-keyword">operator</span>*=(<span class="hljs-type">const</span> complex &amp;);<br>    complex &amp;<span class="hljs-keyword">operator</span>/=(<span class="hljs-type">const</span> complex &amp;);<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">real</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">imag</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> re, im;<br><br>    <span class="hljs-keyword">friend</span> complex &amp;__doapl(complex *, <span class="hljs-type">const</span> complex &amp;);<br>    <span class="hljs-keyword">friend</span> complex &amp;__doami(complex *, <span class="hljs-type">const</span> complex &amp;);<br>    <span class="hljs-keyword">friend</span> complex &amp;__doaml(complex *, <span class="hljs-type">const</span> complex &amp;);<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">imag</span><span class="hljs-params">(<span class="hljs-type">const</span> complex &amp;x)</span> </span>&#123; <span class="hljs-keyword">return</span> x.<span class="hljs-built_in">imag</span>(); &#125;<br></code></pre></td></tr></table></figure><p><strong>inline</strong>；快（但是最后是否inline由编译器决定）；复杂时还是需要定义在外部。</p><p>函数在class body内完成，自动称为inline候选人。</p><h2 id="访问级别"><a href="#访问级别" class="headerlink" title="访问级别"></a>访问级别</h2><p>数据部分一般private；如果函数是要被外界调用的就放在public，若不打算被外界调用则放在private。即分为public给外界使用、private处理内部数据。</p><blockquote><p>尽量使外界通过方法“拿”数据，而不是直接访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// bad</span><br>cout &lt;&lt; c1.re;<br>cout &lt;&lt; c1.im;<br><span class="hljs-comment">// good</span><br>cout &lt;&lt; c1.<span class="hljs-built_in">real</span>();<br>cout &lt;&lt; c1.<span class="hljs-built_in">imag</span>();<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>Course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HUST Data Structures Homework 2 Majority Element</title>
    <link href="/2020/09/15/HUST-Data-Structures-Homework-2-Majority-Element/"/>
    <url>/2020/09/15/HUST-Data-Structures-Homework-2-Majority-Element/</url>
    
    <content type="html"><![CDATA[<h1 id="快速求幂"><a href="#快速求幂" class="headerlink" title="快速求幂"></a>快速求幂</h1><p>要求，以2为底和以2为底的算法分别求幂；分析两种算法的复杂程度。</p><h2 id="以2为底"><a href="#以2为底" class="headerlink" title="以2为底"></a>以2为底</h2><p>以2为底，缓存中间结果；<code>x^4=x^2*x^2</code>；<code>x^8=x^4*x^4</code>；递归；每经过一次递归调用，问题规模减半。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><h1 id="求主元"><a href="#求主元" class="headerlink" title="求主元"></a>求主元</h1>]]></content>
    
    
    <categories>
      
      <category>Course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HUST Data Structures Homework 1 Time Complexity</title>
    <link href="/2020/09/01/HUST-Data-Structures-Homework-1-Time-Complexity/"/>
    <url>/2020/09/01/HUST-Data-Structures-Homework-1-Time-Complexity/</url>
    
    <content type="html"><![CDATA[<h1 id="求整数和"><a href="#求整数和" class="headerlink" title="求整数和"></a>求整数和</h1><p>利用递归来计算n项和的值；测试数据，100~1000，相隔100；clock_t得到时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span> t)</span> &#123;<br>    <span class="hljs-comment">// N-1-&gt;N</span><br>    <span class="hljs-comment">// 从1开始</span><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (t &gt; <span class="hljs-number">1</span>) &#123;<br>        res = t + func(t - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span> sign = <span class="hljs-number">1</span>;  <br>    <span class="hljs-keyword">while</span> (sign != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;sign);<br>        <span class="hljs-type">clock_t</span> start, end;<br>        start = clock();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) &#123;<br>            <span class="hljs-comment">// 不要输出，影响时间复杂度</span><br>            func(n);<br>        &#125;<br>        end = clock();<br>        <span class="hljs-type">double</span> duration = (<span class="hljs-type">double</span>)(end - start) / CLOCKS_PER_SEC;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f&quot;</span>, duration);<br>    &#125;<br>    system(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>O(T) = R * O(s)；调用次数为N，递归函数单词时间复杂度为O(1)；O(N)和最后结果相符。</p><p><img src="/2020/09/01/HUST-Data-Structures-Homework-1-Time-Complexity/ex1_2.jpg" alt></p><p><img src="/2020/09/01/HUST-Data-Structures-Homework-1-Time-Complexity/ex1.png" alt></p><h1 id="Pizza"><a href="#Pizza" class="headerlink" title="Pizza"></a>Pizza</h1><p>迭代的方式来计算切n刀后的最多的pizza块数；测试数据，100~1000，相隔100；clock_t得到时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span> sign = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (sign != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;sign);<br>        <span class="hljs-type">clock_t</span> start, end;<br>        start = clock();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) &#123;<br>            <span class="hljs-comment">// 不要输出，影响时间复杂度</span><br>            <span class="hljs-comment">// 1+1+2+3+...+n</span><br>            <span class="hljs-type">int</span> t = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>                t += i;<br>            &#125;<br>        &#125;<br>        end = clock();<br>        <span class="hljs-type">double</span> duration = (<span class="hljs-type">double</span>)(end - start) / CLOCKS_PER_SEC;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f&quot;</span>, duration);<br>    &#125;<br>    system(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>迭代直接看函数体，毫无疑问O(N)。</p><p><img src="/2020/09/01/HUST-Data-Structures-Homework-1-Time-Complexity/ex2_2.jpg" alt></p><p><img src="/2020/09/01/HUST-Data-Structures-Homework-1-Time-Complexity/ex2.png" alt></p><h1 id="Hanoi"><a href="#Hanoi" class="headerlink" title="Hanoi"></a>Hanoi</h1><p>借助一个中转柱，使起始柱中按照规则排放的盘子移动到终点柱，且一次只能移动一个盘，且不允许大盘放在小盘上面。</p><p><img src="/2020/09/01/HUST-Data-Structures-Homework-1-Time-Complexity/ex3idea.png" alt></p><p>n层问题总可以转换为，n-1层盘子借助中转盘（不一定是B）移动至相邻空盘上，将第n个盘子移动至目标盘，进行n-1层问题。经典递归思想。</p><p>函数定义，HanoiTower(int n, char source, char temp, char target)；测试数据为大小为8至16的n；要求对结果做log2，绘制图表。</p><p>验证算法正确性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(<span class="hljs-type">char</span> a, <span class="hljs-type">char</span> b)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c---&gt;%c\n&quot;</span>, a, b);<br>    count++;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @a source</span><br><span class="hljs-comment"> * @b temp</span><br><span class="hljs-comment"> * @c target</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">HanoiTower</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> a, <span class="hljs-type">char</span> b, <span class="hljs-type">char</span> c)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == n) &#123;<br>        move(a, c);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        HanoiTower(n - <span class="hljs-number">1</span>, a, c, b);<br>        move(a, c);<br>        HanoiTower(n - <span class="hljs-number">1</span>, b, a, c);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span> sign = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-type">char</span> a = <span class="hljs-string">&#x27;A&#x27;</span>;<br>    <span class="hljs-type">char</span> b = <span class="hljs-string">&#x27;B&#x27;</span>;<br>    <span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;C&#x27;</span>;<br><br>    HanoiTower(<span class="hljs-number">3</span>, a, b, c);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, count);<br>    system(<span class="hljs-string">&quot;pause&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2020/09/01/HUST-Data-Structures-Homework-1-Time-Complexity/ex3_2.jpg" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(<span class="hljs-type">char</span> a, <span class="hljs-type">char</span> b)</span> &#123;<br>    <span class="hljs-comment">// printf(&quot;%c---&gt;%c\n&quot;, a, b);</span><br>    count++;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @a source</span><br><span class="hljs-comment"> * @b temp</span><br><span class="hljs-comment"> * @c target</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">HanoiTower</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> a, <span class="hljs-type">char</span> b, <span class="hljs-type">char</span> c)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == n) &#123;<br>        move(a, c);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        HanoiTower(n - <span class="hljs-number">1</span>, a, c, b);<br>        move(a, c);<br>        HanoiTower(n - <span class="hljs-number">1</span>, b, a, c);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span> sign = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (sign != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;sign);<br>        count = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">clock_t</span> start, end;<br>        start = clock();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            HanoiTower(n, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>);<br>        &#125;<br>        end = clock();<br>        <span class="hljs-type">double</span> duration = (<span class="hljs-type">double</span>)(end - start) / CLOCKS_PER_SEC;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f&quot;</span>, duration);<br>    &#125;<br>    system(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2020/09/01/HUST-Data-Structures-Homework-1-Time-Complexity/ex3_3.jpg" alt></p><p><img src="/2020/09/01/HUST-Data-Structures-Homework-1-Time-Complexity/ex3.png" alt></p><p>log2后结果。</p><div class="table-container"><table><thead><tr><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr></thead><tbody><tr><td>-6.15843</td><td>-5.96578</td><td>-4.92139</td><td>-3.87832</td><td>-2.92139</td><td>-1.89432</td><td>-0.92139</td><td>0.070389</td><td>1.01078</td></tr></tbody></table></div><p><img src="/2020/09/01/HUST-Data-Structures-Homework-1-Time-Complexity/ex3log2.png" alt></p><p>时间复杂度，从数学上，$T(n)=2 T(n-1)+1$，则可知：</p><p>$\begin{aligned} T(1) &amp; =2 T(0)+1=2^0+2^0-1 \\ T(2) &amp; =2 T(1)+1=2^1+2^1-1 \\ T(3) &amp; =2 T(2)+1=2^2+2^2-1 \\ \quad \ldots &amp; \\ T(n) &amp; =2 T(n-1)+1=2^{n-1}+2^{n-1}-1=2^n-1\end{aligned}$</p><p>因此，$T(n)=2^n-1=O\left(2^n\right)$；和实验结果相符；从程序上看，每次n层都需要2次n-1操作，必然指数级增长。</p>]]></content>
    
    
    <categories>
      
      <category>Course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Map</title>
    <link href="/2019/07/01/Map/"/>
    <url>/2019/07/01/Map/</url>
    
    <content type="html"><![CDATA[<blockquote><p>模板</p><p><code>&#123;% post_link %&#125;</code></p></blockquote><h1 id="Graphcis"><a href="#Graphcis" class="headerlink" title="Graphcis"></a>Graphcis</h1><h2 id="Rendering"><a href="#Rendering" class="headerlink" title="Rendering"></a>Rendering</h2><ul><li><p>渲染管线</p><ul><li></li></ul></li><li><p>基础光照</p></li><li>基础纹理</li><li>透明效果</li><li>环境交互</li><li>后处理</li><li>全局光照</li><li>具体效果</li><li>优化</li><li>PBR</li><li>光追</li></ul><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h1 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h1>]]></content>
    
    
    <categories>
      
      <category>Map</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
