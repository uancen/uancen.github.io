<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HJ C++ OOP Note 1 Header</title>
    <link href="/2021/04/01/HJ-C++-OOP-Note-1-Header/"/>
    <url>/2021/04/01/HJ-C++-OOP-Note-1-Header/</url>
    
    <content type="html"><![CDATA[<h1 id="C-vs-C"><a href="#C-vs-C" class="headerlink" title="C vs. C++"></a>C vs. C++</h1><h2 id="C-vs-C-1"><a href="#C-vs-C-1" class="headerlink" title="C vs. C++"></a>C vs. C++</h2><p>C面向过程而C++面向对象。</p><blockquote><p>C++面向对象的关键：类的引入；类的封装性、继承性、多态性简化了程序编写，提到了代码重用率。</p></blockquote><p>C的目的：比汇编方便易用，同时不要损失汇编的表达能力；因此简单容易编译，灵活贴近底层。</p><p>C++的目的：提高编程人员的生产率，哪怕代价是增加编译器的复杂度；提高编程人员生产率的方法有如下几种：提高抽象层次、支持模块化编程、自动化代码生成。</p><blockquote><p>C++不仅仅是面向对象，其目的也在于支持泛型编程。</p></blockquote><h2 id="Object-Oriented"><a href="#Object-Oriented" class="headerlink" title="Object Oriented"></a>Object Oriented</h2><p>Object Based：面对的是单一的Class的设计；Object Oriented：面对的是Classes的设计，classes和classes之间的关系。</p><p>Classes的两个经典分类：Class without pointer members、Class with pointer member。</p><p><img src="/2021/04/01/HJ-C++-OOP-Note-1-Header/classes.png" alt></p><blockquote><p>String数据内部只有一个指针，采用动态分配内存，该指针就指向动态分配的内存。</p></blockquote><h2 id="C-programs"><a href="#C-programs" class="headerlink" title="C++ programs"></a>C++ programs</h2><p><img src="/2021/04/01/HJ-C++-OOP-Note-1-Header/programs.png" alt></p><blockquote><p>延伸文件名不一定是.h或.cpp，也可能是.hpp（头文件和主程序放在一个文件中实现）。</p></blockquote><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>向左cout“丢”（&lt;&lt;）即可</p><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><h2 id="防范式声明"><a href="#防范式声明" class="headerlink" title="防范式声明"></a>防范式声明</h2><p>防止此头文件被重复包含。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _COMPLEX_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _COMPLEX_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="Header布局"><a href="#Header布局" class="headerlink" title="Header布局"></a>Header布局</h2><p><img src="/2021/04/01/HJ-C++-OOP-Note-1-Header/headerlayout.png" alt></p><h1 id="后续内容"><a href="#后续内容" class="headerlink" title="后续内容"></a>后续内容</h1><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>如果把私有数据的类型写死了，定义示例的时候，数据类型受到限制。所以需要写一个模板类（含模板的类）。T写成什么都可以。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span>(T r = <span class="hljs-number">0</span>, T i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span>(r), <span class="hljs-built_in">im</span>(i)<br>    &#123;<br>    &#125;<br>    complex &amp;<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> complex &amp;);<br>    <span class="hljs-function">T <span class="hljs-title">real</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125;<br>    <span class="hljs-function">T <span class="hljs-title">imag</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    T re, im;<br><br>    <span class="hljs-keyword">friend</span> complex &amp;__doapl(complex *, <span class="hljs-type">const</span> complex &amp;);<br>&#125;;<br><br>&#123;<br>    <span class="hljs-function">complex&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2.5</span>, <span class="hljs-number">1.5</span>)</span></span>;<br>    <span class="hljs-function">complex&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>)</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><blockquote><p>使用时绑定类型。</p></blockquote><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-type">double</span> i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span>(r), <span class="hljs-built_in">im</span>(i) &#123;&#125;<br>    complex &amp;<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> complex &amp;);<br>    complex &amp;<span class="hljs-keyword">operator</span>-=(<span class="hljs-type">const</span> complex &amp;);<br>    complex &amp;<span class="hljs-keyword">operator</span>*=(<span class="hljs-type">const</span> complex &amp;);<br>    complex &amp;<span class="hljs-keyword">operator</span>/=(<span class="hljs-type">const</span> complex &amp;);<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">real</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">imag</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> re, im;<br><br>    <span class="hljs-keyword">friend</span> complex &amp;__doapl(complex *, <span class="hljs-type">const</span> complex &amp;);<br>    <span class="hljs-keyword">friend</span> complex &amp;__doami(complex *, <span class="hljs-type">const</span> complex &amp;);<br>    <span class="hljs-keyword">friend</span> complex &amp;__doaml(complex *, <span class="hljs-type">const</span> complex &amp;);<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">imag</span><span class="hljs-params">(<span class="hljs-type">const</span> complex &amp;x)</span> </span>&#123; <span class="hljs-keyword">return</span> x.<span class="hljs-built_in">imag</span>(); &#125;<br></code></pre></td></tr></table></figure><p><strong>inline</strong>；快（但是最后是否inline由编译器决定）；复杂时还是需要定义在外部。</p><p>函数在class body内完成，自动称为inline候选人。</p><h2 id="访问级别"><a href="#访问级别" class="headerlink" title="访问级别"></a>访问级别</h2><p>数据部分一般private；如果函数是要被外界调用的就放在public，若不打算被外界调用则放在private。即分为public给外界使用、private处理内部数据。</p><blockquote><p>尽量使外界通过方法“拿”数据，而不是直接访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// bad</span><br>cout &lt;&lt; c1.re;<br>cout &lt;&lt; c1.im;<br><span class="hljs-comment">// good</span><br>cout &lt;&lt; c1.<span class="hljs-built_in">real</span>();<br>cout &lt;&lt; c1.<span class="hljs-built_in">imag</span>();<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
