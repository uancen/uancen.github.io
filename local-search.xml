<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CppSTL 学习笔记（一）STL各组件应用示例</title>
    <link href="/2023/02/25/CppSTL-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89STL%E5%90%84%E7%BB%84%E4%BB%B6%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B/"/>
    <url>/2023/02/25/CppSTL-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89STL%E5%90%84%E7%BB%84%E4%BB%B6%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android插件化 读书笔记（六）代理模式</title>
    <link href="/2023/02/23/Android%E6%8F%92%E4%BB%B6%E5%8C%96-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/23/Android%E6%8F%92%E4%BB%B6%E5%8C%96-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Head First Design Patterns 读书笔记（二）观察者模式</title>
    <link href="/2023/02/23/Head-First-Design-Patterns-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/23/Head-First-Design-Patterns-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>NJU OS 学习笔记（一）绪论</title>
    <link href="/2023/02/22/NJU-OS-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E7%BB%AA%E8%AE%BA/"/>
    <url>/2023/02/22/NJU-OS-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>没有定义！OS==OS的“全部”。</p></blockquote><p>Operating System</p><p>A body of software, in fact, that is responsible for <em>making it easy to run programs</em> (even allowing you to seemingly run many at the same time), allowing programs to share memory, enabling programs to interact with devices, and other fun stuff like that.</p><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>Hardware</p><p>计算机硬件（电路）；公理系统。</p><p>Software</p><p><strong>.c -&gt; .s -&gt; .o -&gt; a.out</strong>（视角一）穿过OS，<strong>计算机执行指令序列（ISA）</strong>（视角二）。</p><p>举例，CPU（RISC-V）模拟器，取出指令并执行；<a href="#鸡兔同笼问题">解决鸡兔同笼问题</a>。</p><p><strong>操作系统，狭义，硬件和软件的中间层（自然管理了软件、硬件资源），支持程序运行。</strong></p><ul><li>程序视角：对象 + API；</li><li>硬件视角：C program。 </li></ul><blockquote><p>分布式系统中，对集群的抽象。</p></blockquote><h1 id="程序视角"><a href="#程序视角" class="headerlink" title="程序视角"></a>程序视角</h1><blockquote><p>操作系统上的程序。</p></blockquote><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="鸡兔同笼问题"><a href="#鸡兔同笼问题" class="headerlink" title="鸡兔同笼问题"></a>鸡兔同笼问题</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">inst_fetch</span><span class="hljs-params">(<span class="hljs-type">inst_t</span> *in)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">union</span><br>    &#123;<br>        <span class="hljs-type">inst_t</span> i;<br>        u32 u;<br>    &#125; u;<br>    <span class="hljs-type">int</span> r = <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%x&quot;</span>, &amp;u.u);<br>    *in = u.i;<br>    <span class="hljs-keyword">return</span> r &gt; <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">ebreak</span><span class="hljs-params">(CPUState *cpu)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">switch</span> (cpu-&gt;x[<span class="hljs-number">10</span>])<br>    &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    &#123;<br>        <span class="hljs-built_in">putchar</span>(cpu-&gt;x[<span class="hljs-number">11</span>]);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, cpu-&gt;x[<span class="hljs-number">11</span>]);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>    &#123;<br>        cpu-&gt;on = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint32_t</span> u32;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    u32 op : <span class="hljs-number">7</span>, rd : <span class="hljs-number">5</span>, f3 : <span class="hljs-number">3</span>, rs1 : <span class="hljs-number">5</span>, rs2 : <span class="hljs-number">5</span>, f7 : <span class="hljs-number">7</span>;<br>&#125; <span class="hljs-type">inst_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    u32 on, x[<span class="hljs-number">32</span>];<br>&#125; CPUState;<br><br><span class="hljs-comment">// Uncore:</span><br><span class="hljs-comment">//   inst_fetch - read an instruction from stdin</span><br><span class="hljs-comment">//   ebreak - hyper call: putchar/putd/exit</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;uncore.c&quot;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> u32 <span class="hljs-title function_">sext</span><span class="hljs-params">(u32 val, u32 n)</span><br>&#123;<br>    <span class="hljs-comment">// Sign extend n-bit integer val to 32-bit</span><br>    u32 mask = ~((<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>);<br>    u32 <span class="hljs-built_in">set</span> = (val &gt;&gt; n) &amp; <span class="hljs-number">1</span>;<br>    u32 ret = <span class="hljs-built_in">set</span> ? (val | mask) : val;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    CPUState cpu = &#123;.on = <span class="hljs-number">1</span>, .x = &#123;<span class="hljs-number">0</span>&#125;&#125;; <span class="hljs-comment">// The RESET state</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; argv[i + <span class="hljs-number">1</span>] &amp;&amp; i &lt; <span class="hljs-number">8</span>; i++)<br>    &#123;<br>        cpu.x[<span class="hljs-number">10</span> + i] = atoi(argv[i + <span class="hljs-number">1</span>]); <span class="hljs-comment">// Set a0-a7 to arguments</span><br>    &#125;<br><br>    <span class="hljs-type">inst_t</span> in;<br>    <span class="hljs-comment">// 逐一取出指令并执行</span><br>    <span class="hljs-keyword">while</span> (cpu.on &amp;&amp; inst_fetch(&amp;in))<br>    &#123;<br>        <span class="hljs-comment">// For each fetched instruction, execute it following the RV32I spec</span><br>        u32 op = in.op, f3 = in.f3, f7 = in.f7;<br>        u32 imm = sext((f7 &lt;&lt; <span class="hljs-number">5</span>) | in.rs2, <span class="hljs-number">12</span>), shamt = in.rs2;<br>        u32 rd = in.rd, rs1_u = cpu.x[in.rs1], rs2_u = cpu.x[in.rs2], res = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 只需要六条指令，就可以实现鸡兔同笼问题的解法</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __ <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-comment">// Bad syntactic sugar!</span></span><br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">0b0110011</span> &amp;&amp; f3 == <span class="hljs-number">0b000</span> &amp;&amp; f7 == <span class="hljs-number">0b0000000</span>)<br>            res = rs1_u + rs2_u;<br>        __(op == <span class="hljs-number">0b0110011</span> &amp;&amp; f3 == <span class="hljs-number">0b000</span> &amp;&amp; f7 == <span class="hljs-number">0b0100000</span>)<br>        res = rs1_u - rs2_u;<br>        __(op == <span class="hljs-number">0b0010011</span> &amp;&amp; f3 == <span class="hljs-number">0b000</span>)<br>        res = rs1_u + imm;<br>        __(op == <span class="hljs-number">0b0010011</span> &amp;&amp; f3 == <span class="hljs-number">0b001</span> &amp;&amp; f7 == <span class="hljs-number">0b0000000</span>)<br>        res = rs1_u &lt;&lt; shamt;<br>        __(op == <span class="hljs-number">0b0010011</span> &amp;&amp; f3 == <span class="hljs-number">0b101</span> &amp;&amp; f7 == <span class="hljs-number">0b0000000</span>)<br>        res = rs1_u &gt;&gt; shamt;<br>        __(op == <span class="hljs-number">0b1110011</span> &amp;&amp; f3 == <span class="hljs-number">0b000</span> &amp;&amp; rd == <span class="hljs-number">0</span> &amp;&amp; imm == <span class="hljs-number">1</span>)<br>        ebreak(&amp;cpu);<br>        <span class="hljs-keyword">else</span> assert(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (rd)<br>            cpu.x[rd] = res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>make run；生成机器指令。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android插件化 读书笔记（五）跨进程通信</title>
    <link href="/2023/02/21/Android%E6%8F%92%E4%BB%B6%E5%8C%96-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <url>/2023/02/21/Android%E6%8F%92%E4%BB%B6%E5%8C%96-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h1><blockquote><p>仅仅需要了解架构模型，Client、Server、ServiceManager。</p><p>四大组件底层都是基于Binder的。</p></blockquote><p>IPC；解决跨进程通信；Binder分为Client和Server两个进程，相对。</p><h2 id="Binder组成"><a href="#Binder组成" class="headerlink" title="Binder组成"></a>Binder组成</h2><p><img src="/2023/02/21/Android%E6%8F%92%E4%BB%B6%E5%8C%96-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/Binder_1.png" alt></p><blockquote><p>SM负责把Binder Server注册到一个容器中。</p></blockquote><h2 id="Binder通信流程"><a href="#Binder通信流程" class="headerlink" title="Binder通信流程"></a>Binder通信流程</h2><p><img src="/2023/02/21/Android%E6%8F%92%E4%BB%B6%E5%8C%96-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/Binder_2.png" alt></p><ul><li>Server在SM中注册；</li><li>Client需要调动Server的add方法，需要获取Server对象，<strong>SM把Server的一个Proxy返回给Client</strong>；</li><li>Client调用Proxy的方法，SM帮助调用Server的对应方法，并把结果返回。</li></ul><blockquote><p>主要由Binder驱动完成。</p></blockquote><h1 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h1><p>Android接口定义语言（Android interface definition Language），发布以及调用远程服务，实现<strong>跨进程通信</strong>。</p><h2 id="AIDLDemo"><a href="#AIDLDemo" class="headerlink" title="AIDLDemo"></a>AIDLDemo</h2><blockquote><p>Ctrl+F9，自动生成aidl代码，build -&gt; generated找。</p></blockquote><p>Service中MyService实现逻辑。onBind一定返回Mybinder，使得Client可以使用MyBinder的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TAG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;---MyService---&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">MyService</span><span class="hljs-params">()</span> &#123;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> IBinder <span class="hljs-title function_">onBind</span><span class="hljs-params">(Intent intent)</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Return the communication channel to the service.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mybinder</span>();<br>&#125;<br><br><span class="hljs-comment">// Stub；Alt+Enter自动实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mybinder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IMyAidlInterface</span>.Stub&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getStringFromService</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;Service was called by Client&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;777&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Client也需要新建aidl，但是不能新建aidl，会生成Client的p；Service p和Client p需要一致，Client new AIDL Folder即可，在其中new和Service的p一致的p。</p><p><img src="/2023/02/21/Android%E6%8F%92%E4%BB%B6%E5%8C%96-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/AIDLDemo_1.png" alt></p><p>Client也需要先编译aidl；Client connection；必须显示Intent，Action、Package和Service保持一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">IMyAidlInterface</span> <span class="hljs-variable">myAidlInterface</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">TextView</span> <span class="hljs-variable">txt</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br><br>        txt = findViewById(R.id.txt);<br><br>        <span class="hljs-type">ServiceConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceConnection</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onServiceConnected</span><span class="hljs-params">(ComponentName componentName, IBinder iBinder)</span> &#123;<br>                myAidlInterface = IMyAidlInterface.Stub.asInterface(iBinder);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> myAidlInterface.getStringFromService();<br>                    txt.setText(s);<br>                &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onServiceDisconnected</span><span class="hljs-params">(ComponentName componentName)</span> &#123;<br><br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();<br>        intent.setAction(<span class="hljs-string">&quot;com.example.service.action&quot;</span>);<br>        intent.setPackage(<span class="hljs-string">&quot;com.example.aidlservice&quot;</span>);<br>        bindService(intent,connection,BIND_AUTO_CREATE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>安卓高版本权限缩进，需要使Client有权限进行访问。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.QUERY_ALL_PACKAGES&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">tools:ignore</span>=<span class="hljs-string">&quot;QueryAllPackagesPermission&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">queries</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.example.aidlservice&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">queries</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="AIDL类"><a href="#AIDL类" class="headerlink" title="AIDL类"></a>AIDL类</h2><blockquote><p>AIDL需要了解以下类，IBinder、IInterface、Binder、Proxy、Stub。</p></blockquote><h2 id="AIDL工作流程"><a href="#AIDL工作流程" class="headerlink" title="AIDL工作流程"></a>AIDL工作流程</h2><p>自定义aidl文件（.aidl），AS生成的类文件（.java）类图。</p><p><img src="/2023/02/21/Android%E6%8F%92%E4%BB%B6%E5%8C%96-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/AIDLClass.png" alt></p><p>一个接口，两个类；放在一个AIDL文件中；当有多个AIDL类的时候，Stub和Proxy类就会重名，因此放在不同AIDL接口中。</p><p><img src="/2023/02/21/Android%E6%8F%92%E4%BB%B6%E5%8C%96-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/AIDLClass_2.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">myAidlInterface = IMyAidlInterface.Stub.asInterface(iBinder);<br></code></pre></td></tr></table></figure><p>Stub的sum方法调用到Proxy的sum方法，进而调用另一个进程的sum方法。<strong>起决定作用的是Stub的asInterface方法和onTransact方法。</strong></p><h3 id="Client角度"><a href="#Client角度" class="headerlink" title="Client角度"></a>Client角度</h3><p>对于AIDL的使用者，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">myAidlInterface = IMyAidlInterface.Stub.asInterface(iBinder);<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> myAidlInterface.getStringFromService();<br></code></pre></td></tr></table></figure><p>asInterface方法的作用是判断参数，也就是IBinder对象，和自己是否在同一个进程；是，则直接使用；否，则把这个IBinder参数包装成一个Proxy对象，这时调用Stub的sum方法，间接调用Proxy的sum方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.example.aidlservice.IMyAidlInterface <span class="hljs-title function_">asInterface</span><span class="hljs-params">(android.os.IBinder obj)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> ((obj==<span class="hljs-literal">null</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    android.os.<span class="hljs-type">IInterface</span> <span class="hljs-variable">iin</span> <span class="hljs-operator">=</span> obj.queryLocalInterface(DESCRIPTOR);<br>    <span class="hljs-keyword">if</span> (((iin!=<span class="hljs-literal">null</span>)&amp;&amp;(iin <span class="hljs-keyword">instanceof</span> com.example.aidlservice.IMyAidlInterface))) &#123;<br>        <span class="hljs-keyword">return</span> ((com.example.aidlservice.IMyAidlInterface)iin);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">com</span>.example.aidlservice.IMyAidlInterface.Stub.Proxy(obj);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Proxy角度"><a href="#Proxy角度" class="headerlink" title="Proxy角度"></a>Proxy角度</h3><p>Proxy在自己的sum方法中，会使用Parcelable来准备数据，把函数名称、函数参数都写入<code>_data</code>，让<code>_reply</code>接收函数返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> java.lang.String <span class="hljs-title function_">getStringFromService</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> android.os.RemoteException<br>&#123;<br>    android.os.<span class="hljs-type">Parcel</span> <span class="hljs-variable">_data</span> <span class="hljs-operator">=</span> android.os.Parcel.obtain();<br>    android.os.<span class="hljs-type">Parcel</span> <span class="hljs-variable">_reply</span> <span class="hljs-operator">=</span> android.os.Parcel.obtain();<br>    java.lang.String _result;<br>    <span class="hljs-keyword">try</span> &#123;<br>        _data.writeInterfaceToken(DESCRIPTOR);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">_status</span> <span class="hljs-operator">=</span> mRemote.transact(Stub.TRANSACTION_getStringFromService, _data, _reply, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> getDefaultImpl().getStringFromService();<br>        &#125;<br>        _reply.readException();<br>        _result = _reply.readString();<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        _reply.recycle();<br>        _data.recycle();<br>    &#125;<br>    <span class="hljs-keyword">return</span> _result;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">boolean <span class="hljs-variable">_status</span> = mRemote.transact(Stub.TRANSACTION_getStringFromService, <span class="hljs-variable">_data</span>, <span class="hljs-variable">_reply</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="Server角度"><a href="#Server角度" class="headerlink" title="Server角度"></a>Server角度</h3><p>通过onTransact方法接收Client进程传过来的数据，包括函数名称、函数参数，找到对应的函数（这里是sum），把参数喂进去，得到结果，返回。经典的读数据 —&gt; 逻辑 —&gt; 写数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onTransact</span><span class="hljs-params">(<span class="hljs-type">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="hljs-type">int</span> flags)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException<br>&#123;<br>    java.lang.<span class="hljs-type">String</span> <span class="hljs-variable">descriptor</span> <span class="hljs-operator">=</span> DESCRIPTOR;<br>    <span class="hljs-keyword">switch</span> (code)<br>    &#123;<br>        <span class="hljs-keyword">case</span> INTERFACE_TRANSACTION:<br>            &#123;<br>                reply.writeString(descriptor);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        <span class="hljs-keyword">case</span> TRANSACTION_getStringFromService:<br>            &#123;<br>                data.enforceInterface(descriptor);<br>                java.lang.<span class="hljs-type">String</span> <span class="hljs-variable">_result</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getStringFromService();<br>                reply.writeNoException();<br>                reply.writeString(_result);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        <span class="hljs-keyword">default</span>:<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.onTransact(code, data, reply, flags);<br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>四大组件的启动和后续流程，都是在与AMS通信，基于Binder。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Plug-in</tag>
      
      <tag>Java</tag>
      
      <tag>IPC</tag>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android插件化 读书笔记（四）Activity工作原理</title>
    <link href="/2023/02/21/Android%E6%8F%92%E4%BB%B6%E5%8C%96-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89Activity%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <url>/2023/02/21/Android%E6%8F%92%E4%BB%B6%E5%8C%96-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89Activity%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="AMS"><a href="#AMS" class="headerlink" title="AMS"></a>AMS</h1><p>管理Activity，作为Binder模型中的Server。</p><blockquote><p>Q：App的安装过程，为什么不直接把Apk解压缩到本地。</p><p>待解答。</p><p>Q：为什么Hook永远是在Binder Client端，也就是四大组件这边，而不是在AMS边进行Hook。</p><p>AMS要负责和所有App的四大组件进行通信，Hook易导致功能停止。</p><p>而在Client端做Hook，只影响Hook代码所在的App。</p></blockquote><h1 id="App启动"><a href="#App启动" class="headerlink" title="App启动"></a>App启动</h1><blockquote><p>Activity工作原理。</p></blockquote><h2 id="App启动简述"><a href="#App启动简述" class="headerlink" title="App启动简述"></a>App启动简述</h2><p>Launcher，为每个App的图标提供了启动这个App所需要的Intent信息。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">action：android<span class="hljs-selector-class">.intent</span><span class="hljs-selector-class">.action</span><span class="hljs-selector-class">.MAIN</span><br>category: android<span class="hljs-selector-class">.intent</span><span class="hljs-selector-class">.category</span><span class="hljs-selector-class">.LAUNCHER</span><br>cmp: 包名 + 首页Activity名<br></code></pre></td></tr></table></figure><blockquote><p>对应到AndvoidManifest文件中定义为首页的Activity的<code>&lt;intent-filter&gt;</code>。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sqf">&lt;<span class="hljs-built_in">action</span> android:<span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;android.intent.action.MAIN&quot;</span> /&gt;<br>&lt;category android:<span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;<br></code></pre></td></tr></table></figure></blockquote><p>这些信息是App安装（或Android系统启动）的时候，PackageManagerService（PMS）从Apk包的AndroidManifest文件中读取到的。</p><p>Launcher和App位于不同的进程，其通信通过Binder完成。强调通信过程后，由更详细的过程，以下分步骤。</p><h2 id="Launcher通知AMS"><a href="#Launcher通知AMS" class="headerlink" title="Launcher通知AMS"></a>Launcher通知AMS</h2><h3 id="点击图标"><a href="#点击图标" class="headerlink" title="点击图标"></a>点击图标</h3><p>点击<strong>App快捷图标</strong>，会调用Launcher的startActivitySafely方法，其实还是会调用startActivity方法，intent需要带着启动该App所需要的关键信息（该信息在App安装过程中，”记录“在Launcher的该App的快捷图标中）。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sqf">&lt;<span class="hljs-built_in">action</span> android:<span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;android.intent.action.MAIN&quot;</span> /&gt;<br>&lt;category android:<span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;<br>cmp：该App包名 + 首页Activity名<br></code></pre></td></tr></table></figure><p>而该App的AndroidManifest文件中，也在首页Activity的<code>&lt;intent-filter&gt;</code>指定action和category。</p><p><img src="/2023/02/21/Android%E6%8F%92%E4%BB%B6%E5%8C%96-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89Activity%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/launcher2AMS.png" alt></p><p>startActivity，调用startActivityForResult。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// -1：不关心App是否启动成功的返回结果</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startActivity</span><span class="hljs-params">(Intent intent, ...)</span> &#123;<br>    startActivityForResult(intent, -<span class="hljs-number">1</span>, options);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Launcher-startActivityForResult"><a href="#Launcher-startActivityForResult" class="headerlink" title="Launcher startActivityForResult"></a>Launcher startActivityForResult</h3><p>startActivityForResult方法的实现中，调用Instrumentation的execStartActivity。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startActivityForResult</span><span class="hljs-params">(Intent intent, ...)</span> &#123;<br>    Instrumentation.<span class="hljs-type">ActivityResult</span> <span class="hljs-variable">ar</span> <span class="hljs-operator">=</span><br>        mInstrumentation.execStartActivity(<br>            <span class="hljs-built_in">this</span>, mMainThread.getApplicationThread(), mToken, <span class="hljs-built_in">this</span>,<br>            intent, requestCode, options);<br>&#125;<br></code></pre></td></tr></table></figure><p>mMainThread变量，ActivityThread类型。</p><blockquote><p>ActivityThread，主线程，是UI线程，在App启动时创建，代表了App应用程序。</p><p>Application，ActivityThread的上下文。</p><p>一般程序由开发者提供main函数作为入口；Android App的入口是AndroidManifest中定义默认启动Activity。</p><blockquote><p>Android的main函数在ActivityThread中。这个类是Android系统提供的底层类，不由开发者提供。</p></blockquote></blockquote><p>通过ActivityThread的getApplicationThread方法取到一个Binder对象，对象的类型为ApplicationThread，代表了Launcher所在的App进程。</p><p>mToken也是一个Binder对象，代表Launcher这个Activity也通过Instrumentation传给AMS。</p><p>AMS通过类似路由的机制，记录下Launcher”IP地址“（这两个参数）。</p><h3 id="Instrumentation-execStartActivity"><a href="#Instrumentation-execStartActivity" class="headerlink" title="Instrumentation execStartActivity"></a>Instrumentation execStartActivity</h3><p>帮助启动Activity。</p><p>这里借助Instrumentation做一个透传，借助Instrumentation，Activity把数据传递给ActivityManagerNative。</p><h3 id="AMN-getDefault"><a href="#AMN-getDefault" class="headerlink" title="AMN getDefault"></a>AMN getDefault</h3><p>AMN通过getDefault方法，从ServiceManager（一个容器类）中取得一个名为activity的对象，然后把它包装成一个ActivityManagerProxy对象（AMP），作为AMS的代理对象。</p><blockquote><p>AMN的getDefault方法返回类型为IActivityManager，而不是AMP。IActivityManager是一个实现了IInterface的接口，里面定义了四大组件所有的生命周期。</p></blockquote><p><img src="/2023/02/21/Android%E6%8F%92%E4%BB%B6%E5%8C%96-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89Activity%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/AMNAMPClass.png" alt></p><p>AMN和AMP都实现了IActivityManager接口，AMS继承自AMN，<strong>AIDL</strong>。</p><h3 id="AMP-startActivity"><a href="#AMP-startActivity" class="headerlink" title="AMP startActivity"></a>AMP startActivity</h3><p>AMP的startActivity和AIDL的Proxy方法一样，写入数据到另一个进程，也就是AMS，然后等待AMS返回结果。</p><h2 id="AMS处理Launcher传过来的信息"><a href="#AMS处理Launcher传过来的信息" class="headerlink" title="AMS处理Launcher传过来的信息"></a>AMS处理Launcher传过来的信息</h2><blockquote><p>AMS大部分逻辑和开发者无关。</p></blockquote><p>Binder的Server端在做事情，过程如下。</p><p>Binder（也就是AMN/AMP）和AMS通信，希望启动App，发送类型为START_ACTIVITY的请求给AMS，同时会告诉AMS要启动哪个Activity。</p><p>AMS检查App中的AndroidManifest文件，是否存在要启动的Activity。</p><p><img src="/2023/02/21/Android%E6%8F%92%E4%BB%B6%E5%8C%96-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89Activity%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/IAPTClass.png" alt></p><p>AMS通知Launcher，Launcher完成传递使命了，可以休眠了。Launcher以及它所在的进程在AMS这边保存为一个ActivityRecord对象，该对象里面有一个ApplicationThreadProxy，ApplicationThread的代理对象。</p><p>AMS通过ApplicationThreadProxy发送消息，而App端则通过ApplicationThread来接收这个消息。</p><h2 id="Launcher休眠并通知AMS"><a href="#Launcher休眠并通知AMS" class="headerlink" title="Launcher休眠并通知AMS"></a>Launcher休眠并通知AMS</h2><p><img src="/2023/02/21/Android%E6%8F%92%E4%BB%B6%E5%8C%96-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89Activity%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/launcher2AMS2.png" alt></p><p>ApplicationThread（APT）接收到来自AMS的消息后，调用ActivityThread（主线程）的sendMessage方法，向Launcher的主线程消息队列发送一个PAUSE_ACTIVITY消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(<span class="hljs-type">int</span> what, Object obj, <span class="hljs-type">int</span> arg, ...)</span> &#123;<br>    <span class="hljs-keyword">if</span> (DEBUG_MESSAGES)<br>        Slog.v(TAG, <span class="hljs-string">&quot;SCHEDULE &quot;</span> + what + <span class="hljs-string">&quot; &quot;</span> + mH.codeToString(what)<br>               + <span class="hljs-string">&quot;: &quot;</span> + arg1 + <span class="hljs-string">&quot; / &quot;</span> + obj);<br>    <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> Message.obtain();<br>    msg.what = what;<br>    msg.obj = obj;<br>    msg.arg1 = arg1;<br>    msg.arg2 = arg2;<br>    <span class="hljs-keyword">if</span> (async) &#123;<br>        msg.setAsynchronous(<span class="hljs-literal">true</span>);<br>    &#125;<br>    mH.sendMessage(msg);<br>&#125;<br></code></pre></td></tr></table></figure><p>发送消息是通过一个名为<strong>H</strong>的Handler类的完成。AMS给Activity发送的所有消息，以及给其他三大组件发送的所有消息，都从H这里经过（switch … case …做处理）。</p><blockquote><p>那么可以在这里做插件化技术。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityThread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">H</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="hljs-string">&quot;&gt;&gt;&gt; handling: &quot;</span> + codeToString(msg.what));<br>        <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>            <span class="hljs-keyword">case</span> PAUSE_ACTIVITY:<br>                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;activityPause&quot;</span>);<br>                handlePauseActivity((IBinder)msg.obj, <span class="hljs-literal">false</span>, (msg.arg1&amp;<span class="hljs-number">1</span>) != <span class="hljs-number">0</span>, msg.arg2, (msg.arg1&amp;<span class="hljs-number">2</span>) != <span class="hljs-number">0</span>);<br>                maybeSnapshot();<br>                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>H对PAUSE_ACTIVITY消息的处理，是调用ActivityThread的handlePauseActivity方法，该方法</p><ul><li>ActivityThread里面有一个mActivities集合，保存当前App也就是Launcher中所有打开的Activity，把它找出来，让它休眠；</li><li>通过AMP通知AMS，已经休眠。</li></ul><blockquote><p>H和APT都是ActivityThread的内嵌类，无类文件。</p></blockquote><p>以上，Launcher的工作完成了。</p><h2 id="AMS启动新的进程"><a href="#AMS启动新的进程" class="headerlink" title="AMS启动新的进程"></a>AMS启动新的进程</h2><p>AMS接下来要启动App的首页，App不在后台进程中，所以要启动一个新的进程。Process.start方法，并且指定了ActivityThread的main函数为入口函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">pid</span> <span class="hljs-operator">=</span> Process.start(“android.app.ActivityThread”, mSimpleProcessManagement ? app.processName : gid, debugFl ...)<br></code></pre></td></tr></table></figure><p>新的进程启动，以ActivityThread的main函数作为入口。启动新进程，其实就是启动一个新的App。</p><p><img src="/2023/02/21/Android%E6%8F%92%E4%BB%B6%E5%8C%96-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89Activity%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/newThread.png" alt></p><p>在启动新进程的时候，为这个进程创建ActivityThread对象，即主线程（UI线程）。创建好UI线程后，立刻进入ActivityThread的main函数，创建一个主线程Looper，也就是MainLooper，创建Application。</p><p>主线程在收到BIND_APPLICATION消息后，根据传递过来的ApplicationInfo创建一个对应的LoadedApk对象（标志当前APK信息），然后创建ContextImpl对象（标志当前进程的环境），紧接着通过反射创建目标Application，并调用其attach方法，将ContextImpl对象设置为目标Application的上下文环境，最后调用Application的onCreate函数，做一些初始工作。</p><blockquote><p>Application在App中并没有那么重要，只是一个Context上下文。App中的灵魂是ActivityThread，但是对于App开发人员是访问不到的，反射可以对于这个类进行一些修改。</p></blockquote><p>创建新App的最后，告诉AMS”启动好“的消息，把ActivityThread对象发送给AMS；则AMS”记录“了该App的信息，可以通过这个ActivityThread对象，向这个App发送消息。</p><h2 id="AMS告诉新App启动哪个Activity"><a href="#AMS告诉新App启动哪个Activity" class="headerlink" title="AMS告诉新App启动哪个Activity"></a>AMS告诉新App启动哪个Activity</h2><p>AMS把传入的ActivityThread对象转为一个ApplicationThread对象，用于以后和这个App跨进程通信（<a href="#AMS处理Launcher传过来的信息">和APT和ATP的关系同理</a>）。</p><blockquote><p>Q：App如何得到启动哪个Activity？</p><p>Launcher通知AMS，启动App的哪个Activity；AMS处理信息时，这个信息被存下来；AMS从过去的记录中翻出来要启动哪个Activity，然后通过ATP告诉App。</p></blockquote><h2 id="启动App首页Activity"><a href="#启动App首页Activity" class="headerlink" title="启动App首页Activity"></a>启动App首页Activity</h2><p><img src="/2023/02/21/Android%E6%8F%92%E4%BB%B6%E5%8C%96-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89Activity%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/startFirstActivity.png" alt></p><p>在Binder的另一端，App通过APT接收到AMS的消息，仍然在H的handleMessage方法的switch语句中处理，只不过，这次消息的类型是LAUNCH_ACTIVITY。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> LAUNCH_ACTIVITY: &#123;<br>    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;activityStart&quot;</span>);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ActivityClientRecord</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> (ActivityClientRecord) msg.obj;<br>    <span class="hljs-comment">// r.packageInfo就是LoadedAPK</span><br>r.packageInfo = getPackageInfoNoCheck(<br>    r.activityInfo.applicationInfo, r.compatInfo);<br>    handleLaunchActivity(r, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;LAUNCH_ACTIVITY&quot;</span>);<br>    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);<br>                &#125; <br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p><strong>ActivityClientRecord是AMS传递过来的要启动的Activity。</strong></p><p>getPackageInfoNoCheck方法会提取apk中的所有资源，然后设置r的packageInfo属性。这个属性的类型很有名，叫做LoadedApk。</p><blockquote><p>这个地方也是插件化技术渗入的一个点。</p></blockquote><p>在H的这个分支中，又反过来回调ActivityThread的handleLaunchActivity方法。</p><p><img src="/2023/02/21/Android%E6%8F%92%E4%BB%B6%E5%8C%96-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89Activity%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/ActivityThreadwithH.png" alt></p><p>每次都是APT执行ActivityThread的sendMessage方法，在这个方法中，把消息拼装一下，然后扔给H的swicth语句分析，决定要执行ActivityThread的那个方法。</p><p>handleLaunchActivity通过Instrumentation的newActivity方法，创建要启动的Activity实例；为这个Activity创建一个上下文Context对象，并与Activity进行关联；通过Instrumentation的callActivityOnCreate方法，执行Activity的onCreate方法，从而启动Activity。</p><p>至此，App启动完毕。这个流程经过了很多次握手，App和ASM频繁地向对方发送消息，而发送消息的机制，是建立在Binder的基础之上的。</p><h1 id="App内部的页面跳转"><a href="#App内部的页面跳转" class="headerlink" title="App内部的页面跳转"></a>App内部的页面跳转</h1><p>从ActivityA跳转到ActivityB，可以把ActivityA当作Launcher，这个过程不需要重新启动一个新的进程，可以简化流程。</p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Plug-in</tag>
      
      <tag>Java</tag>
      
      <tag>Activity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android插件化 读书笔记（三）封装反射语法</title>
    <link href="/2023/02/20/Android%E6%8F%92%E4%BB%B6%E5%8C%96-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%B0%81%E8%A3%85%E5%8F%8D%E5%B0%84%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/02/20/Android%E6%8F%92%E4%BB%B6%E5%8C%96-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%B0%81%E8%A3%85%E5%8F%8D%E5%B0%84%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="对反射的简单封装"><a href="#对反射的简单封装" class="headerlink" title="对反射的简单封装"></a>对反射的简单封装</h1><p>对反射的简单封装如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AncenReflection</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">create</span><span class="hljs-params">(String className, Class[] paramTypes, Object[] paramValues)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(className);<br>            <span class="hljs-type">Constructor</span> <span class="hljs-variable">ctor</span> <span class="hljs-operator">=</span> cls.getDeclaredConstructor(paramTypes);<br><br>            <span class="hljs-keyword">return</span> ctor.newInstance(paramValues);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">invokeInstanceMethod</span><span class="hljs-params">(Object obj, String methodName, Class[] paramTypes, Object[] paramValues)</span> &#123;<br>        <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 调用private方法</span><br>            <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredMethod(methodName, paramTypes);<br>            method.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> method.invoke(obj, paramValues);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">invokeStaticMethod</span><span class="hljs-params">(String className, String methodName, Class[] paramTypes, Object[] paramValues)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(className);<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> cls.getDeclaredMethod(methodName, paramTypes);<br>            method.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> method.invoke(<span class="hljs-literal">null</span>, paramValues);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getFieldObject</span><span class="hljs-params">(String className, Object obj, String fieldName)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(className);<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> cls.getDeclaredField(fieldName);<br>            field.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> field.get(obj);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFieldObject</span><span class="hljs-params">(String className, Object obj, String fieldName, Object fieldVaule)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(className);<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> cls.getDeclaredField(fieldName);<br>            field.setAccessible(<span class="hljs-literal">true</span>);<br>            field.set(obj, fieldVaule);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">clsname</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;com.ancen.testreflection.TestClassCtor&quot;</span>);<br>    <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(clsname);<br>    Class[] p3 = &#123;<span class="hljs-type">int</span>.class, String.class&#125;;<br>    Object[] v3 = &#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Ancen&quot;</span>&#125;;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> AncenReflection.create(clsname, p3, v3);<br>    Class[] p4 = &#123;String.class&#125;;<br>    Object[] v4 = &#123;<span class="hljs-string">&quot;Ancen_2&quot;</span>&#125;;<br>    AncenReflection.invokeStaticMethod(clsname, <span class="hljs-string">&quot;work&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="对反射进一步封装"><a href="#对反射进一步封装" class="headerlink" title="对反射进一步封装"></a>对反射进一步封装</h1><ul><li>重载（参数数量；Class cls、String className）；</li><li>区分静态字段和实例字段；</li><li>简化获取字段和设置字段的方法（减少参数数量）。</li></ul><blockquote><p>代码附在最后。</p></blockquote><h1 id="jOOR"><a href="#jOOR" class="headerlink" title="jOOR"></a>jOOR</h1><ul><li><p>Reflect.java</p></li><li><p>ReflectException.java</p></li></ul><blockquote><p>只有两个类，可以直接拖进项目。</p></blockquote><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>onClass()：包裹一个类或者对象，表示在这个类或对象上进行反射，类的值可以是Class，也可以是完整的类名（包含包名信息）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @param name</span><br><span class="hljs-comment"> * A fully qualified class name.</span><br><span class="hljs-comment"> * @param classLoader</span><br><span class="hljs-comment"> * The class loader in whose context the class should be loaded.</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-type">Reflect</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> onClass(Object.class);<br><span class="hljs-type">Reflect</span> <span class="hljs-variable">r2</span> <span class="hljs-operator">=</span> onClass(<span class="hljs-string">&quot;java.lang.Object&quot;</span>);<br><span class="hljs-type">Reflect</span> <span class="hljs-variable">r3</span> <span class="hljs-operator">=</span> onClass(<span class="hljs-string">&quot;java.lang.Object&quot;</span>, ClassLoader.getSystemClassLoader());<br><br><span class="hljs-comment">// 等价于Class.forName()</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">Class</span> <span class="hljs-variable">j4</span> <span class="hljs-operator">=</span> onClass(<span class="hljs-string">&quot;android.widget.Button&quot;</span>).type();<br>&#125;<br><span class="hljs-keyword">catch</span> (ReflectException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="调用构造方法"><a href="#调用构造方法" class="headerlink" title="调用构造方法"></a>调用构造方法</h2><p>onCreate()：用来调用之前的类的构造方法，有两种重载，一种有参数，一种无参数；返回Reflect包裹体。可以通过get()获取返回值拿到构造的类的实例。</p><p>get()：获取（field和method返回）值相关，会进行类型转换，常与call组合使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TestClassCtor</span> <span class="hljs-variable">testClassCtor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestClassCtor</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> testClassCtor.getClass();<br><span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> temp.getName();<br><br><span class="hljs-comment">// public构造函数</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> onClass(temp).create().get();<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> onClass(temp).create(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;abc&quot;</span>).get();<br><br><span class="hljs-comment">// private构造函数</span><br><span class="hljs-type">TestClassCtor</span> <span class="hljs-variable">obj3</span> <span class="hljs-operator">=</span> onClass(TestClassCtor.class).create(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;abc&quot;</span>).get();<br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> obj3.getName();<br>Log.d(<span class="hljs-string">&quot;Ancen&quot;</span>, a);<br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">D/Ancen: abc</span><br></code></pre></td></tr></table></figure><h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><p>call()：方法调用，传入方法名和参数，如有返回值还需要调用get。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建对象</span><br><span class="hljs-type">TestClassCtor</span> <span class="hljs-variable">testClassCtor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestClassCtor</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> testClassCtor.getClass();<br><span class="hljs-type">Reflect</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> onClass(temp).create();<br><br><span class="hljs-comment">// 调用一个private实例方法</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> r.call(<span class="hljs-string">&quot;doSomething&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>).get();<br><span class="hljs-comment">// 调用一个public实例方法</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> r.call(<span class="hljs-string">&quot;getName&quot;</span>).get();<br><span class="hljs-comment">// 调用一个private静态方法</span><br>onClass(TestClassCtor.class).call(<span class="hljs-string">&quot;work&quot;</span>).get();<br><span class="hljs-comment">// 调用一个public静态方法</span><br>onClass(TestClassCtor.class).call(<span class="hljs-string">&quot;printAddress&quot;</span>).get();<br></code></pre></td></tr></table></figure><h2 id="访问字段"><a href="#访问字段" class="headerlink" title="访问字段"></a>访问字段</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取实例字段并修改</span><br><span class="hljs-type">Reflect</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> onClass(<span class="hljs-string">&quot;com.ancen.testreflection.TestClassCtor&quot;</span>)<br>    .create(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;abc&quot;</span>);<br>r.set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Ancen_2&quot;</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> r.get(<span class="hljs-string">&quot;name&quot;</span>);<br><br><span class="hljs-comment">// 获取静态字段并修改</span><br>onClass(<span class="hljs-string">&quot;com.ancen.testreflection.TestClassCtor&quot;</span>)<br>    .set(<span class="hljs-string">&quot;address&quot;</span>, <span class="hljs-string">&quot;ac&quot;</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> onClass(<span class="hljs-string">&quot;com.ancen.testreflection.TestClassCtor&quot;</span>)<br>    .get(<span class="hljs-string">&quot;address&quot;</span>);<br><br>Log.d(<span class="hljs-string">&quot;Ancen&quot;</span>, obj1.toString());<br>Log.d(<span class="hljs-string">&quot;Ancen&quot;</span>, obj2.toString());<br></code></pre></td></tr></table></figure><h2 id="对泛型的反射"><a href="#对泛型的反射" class="headerlink" title="对泛型的反射"></a>对泛型的反射</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取AMN的gDefault单例gDefault，gDefault是静态的</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">gDefault</span> <span class="hljs-operator">=</span> onClass(<span class="hljs-string">&quot;com.ancen.testreflection.AMN&quot;</span>).get(<span class="hljs-string">&quot;gDefault&quot;</span>);<br><br><span class="hljs-comment">// gDefault是一个android.util.Singleton对象</span><br><span class="hljs-comment">// 取出这个单例里面的mInstance字段</span><br><span class="hljs-comment">// mInstance是初始的ClassB2Interface对象</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">mInstance</span> <span class="hljs-operator">=</span> onClass(gDefault).get(<span class="hljs-string">&quot;mInstance&quot;</span>);<br><br><span class="hljs-comment">// 创建一个这个对象的代理对象ClassB2Mock, 然后替换这个字段</span><br>Class&lt;?&gt; classB2Interface = onClass(<span class="hljs-string">&quot;com.ancen.testreflection.ClassB2Interface&quot;</span>).type();<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @param ClassLoader loader</span><br><span class="hljs-comment"> * 用哪个类加载器去加载代理对象</span><br><span class="hljs-comment"> * @param Class&lt;?&gt;[] interfaces</span><br><span class="hljs-comment"> * 动态代理类需要实现的接口</span><br><span class="hljs-comment"> * @param reflect.InvocationHandler h</span><br><span class="hljs-comment"> * 动态代理方法在执行时，会调用h里面的invoke方法去执行</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> Proxy.newProxyInstance(<br>        Thread.currentThread().getContextClassLoader(),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[] &#123; classB2Interface &#125;,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassB2Mock</span>(mInstance));<br>onClass(gDefault).set(<span class="hljs-string">&quot;mInstance&quot;</span>, proxy);<br></code></pre></td></tr></table></figure><h2 id="jOOR缺陷"><a href="#jOOR缺陷" class="headerlink" title="jOOR缺陷"></a>jOOR缺陷</h2><p>jOOR在Android领域有个很大的缺陷，jOOR不支持反射final类型的字段。</p><blockquote><p>2023年做实验，已经支持了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Ancen&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实例字段</span><br><span class="hljs-type">Reflect</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> onClass(<span class="hljs-string">&quot;com.ancen.testreflection.User&quot;</span>).create();<br>obj.set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Ancen_2&quot;</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">newObj</span> <span class="hljs-operator">=</span> obj.get(<span class="hljs-string">&quot;name&quot;</span>);<br>Log.d(<span class="hljs-string">&quot;Ancen&quot;</span>, newObj.toString());<br><br><span class="hljs-comment">// 静态字段</span><br><span class="hljs-type">Reflect</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> onClass(<span class="hljs-string">&quot;com.ancen.testreflection.User&quot;</span>);<br>obj2.set(<span class="hljs-string">&quot;userId&quot;</span>, <span class="hljs-number">1</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">newObj2</span> <span class="hljs-operator">=</span> obj2.get(<span class="hljs-string">&quot;userId&quot;</span>);<br>Log.d(<span class="hljs-string">&quot;Ancen&quot;</span>, newObj2.toString());<br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">D/Ancen: Ancen_2</span><br><span class="hljs-section">D/Ancen: 1</span><br></code></pre></td></tr></table></figure><h1 id="对反射进一步封装（Code）"><a href="#对反射进一步封装（Code）" class="headerlink" title="对反射进一步封装（Code）"></a>对反射进一步封装（Code）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ancen.testreflection;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AncenReflection</span> &#123;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 构造函数</span><br><span class="hljs-comment">     * 无参</span><br><span class="hljs-comment">     * 一个参数</span><br><span class="hljs-comment">     * 多个参数</span><br><span class="hljs-comment">     * */</span><br><br>    <span class="hljs-comment">// 无参</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">create</span><span class="hljs-params">(String className)</span> &#123;<br>        Class[] paramTypes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;;<br>        Object[] paramValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;&#125;;<br>        <span class="hljs-keyword">return</span> create(className, paramTypes, paramValues);<br>    &#125;<br><br>    <span class="hljs-comment">// 无参</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">create</span><span class="hljs-params">(Class cls)</span> &#123;<br>        Class[] paramTypes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;;<br>        Object[] paramValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;&#125;;<br>        <span class="hljs-keyword">return</span> create(cls, paramTypes, paramValues);<br>    &#125;<br><br>    <span class="hljs-comment">// 一个参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">create</span><span class="hljs-params">(String className, Class paramType, Object paramValue)</span> &#123;<br>        Class[] paramTypes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;paramType&#125;;<br>        Object[] paramValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;paramValue&#125;;<br>        <span class="hljs-keyword">return</span> create(className, paramTypes, paramValues);<br>    &#125;<br><br>    <span class="hljs-comment">// 一个参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">create</span><span class="hljs-params">(Class cls, Class paramType, Object paramValue)</span> &#123;<br>        Class[] paramTypes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;paramType&#125;;<br>        Object[] paramValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;paramValue&#125;;<br>        <span class="hljs-keyword">return</span> create(cls, paramTypes, paramValues);<br>    &#125;<br><br>    <span class="hljs-comment">// 多个参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">create</span><span class="hljs-params">(String className, Class[] paramTypes, Object[] paramValues)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(className);<br>            <span class="hljs-type">Constructor</span> <span class="hljs-variable">ctor</span> <span class="hljs-operator">=</span> cls.getDeclaredConstructor(paramTypes);<br>            <span class="hljs-keyword">return</span> ctor.newInstance(paramValues);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 多个参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">create</span><span class="hljs-params">(Class cls, Class[] paramTypes, Object[] paramValues)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Constructor</span> <span class="hljs-variable">ctor</span> <span class="hljs-operator">=</span> cls.getDeclaredConstructor(paramTypes);<br>            <span class="hljs-keyword">return</span> ctor.newInstance(paramValues);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 调用实例方法</span><br><span class="hljs-comment">     * 无参</span><br><span class="hljs-comment">     * 一个参数</span><br><span class="hljs-comment">     * 多个参数</span><br><span class="hljs-comment">     * */</span><br><br>    <span class="hljs-comment">// 无参</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">invokeInstanceMethod</span><span class="hljs-params">(Object obj, String methodName)</span> &#123;<br>        Class[] paramTypes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;;<br>        Object[] paramValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;&#125;;<br>        <span class="hljs-keyword">return</span> invokeInstanceMethod(obj, methodName, paramTypes, paramValues);<br>    &#125;<br><br>    <span class="hljs-comment">// 一个参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">invokeInstanceMethod</span><span class="hljs-params">(Object obj, String methodName, Class paramType, Object paramValue)</span> &#123;<br>        Class[] paramTypes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;paramType&#125;;<br>        Object[] paramValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;paramValue&#125;;<br>        <span class="hljs-keyword">return</span> invokeInstanceMethod(obj, methodName, paramTypes, paramValues);<br>    &#125;<br><br>    <span class="hljs-comment">// 多个参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">invokeInstanceMethod</span><span class="hljs-params">(Object obj, String methodName, Class[] paramTypes, Object[] paramValues)</span> &#123;<br>        <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 调用private方法</span><br>            <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredMethod(methodName, paramTypes);<br>            method.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> method.invoke(obj, paramValues);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 调用静态方法</span><br><span class="hljs-comment">     * 无参</span><br><span class="hljs-comment">     * 一个参数</span><br><span class="hljs-comment">     * 多个参数</span><br><span class="hljs-comment">     * */</span><br><br>    <span class="hljs-comment">// 无参</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">invokeStaticMethod</span><span class="hljs-params">(String className, String methodName)</span> &#123;<br>        Class[] paramTypes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;;<br>        Object[] paramValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;&#125;;<br>        <span class="hljs-keyword">return</span> invokeStaticMethod(className, methodName, paramTypes, paramValues);<br>    &#125;<br><br>    <span class="hljs-comment">// 无参</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">invokeStaticMethod</span><span class="hljs-params">(Class cls, String methodName)</span> &#123;<br>        Class[] paramTypes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;;<br>        Object[] paramValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;&#125;;<br>        <span class="hljs-keyword">return</span> invokeStaticMethod(cls, methodName, paramTypes, paramValues);<br>    &#125;<br><br>    <span class="hljs-comment">// 一个参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">invokeStaticMethod</span><span class="hljs-params">(String className, String methodName, Class paramType, Object paramValue)</span> &#123;<br>        Class[] paramTypes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;paramType&#125;;<br>        Object[] paramValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;paramValue&#125;;<br>        <span class="hljs-keyword">return</span> invokeStaticMethod(className, methodName, paramTypes, paramValues);<br>    &#125;<br><br>    <span class="hljs-comment">// 一个参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">invokeStaticMethod</span><span class="hljs-params">(Class cls, String methodName, Class paramType, Object paramValue)</span> &#123;<br>        Class[] paramTypes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;paramType&#125;;<br>        Object[] paramValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;paramValue&#125;;<br>        <span class="hljs-keyword">return</span> invokeStaticMethod(cls, methodName, paramTypes, paramValues);<br>    &#125;<br><br>    <span class="hljs-comment">// 多个参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">invokeStaticMethod</span><span class="hljs-params">(String className, String methodName, Class[] paramTypes, Object[] paramValues)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(className);<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> cls.getDeclaredMethod(methodName, paramTypes);<br>            method.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> method.invoke(<span class="hljs-literal">null</span>, paramValues);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 多个参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">invokeStaticMethod</span><span class="hljs-params">(Class cls, String methodName, Class[] paramTypes, Object[] paramValues)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> cls.getDeclaredMethod(methodName, paramTypes);<br>            method.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> method.invoke(<span class="hljs-literal">null</span>, paramValues);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 调用静态方法</span><br><span class="hljs-comment">     * 区分静态和实例</span><br><span class="hljs-comment">     * 传入参数：String className；Class cls；Object obj</span><br><span class="hljs-comment">     * */</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getFieldObject</span><span class="hljs-params">(String className, Object obj, String fieldName)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(className);<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> cls.getDeclaredField(fieldName);<br>            field.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> field.get(obj);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getFieldObject</span><span class="hljs-params">(Class cls, Object obj, String fieldName)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> cls.getDeclaredField(fieldName);<br>            field.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> field.get(obj);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFieldObject</span><span class="hljs-params">(String className, Object obj, String fieldName, Object fieldValue)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(className);<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> cls.getDeclaredField(fieldName);<br>            field.setAccessible(<span class="hljs-literal">true</span>);<br>            field.set(obj, fieldValue);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFieldObject</span><span class="hljs-params">(Class cls, Object obj, String fieldName, Object fieldValue)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> cls.getDeclaredField(fieldName);<br>            field.setAccessible(<span class="hljs-literal">true</span>);<br>            field.set(obj, fieldValue);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFieldObject</span><span class="hljs-params">(Object obj, String fieldName, Object fieldValue)</span> &#123;<br>        setFieldObject(obj.getClass(), obj, fieldName, fieldValue);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getStaticFieldObject</span><span class="hljs-params">(String className, String fieldName)</span> &#123;<br>        <span class="hljs-keyword">return</span> getFieldObject(className, <span class="hljs-literal">null</span>, fieldName);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getStaticFieldObject</span><span class="hljs-params">(Class cls, String fieldName)</span> &#123;<br>        <span class="hljs-keyword">return</span> getFieldObject(cls, <span class="hljs-literal">null</span>, fieldName);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getStaticFieldObject</span><span class="hljs-params">(Object obj, String fieldName)</span> &#123;<br>        <span class="hljs-keyword">return</span> getFieldObject(obj.getClass(), <span class="hljs-literal">null</span>, fieldName);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStaticFieldObject</span><span class="hljs-params">(String classname, String fieldName, Object fieldValue)</span> &#123;<br>        setFieldObject(classname, <span class="hljs-literal">null</span>, fieldName, fieldValue);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStaticFieldObject</span><span class="hljs-params">(Class cls, String fieldName, Object fieldValue)</span> &#123;<br>        setFieldObject(cls, <span class="hljs-literal">null</span>, fieldName, fieldValue);<br>    &#125;<br><br>    <span class="hljs-comment">// 暂时不允许通过实例访问setStaticFieldObject来设置静态变量</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Plug-in</tag>
      
      <tag>Java</tag>
      
      <tag>Reflection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Head First Design Patterns 读书笔记（一）欢迎来到设计模式</title>
    <link href="/2023/02/19/Head-First-Design-Patterns-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/19/Head-First-Design-Patterns-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Design Patterns</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android第一行代码 读书笔记（二）UI</title>
    <link href="/2023/02/19/Android%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89UI/"/>
    <url>/2023/02/19/Android%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89UI/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android第一行代码 读书笔记（一）Activity</title>
    <link href="/2023/02/18/Android%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89Activity/"/>
    <url>/2023/02/18/Android%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89Activity/</url>
    
    <content type="html"><![CDATA[<h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><p>组件；用户界面；交互。</p><blockquote><p>Android程序设计讲究逻辑和视图分离，一个活动对应一个布局。</p></blockquote><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="创建一个活动"><a href="#创建一个活动" class="headerlink" title="创建一个活动"></a>创建一个活动</h2><p>布局；onCreate()；AndroidManifest.xml注册，配置主活动。</p><blockquote><p>android:id=”@+id/“，经典XML。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>    <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>    <span class="hljs-comment">// setContentView传入一个布局文件的id，在活动中加载该布局</span><br>    setContentView(R.layout.first_layout);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.FirstActivity&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:label</span>=<span class="hljs-string">&quot;This is FirstActivity&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><code>&lt;intent-filter&gt;</code>配置主活动。</p></blockquote><h2 id="Toast"><a href="#Toast" class="headerlink" title="Toast"></a>Toast</h2><p><code>Toast.makeTest().show()</code>，消息弹出；自动消失；短消息。</p><h2 id="Menu"><a href="#Menu" class="headerlink" title="Menu"></a>Menu</h2><p>菜单；res，menu（Directory），main.xml；<code>&lt;item&gt;</code>标签来创建菜单项。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建菜单对象。</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onCreateOptionsMenu</span><span class="hljs-params">(Menu menu)</span>&#123;<br>    <span class="hljs-comment">// MenuInflater对象inflate方法创建菜单</span><br>    getMenuInflater().inflate(R.menu.main,menu);<br>    <span class="hljs-comment">// 允许创建的菜单显示出来</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 菜单响应事件。</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onOptionsItemSelected</span><span class="hljs-params">(MenuItem item)</span>&#123;<br>    <span class="hljs-keyword">switch</span>(item.getItemId())&#123;<br>        <span class="hljs-keyword">case</span> R.id.add_item:<br>            Toast.makeText(<span class="hljs-built_in">this</span>,<span class="hljs-string">&quot;Add&quot;</span>,Toast.LENGTH_SHORT).show();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> R.id.remove_item:<br>            Toast.makeText(<span class="hljs-built_in">this</span>,<span class="hljs-string">&quot;Remove&quot;</span>,Toast.LENGTH_SHORT).show();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="销毁一个活动"><a href="#销毁一个活动" class="headerlink" title="销毁一个活动"></a>销毁一个活动</h2><p><code>finish();</code></p><h1 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h1><p>从主活动跳到其他活动。</p><h2 id="显式Intent"><a href="#显式Intent" class="headerlink" title="显式Intent"></a>显式Intent</h2><p>Intent，组件之间交互。用于</p><ul><li>指明当前组件想要执行的活动；</li><li>在不同组件之间传递数据。</li></ul><p>Intent用于启动活动、启动服务、发送广播等场景。Intent意图明显，称为显式Intent。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">button1.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View view)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * @param Context</span><br><span class="hljs-comment">        * @param Class</span><br><span class="hljs-comment">        * 指向希望打开的活动</span><br><span class="hljs-comment">        * */</span><br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(FirstActivity.<span class="hljs-built_in">this</span>,SecondActivity.class);<br>        startActivityForResult(intent,<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="隐式Intent"><a href="#隐式Intent" class="headerlink" title="隐式Intent"></a>隐式Intent</h2><p>指定一系列更抽象的action和category信息，交由系统去分析这个Intent，帮助<strong>找出最合适的活动去启动</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.SecondActivity&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.ancen.activitytest.ACTION_START&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>&lt;activity&gt;</code>下配置<code>&lt;intent-filter&gt;</code>，指定当前活动可以响应的action和category。当action和category同时匹配，这个活动才能响应Intent。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">button1.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View view)</span> &#123;<br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-string">&quot;con.ancen.activitytest.ACTION_START&quot;</span>);<br>        startActivity(intent);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>android.intent.category.DEFAULT</code>是一种默认的category，调用startActivity会自动将其添加进Intent。</p><blockquote><p>每个Intent中只能有一个action，但却能指定多个category。addCategory来添加category。新增的category必须有对应的响应Activity。</p></blockquote><h2 id="启动其他程序的活动"><a href="#启动其他程序的活动" class="headerlink" title="启动其他程序的活动"></a>启动其他程序的活动</h2><blockquote><p>隐式Intent更多的用法，点题，即使用Intent在程序之间“穿梭”。</p></blockquote><p>隐式Intent，启动其他程序的活动，使得Android多个应用程序之间的功能共享成为了可能。例如，应用程序需要展示网页，调用系统的浏览器打开网页。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">button1.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View view)</span> &#123;<br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Intent.ACTION_VIEW);<br>        <span class="hljs-comment">// Uri.parse()：将⼀个⽹址字符串解析成⼀个Uri对象</span><br>        intent.setData(Uri.parse(<span class="hljs-string">&quot;https://www.google.com&quot;</span>));<br>        startActivity(intent);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>Intent指定Intent.ACTION_VIEW，Android内置动作，值为android.intent.action.VIEW。</p><p><strong>setData用于指定当前Intent操作的数据</strong>。</p><blockquote><p><code>&lt;intent-filter&gt;</code>也可以配置<code>&lt;data&gt;</code>标签，用于更精确地指定当前活动能够响应什么类型的数据。scheme；host；port；path；mimeType（可以处理的数据类型，使用通配符指定）。<strong><code>&lt;data&gt;</code>标签指定的内容，需要和Intent中携带的Data一致。</strong></p></blockquote><p>自己建立一个活动，使也可以响应打开网页的Intent，即修改其注册信息从，配置了当前活动能够响应的action是Intent.ACTION_VIEW 的常量值。这时候会弹出选择浏览器响应，或是该活动响应。</p><blockquote><p>但实际上这个活动并没有加载并显⽰⽹⻚的功能，真正开发时候不要这么做，容易误导用户。</p></blockquote><h2 id="向下一个活动传递数据"><a href="#向下一个活动传递数据" class="headerlink" title="向下一个活动传递数据"></a>向下一个活动传递数据</h2><p>启动的时候传递数据。思路，Intent中捎带。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haskell">/*<br> * @param key<br> * ⽤于后⾯从<span class="hljs-type">Intent</span>中取值<br> * @param <span class="hljs-class"><span class="hljs-keyword">data</span></span><br> * 需要传递的数据<br> */<br><span class="hljs-title">intent</span>.putExtra(<span class="hljs-string">&quot;extra_data&quot;</span>, <span class="hljs-class"><span class="hljs-keyword">data</span>);</span><br></code></pre></td></tr></table></figure><p>启动了另⼀个活动，把这些数据从Intent中取出。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Intent intent <span class="hljs-operator">=</span> getIntent()<span class="hljs-comment">;</span><br>String data <span class="hljs-operator">=</span> intent.getStringExtra(<span class="hljs-string">&quot;extra_data&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>getIntent()获取到用于启动活动的Intent，调用getStringExtra()方法，传入相应的键值，得到数据。</p><h2 id="返回数据给上⼀个活动"><a href="#返回数据给上⼀个活动" class="headerlink" title="返回数据给上⼀个活动"></a>返回数据给上⼀个活动</h2><h3 id="startActivityForResult"><a href="#startActivityForResult" class="headerlink" title="startActivityForResult()"></a>startActivityForResult()</h3><p>startActivityForResult()方法也用于启动活动，这个方法期望在活动销毁的时候能够返回一个结果给上一个活动。具体做法，SecondActivity指定没有“意图”的Intent携带数据，setResult()传递Intent，finish()；在FirstActivity中重写onActivityResult()方法来得到返回的数据。</p><blockquote><p>onBackPressed()编写按下Back键逻辑，在这⾥添加返回数据的逻辑，使得按下Back键回到FirstActivity生效。</p><p>以上onActivityResult回调方法嵌套多、耦合大、维护难， 被舍弃。</p></blockquote><h3 id="Activity-Results-API"><a href="#Activity-Results-API" class="headerlink" title="Activity Results API"></a>Activity Results API</h3><p>两个重要的组件：ActivityResultContract和ActivityResultLauncher。ActivityResultContract协议，定义了如何传递数据和如何处理返回的数据，抽象类；ActivityResultLauncher，启动器，launch方法来启动页面跳转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Lambda表达式，当有结果返回时会回调到这里，在这里获取并处理数据</span><br><span class="hljs-type">ActivityResultLauncher</span> <span class="hljs-variable">launcher</span> <span class="hljs-operator">=</span> registerForActivityResult(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityResultContracts</span>.StartActivityForResult(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityResultCallback</span>&lt;ActivityResult&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onActivityResult</span><span class="hljs-params">(ActivityResult result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (result.getResultCode() == RESULT_OK) &#123;<br>            Log.d(TAG, <span class="hljs-string">&quot;onActivityResult: data = &quot;</span> + result.getData().getStringExtra(<span class="hljs-string">&quot;data_return&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// 为按钮注册监听器</span><br>button1.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View view)</span> &#123;<br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(FirstActivity.<span class="hljs-built_in">this</span>,SecondActivity.class);<br>        <span class="hljs-comment">// startActivityForResult(intent,1);</span><br>        launcher.launch(intent);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">button2.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View view)</span> &#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;onClick: &quot;</span>);<br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();<br>        intent.putExtra(<span class="hljs-string">&quot;data_return&quot;</span>, <span class="hljs-string">&quot;返回的数据&quot;</span>);<br>        setResult(RESULT_OK, intent);<br>        finish();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="活动的生命周期"><a href="#活动的生命周期" class="headerlink" title="活动的生命周期"></a>活动的生命周期</h1>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Activity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android插件化 读书笔记（二）Java原生反射</title>
    <link href="/2023/02/18/Android%E6%8F%92%E4%BB%B6%E5%8C%96-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Java%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%B0%84/"/>
    <url>/2023/02/18/Android%E6%8F%92%E4%BB%B6%E5%8C%96-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Java%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h1><blockquote><p>Java原生语法。</p></blockquote><p>class（包括interface）的本质是数据类型（Type）。由JVM在执行过程中动态加载的。JVM在第一次读取到一种class类型时，将其加载进内存。<strong>每加载一种类，JVM就为其创建一个Class类型的实例，并关联起来。</strong></p><blockquote><p>这里的Class类型也是一个名叫Class的class。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Class</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-title function_">Class</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>以String类为例，当JVM加载String类时，它首先读取String.class文件到内存，然后，为String类创建一个Class实例并关联起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>(String);<br></code></pre></td></tr></table></figure><blockquote><p>这个Class实例是JVM内部创建的，Class类的构造方法是private，只有JVM能创建Class实例，自己的Java程序是无法创建Class实例的。</p></blockquote><p><strong>JVM持有的每个Class实例都指向一个数据类型（class或interface）</strong>。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs coq">┌───────────────────────────┐<br>│      <span class="hljs-keyword">Class</span> <span class="hljs-keyword">Instance</span>       │──────&gt; String<br>├───────────────────────────┤<br>│name = <span class="hljs-string">&quot;java.lang.String&quot;</span>  │<br>└───────────────────────────┘<br>┌───────────────────────────┐<br>│      <span class="hljs-keyword">Class</span> <span class="hljs-keyword">Instance</span>       │──────&gt; Random<br>├───────────────────────────┤<br>│name = <span class="hljs-string">&quot;java.util.Random&quot;</span>  │<br>└───────────────────────────┘<br>┌───────────────────────────┐<br>│      <span class="hljs-keyword">Class</span> <span class="hljs-keyword">Instance</span>       │──────&gt; Runnable<br>├───────────────────────────┤<br>│name = <span class="hljs-string">&quot;java.lang.Runnable&quot;</span>│<br>└───────────────────────────┘<br></code></pre></td></tr></table></figure><p>一个Class实例包含了该class的所有完整信息。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gradle">┌───────────────────────────┐<br>│      <span class="hljs-keyword">Class</span> Instance       │──────&gt; String<br>├───────────────────────────┤<br>│name = <span class="hljs-string">&quot;java.lang.String&quot;</span>  │<br>├───────────────────────────┤<br>│<span class="hljs-keyword">package</span> = <span class="hljs-string">&quot;java.lang&quot;</span>      │<br>├───────────────────────────┤<br>│<span class="hljs-keyword">super</span> = <span class="hljs-string">&quot;java.lang.Object&quot;</span> │<br>├───────────────────────────┤<br>│<span class="hljs-keyword">interface</span> = CharSequence...│<br>├───────────────────────────┤<br>│field = value[],hash,...   │<br>├───────────────────────────┤<br>│method = indexOf()...      │<br>└───────────────────────────┘<br></code></pre></td></tr></table></figure><blockquote><p>可见，通过class的Class实例就可以获取到该实例对应的class的所有信息；且由上述可知，JVM为每个加载的class都创建了对应的Class实例，即class的Class实例存在且可获取。</p></blockquote><p><strong>这种通过Class实例获取class信息的方法称为反射（Reflection）。</strong></p><h2 id="获得Class实例"><a href="#获得Class实例" class="headerlink" title="获得Class实例"></a>获得Class实例</h2><p>由以下方法获取class的Class实例；静态方法Class.forName()最常用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// class的实例变量-&gt;class的Class实例</span><br><span class="hljs-comment">// 通过getClass，每个类都有这个函数</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> str.getClass();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// class的字符串类名-&gt;class的Class实例</span><br><span class="hljs-comment">// 这种方式最常见，通过静态方法Class.forName()</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br><span class="hljs-type">Class</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;android.widget.Button&quot;</span>);<br><span class="hljs-comment">// 通过getSuperClass获得父类，每个类都有这个函数</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">c5</span> <span class="hljs-operator">=</span> c3.getSuperclass();  <span class="hljs-comment">// 得到TextView</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// class-&gt;class的Class实例</span><br><span class="hljs-comment">// 通过.class静态属性</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">c6</span> <span class="hljs-operator">=</span> String.class;<br><span class="hljs-type">Class</span> <span class="hljs-variable">c7</span> <span class="hljs-operator">=</span> java.lang.String.class;<br><span class="hljs-type">Class</span> <span class="hljs-variable">c8</span> <span class="hljs-operator">=</span> MainActivity.InnerClass.class;<br><span class="hljs-type">Class</span> <span class="hljs-variable">c9</span> <span class="hljs-operator">=</span> <span class="hljs-type">int</span>.class;<br><span class="hljs-type">Class</span> <span class="hljs-variable">c10</span> <span class="hljs-operator">=</span> <span class="hljs-type">int</span>[].class;<br><span class="hljs-comment">// 基本类型包装类的TYPE语法</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">c11</span> <span class="hljs-operator">=</span> Boolean.TYPE;<br><span class="hljs-type">Class</span> <span class="hljs-variable">c12</span> <span class="hljs-operator">=</span> Byte.TYPE;<br><span class="hljs-type">Class</span> <span class="hljs-variable">c13</span> <span class="hljs-operator">=</span> Character.TYPE;<br><span class="hljs-type">Class</span> <span class="hljs-variable">c14</span> <span class="hljs-operator">=</span> Short.TYPE;<br><span class="hljs-type">Class</span> <span class="hljs-variable">c15</span> <span class="hljs-operator">=</span> Integer.TYPE;<br><span class="hljs-type">Class</span> <span class="hljs-variable">c16</span> <span class="hljs-operator">=</span> Long.TYPE;<br><span class="hljs-type">Class</span> <span class="hljs-variable">c17</span> <span class="hljs-operator">=</span> Float.TYPE;<br><span class="hljs-type">Class</span> <span class="hljs-variable">c18</span> <span class="hljs-operator">=</span> Double.TYPE;<br><span class="hljs-type">Class</span> <span class="hljs-variable">c19</span> <span class="hljs-operator">=</span> Void.TYPE;<br></code></pre></td></tr></table></figure><blockquote><p>得到类和对象的类型，主要用于<strong>Proxy.newProxyInstance</strong>。</p></blockquote><p>数组（例如String[]）也是一种类，而且不同于String.class，它的类名是<code>[Ljava.lang.String;</code>。JVM为每一种基本类型如int也创建了Class实例，通过int.class访问。</p><h2 id="使用Class实例"><a href="#使用Class实例" class="headerlink" title="使用Class实例"></a>使用Class实例</h2><p>可以通过获取的Class实例来创建对应类型的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取String的Class实例:</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> String.class;<br><span class="hljs-comment">// 创建一个String实例:</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (String) cls.newInstance();<br></code></pre></td></tr></table></figure><p>上述代码相当于new String()。通过Class.newInstance()可以创建类实例，<strong>它的局限是：只能调用public的无参数构造方法</strong>，带参数的构造方法，或者非public的构造方法都无法通过Class.newInstance()被调用。</p><h2 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h2><p>JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。<strong>利用JVM动态加载class的特性，可以在运行期根据条件加载不同的实现类。</strong></p><h1 id="调用构造函数"><a href="#调用构造函数" class="headerlink" title="调用构造函数"></a>调用构造函数</h1><blockquote><p>反射到类的构造函数很重要；下述流程中，存在以下重要步骤：<strong>通过字符串反射出一个类，然后通过反射获取到类的构造函数，执行构造函数得到类的实例。从类的实例出发，通过反射进一步得到实例所有字段和方法。</strong></p></blockquote><p>Class类提供了以下几个方法Constructor。</p><ul><li>getConstructors()：获取所有public的Constructor；</li><li><p>getDeclaredConstructors()：获取所有Constructor；</p></li><li><p>getConstructor(Class…)：获取某个public的Constructor；</p></li><li>getDeclaredConstructor(Class…)：获取某个Constructor。</li></ul><blockquote><p>调用非public的Constructor时，必须首先通过setAccessible(true)设置允许访问。setAccessible(true)可能会失败。</p></blockquote><h2 id="获取全部构造函数"><a href="#获取全部构造函数" class="headerlink" title="获取全部构造函数"></a>获取全部构造函数</h2><p>getDeclaredConstructors()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClassCtor</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestClassCtor</span><span class="hljs-params">()</span> &#123;<br>        name = <span class="hljs-string">&quot;Ancen&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestClassCtor</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestClassCtor</span><span class="hljs-params">(<span class="hljs-type">int</span> a, String b)</span> &#123;<br>        name = b;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">doSOmething</span><span class="hljs-params">(String d)</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;doSomething&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;abcd&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;work&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printAddress</span><span class="hljs-params">()</span> &#123;<br>        System.out.print(address);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TestClassCtor</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestClassCtor</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> r.getClass();<br><span class="hljs-comment">// 获取指定类的类名</span><br><span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> temp.getName();<br><br><span class="hljs-comment">// 获取类的所有ctor，不分public还是private</span><br>Constructor[] theConstructors = temp.getDeclaredConstructors();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; theConstructors.length; i++) &#123;<br>    <span class="hljs-comment">// 输出修饰域和方法名称</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> theConstructors[i].getModifiers();<br>    System.out.print(Modifier.toString(mod) + <span class="hljs-string">&quot; &quot;</span> + className + <span class="hljs-string">&quot;(&quot;</span>);<br><br>    <span class="hljs-comment">// 获取指定构造方法的参数的集合</span><br>    Class[] parameterTypes = theConstructors[i].getParameterTypes();<br>    <span class="hljs-comment">// 输出打印参数列表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; parameterTypes.length; j++) &#123;<br>        System.out.print(parameterTypes[j].getName());<br>        <span class="hljs-keyword">if</span> (parameterTypes.length &gt; j + <span class="hljs-number">1</span>) &#123;<br>            System.out.print(<span class="hljs-string">&quot;, &quot;</span>);<br>        &#125;<br>    &#125;<br>    System.out.print(<span class="hljs-string">&quot;)&quot;</span> + <span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">TestClassCtor</span><span class="hljs-params">(<span class="hljs-type">int</span>, java.lang.String)</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">TestClassCtor</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">TestClassCtor</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure><blockquote><p>参考获取Method对象获取所有信息的方法，构造方法也是方法。</p></blockquote><h2 id="获取某个构造函数"><a href="#获取某个构造函数" class="headerlink" title="获取某个构造函数"></a>获取某个构造函数</h2><p>getDeclaredConstructor()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取类的ctor：TestClassCtor()；无参构造函数</span><br><span class="hljs-type">Constructor</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> temp.getDeclaredConstructor();<br>System.out.print(c1 + <span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-type">Constructor</span> <span class="hljs-variable">c1_1</span> <span class="hljs-operator">=</span> temp.getConstructor();<br>System.out.print(c1_1 + <span class="hljs-string">&quot;\n&quot;</span>);<br><br><span class="hljs-comment">// 获取类的ctor：TestClassCtor(int a)</span><br>Class[] p2 = &#123; <span class="hljs-type">int</span>.class &#125;;<br><span class="hljs-type">Constructor</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> temp.getDeclaredConstructor(p2);<br>System.out.print(c2 + <span class="hljs-string">&quot;\n&quot;</span>);<br><br><span class="hljs-comment">// 获取类的ctor：TestClassCtor(int a, String b)</span><br>Class[] p3 = &#123; <span class="hljs-type">int</span>.class, String.class &#125;;<br><span class="hljs-type">Constructor</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> temp.getDeclaredConstructor(p3);<br>System.out.print(c3 + <span class="hljs-string">&quot;\n&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">TestClassCtor</span><span class="hljs-params">()</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">TestClassCtor</span><span class="hljs-params">()</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">TestClassCtor</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">TestClassCtor</span><span class="hljs-params">(<span class="hljs-type">int</span>,java.lang.String)</span><br></code></pre></td></tr></table></figure><h2 id="调用构造函数-1"><a href="#调用构造函数-1" class="headerlink" title="调用构造函数"></a>调用构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;TestClassCtor&quot;</span>);<br><br><span class="hljs-comment">// 含参</span><br>Class[] p3 = &#123; <span class="hljs-type">int</span>.class, String.class &#125;;<br><span class="hljs-type">Constructor</span> <span class="hljs-variable">ctor</span> <span class="hljs-operator">=</span> r.getDeclaredConstructor(p3);<br>ctor.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">// Object obj = ctor.newInstance(1, &quot;abc&quot;);</span><br><span class="hljs-type">TestClassCtor</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> (TestClassCtor) ctor.newInstance(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;abcde&quot;</span>);<br>obj.printAddress();<br><br><span class="hljs-comment">// 无参</span><br><span class="hljs-type">Constructor</span> <span class="hljs-variable">ctor2</span> <span class="hljs-operator">=</span> r.getDeclaredConstructor();<br><span class="hljs-comment">// Object obj2 = ctor2.newInstance();</span><br><span class="hljs-type">TestClassCtor</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> (TestClassCtor) ctor2.newInstance();<br>obj2.printAddress();<br><br><span class="hljs-comment">// 也可以使用Class的newInstance方法，但Class仅提供默认无参的实例化方法</span><br><span class="hljs-comment">// 提示，Java9，类型的newInstance()方法已经被弃用</span><br><span class="hljs-comment">// Object obj4 = r.newInstance();</span><br></code></pre></td></tr></table></figure><h1 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h1><p>Class类提供了以下几个方法来获取Method。</p><ul><li>Method getMethod(name, Class…)：获取某个public的Method（包括父类）；</li><li>Method getDeclaredMethod(name, Class…)：获取当前类的某个Method（不包括父类）；</li><li>Method[] getMethods()：获取所有public的Method（包括父类）；</li><li>Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类）。</li></ul><h2 id="获取类的私有方法并调用"><a href="#获取类的私有方法并调用" class="headerlink" title="获取类的私有方法并调用"></a>获取类的私有方法并调用</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> d</span>) &#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个对象</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;TestClassCtor&quot;</span>);<br>Class[] p3 = &#123; <span class="hljs-type">int</span>.class, String.class &#125;;<br><span class="hljs-type">Constructor</span> <span class="hljs-variable">ctor</span> <span class="hljs-operator">=</span> r.getDeclaredConstructor(p3);<br>ctor.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ctor.newInstance(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;abc&quot;</span>);<br><br><span class="hljs-comment">// 调用方法</span><br>Class[] p4 = &#123; String.class &#125;;<br><span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> r.getDeclaredMethod(<span class="hljs-string">&quot;doSOmething&quot;</span>, p4);<br>method.setAccessible(<span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 参数先写死，下面有通用的函数getMethodParamObject</span><br>Object argList[] = &#123; <span class="hljs-string">&quot;a&quot;</span> &#125;;<br><span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(obj, argList);<br></code></pre></td></tr></table></figure><blockquote><p>一个Method对象包含一个方法的所有信息：</p><ul><li>getName()：返回方法名称，例如：”getScore”；</li><li>getReturnType()：返回方法返回值类型，也是一个Class实例，例如：String.class；</li><li>getParameterTypes()：返回方法的参数类型，是一个Class数组，例如：{String.class, int.class}；</li><li>getModifiers()：返回方法的修饰符，它是一个int，不同的bit表示不同的含义。</li></ul></blockquote><h2 id="获取类的静态私有方法并调用"><a href="#获取类的静态私有方法并调用" class="headerlink" title="获取类的静态私有方法并调用"></a>获取类的静态私有方法并调用</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span>()</span> &#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个对象</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;TestClassCtor&quot;</span>);<br><br><span class="hljs-comment">// 调用方法</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> r.getDeclaredMethod(<span class="hljs-string">&quot;work&quot;</span>); <span class="hljs-comment">// 在指定类中获取指定的方法</span><br>method.setAccessible(<span class="hljs-literal">true</span>);<br>method.invoke(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><blockquote><p><strong>使用反射调用方法时，仍然遵循多态原则</strong>：即总是调用实际类型的重写方法（如果存在）。从父类Class实例拿到的方法，作用在子类实例上，还是会调用子类的重写方法。</p></blockquote><h1 id="访问字段"><a href="#访问字段" class="headerlink" title="访问字段"></a>访问字段</h1><p>Class类提供了以下几个方法来获取字段。</p><ul><li>Field getField(name)：根据字段名获取某个public的field（包括父类）；</li><li>Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）；</li><li>Field[] getFields()：获取所有public的field（包括父类）；</li><li>Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）。</li></ul><h2 id="获取类的私有字段并修改"><a href="#获取类的私有字段并修改" class="headerlink" title="获取类的私有字段并修改"></a>获取类的私有字段并修改</h2><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> <span class="hljs-keyword">name</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个对象</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.testreflection.TestClassCtor&quot;</span>);<br>Class[] p3 = &#123;<span class="hljs-type">int</span>.class, String.class&#125;;<br><span class="hljs-type">Constructor</span> <span class="hljs-variable">ctor</span> <span class="hljs-operator">=</span> r.getDeclaredConstructor(p3);<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ctor.newInstance(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;abc&quot;</span>);<br><br><span class="hljs-comment">// 获取name字段，private</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> r.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>field.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 获取指定实例的指定字段的值</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">fieldObject</span> <span class="hljs-operator">=</span> field.get(obj);<br><span class="hljs-comment">// 设置指定实例的指定字段的值，只对当前实例有效</span><br>field.set(obj, <span class="hljs-string">&quot;ancen&quot;</span>);<br><br><span class="hljs-type">TestClassCtor</span> <span class="hljs-variable">testClassCtor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestClassCtor</span>(<span class="hljs-number">100</span>);<br>testClassCtor.getName(); <span class="hljs-comment">// 仍然返回null，并没有修改</span><br></code></pre></td></tr></table></figure><blockquote><p>一个Field对象包含了一个字段的所有信息：</p><ul><li>getName()：返回字段名称，例如，”name”；</li><li>getType()：返回字段类型，也是一个Class实例，例如，String.class；</li><li>getModifiers()：返回字段的修饰符。</li></ul><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">byte</span>[] value;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Field f = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">DeclaredField(<span class="hljs-string">&quot;value&quot;</span>)</span>;<br>f.get<span class="hljs-constructor">Name()</span>; <span class="hljs-comment">// &quot;value&quot;</span><br>f.get<span class="hljs-constructor">Type()</span>; <span class="hljs-comment">// class [B 表示byte[]类型</span><br><span class="hljs-built_in">int</span> m = f.get<span class="hljs-constructor">Modifiers()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Modifier</span>.</span></span>is<span class="hljs-constructor">Final(<span class="hljs-params">m</span>)</span>; <span class="hljs-comment">// true</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Modifier</span>.</span></span>is<span class="hljs-constructor">Public(<span class="hljs-params">m</span>)</span>; <span class="hljs-comment">// false</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Modifier</span>.</span></span>is<span class="hljs-constructor">Protected(<span class="hljs-params">m</span>)</span>; <span class="hljs-comment">// false</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Modifier</span>.</span></span>is<span class="hljs-constructor">Private(<span class="hljs-params">m</span>)</span>; <span class="hljs-comment">// true</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Modifier</span>.</span></span>is<span class="hljs-constructor">Static(<span class="hljs-params">m</span>)</span>; <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="获取类的静态私有字段并修改"><a href="#获取类的静态私有字段并修改" class="headerlink" title="获取类的静态私有字段并修改"></a>获取类的静态私有字段并修改</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个对象</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.testreflection.TestClassCtor&quot;</span>);<br><br><span class="hljs-comment">// 获取address静态字段，private static</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> r.getDeclaredField(<span class="hljs-string">&quot;address&quot;</span>);<br>field.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">fieldObject</span> <span class="hljs-operator">=</span> field.get(<span class="hljs-literal">null</span>);<br>field.set(fieldObject, <span class="hljs-string">&quot;abcd&quot;</span>);<br><br><span class="hljs-comment">// 静态变量，一次修改，终生受用</span><br>TestClassCtor.printAddress();<br></code></pre></td></tr></table></figure><h1 id="获取继承关系"><a href="#获取继承关系" class="headerlink" title="获取继承关系"></a>获取继承关系</h1><h2 id="获取父类Class"><a href="#获取父类Class" class="headerlink" title="获取父类Class"></a>获取父类Class</h2><p>getSuperclass()获取父类的class；getInterfaces()获取当前类直接实现的接口类型（并不包括其父类实现的接口类型），返回值是Class[]。</p><blockquote><p>getInterfaces()只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型。</p></blockquote><h2 id="判断继承关系"><a href="#判断继承关系" class="headerlink" title="判断继承关系"></a>判断继承关系</h2><p>判断一个实例是否是某个类型时，正常情况下，使用instanceof操作符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">123</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">isDouble</span> <span class="hljs-operator">=</span> n <span class="hljs-keyword">instanceof</span> Double; <span class="hljs-comment">// false</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isInteger</span> <span class="hljs-operator">=</span> n <span class="hljs-keyword">instanceof</span> Integer; <span class="hljs-comment">// true</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isNumber</span> <span class="hljs-operator">=</span> n <span class="hljs-keyword">instanceof</span> Number; <span class="hljs-comment">// true</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isSerializable</span> <span class="hljs-operator">=</span> n <span class="hljs-keyword">instanceof</span> java.io.Serializable; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>如果是两个Class实例，要判断一个向上转型是否成立，可以调用isAssignableFrom()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Integer i = ?</span><br><span class="hljs-comment">// true，因为Integer可以赋值给Integer</span><br>Integer.class.isAssignableFrom(Integer.class); <br><span class="hljs-comment">// Number n = ?</span><br><span class="hljs-comment">// true，因为Integer可以赋值给Number</span><br>Number.class.isAssignableFrom(Integer.class); <br><span class="hljs-comment">// Object o = ?</span><br><span class="hljs-comment">// true，因为Integer可以赋值给Object</span><br>Object.class.isAssignableFrom(Integer.class); <br><span class="hljs-comment">// Integer i = ?</span><br><span class="hljs-comment">// false，因为Number不能赋值给Integer</span><br>Integer.class.isAssignableFrom(Number.class); <br></code></pre></td></tr></table></figure><h1 id="对泛型类的反射（实例）"><a href="#对泛型类的反射（实例）" class="headerlink" title="对泛型类的反射（实例）"></a>对泛型类的反射（实例）</h1><p>Android系统源码中存在大量泛型，所以插件化技术离不开对泛型进行反射，比如单例模式（Singleton）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T mInstance;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> T <span class="hljs-title function_">create</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (mInstance == <span class="hljs-literal">null</span>) &#123;<br>                mInstance = create();<br>            &#125;<br>            <span class="hljs-keyword">return</span> mInstance;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Singleton是一个抽象类，实例化时，先实现create这个抽象方法。例如，ActivityManagerNative（AMN），和Singleton有关的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ClassB2Interface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AMN</span> &#123;<br>    <span class="hljs-comment">// gDefault是AMN的静态私有变量，Singleton类型</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton&lt;ClassB2Interface&gt; gDefault = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>&lt;ClassB2Interface&gt;() &#123;<br>        <span class="hljs-comment">// 要实现create方法，返回一个ClassB2类型的对象</span><br>        <span class="hljs-keyword">protected</span> ClassB2Interface <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">ClassB2</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassB2</span>();<br>            b2.id = <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">return</span> b2;<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class="hljs-comment">// getDefault()方法获取create方法创建的ClassB2对象</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> ClassB2Interface <span class="hljs-title function_">getDefault</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> gDefault.get();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassB2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClassB2Interface</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> id;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;doSomething&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">ActivityManager am;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// gDefault是一个android.util.Singleton对象; 我们取出这个单例里面的字段</span><br>    Class&lt;?&gt; singleton = Class.forName(<span class="hljs-string">&quot;Singleton&quot;</span>);<br>    <span class="hljs-type">Field</span> <span class="hljs-variable">mInstanceField</span> <span class="hljs-operator">=</span> singleton.getDeclaredField(<span class="hljs-string">&quot;mInstance&quot;</span>);<br>    mInstanceField.setAccessible(<span class="hljs-literal">true</span>);<br><br>    <span class="hljs-comment">// 获取AMN的gDefault单例gDefault，gDefault是静态的</span><br>    Class&lt;?&gt; activityManagerNativeClass = Class.forName(<span class="hljs-string">&quot;AMN&quot;</span>);<br>    <span class="hljs-type">Field</span> <span class="hljs-variable">gDefaultField</span> <span class="hljs-operator">=</span> activityManagerNativeClass.getDeclaredField(<span class="hljs-string">&quot;gDefault&quot;</span>);<br>    gDefaultField.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">gDefault</span> <span class="hljs-operator">=</span> gDefaultField.get(<span class="hljs-literal">null</span>);<br><br>    <span class="hljs-comment">// 进一步得到AMN的gDefault对象里面的ClassB2类型对象rawB2Object</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">rawB2Object</span> <span class="hljs-operator">=</span> mInstanceField.get(gDefault);<br><br>    <span class="hljs-comment">// 创建一个这个对象的代理对象ClassB2Mock, 然后替换这个字段</span><br>    <span class="hljs-comment">// ClassB2Mock是对rawB2Object的动态代理</span><br>    Class&lt;?&gt; classB2Interface = Class.forName(<span class="hljs-string">&quot;ClassB2Interface&quot;</span>);<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> Proxy.newProxyInstance(<br>        Thread.currentThread().getContextClassLoader(),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[] &#123; classB2Interface &#125;,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassB2Mock</span>(rawB2Object));<br>    <span class="hljs-comment">// 把AMN中的gDefault字段的，设置为代理对象proxy</span><br>    mInstanceField.set(gDefault, proxy);<br><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ClassB2Mock中</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object o, Method method, Object[] objects)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><span class="hljs-comment">// 代理额外打印了一行日志</span><br>    Log.e(<span class="hljs-string">&quot;Ancen&quot;</span>, method.getName());<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;doSomething&quot;</span>.equals(method.getName())) &#123;<br>        print();<br>    &#125;<br>    <span class="hljs-keyword">return</span> method.invoke(mBase, objects);<br>&#125;<br></code></pre></td></tr></table></figure><p>经过Hook，AMN.getDefault().doSomething()将执行ClassB2Mock里面的逻辑。</p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Plug-in</tag>
      
      <tag>Java</tag>
      
      <tag>Reflection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android插件化 读书笔记（一）插件化技术</title>
    <link href="/2023/02/17/Android%E6%8F%92%E4%BB%B6%E5%8C%96-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E6%8F%92%E4%BB%B6%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/02/17/Android%E6%8F%92%E4%BB%B6%E5%8C%96-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E6%8F%92%E4%BB%B6%E5%8C%96%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h1><p>Android安装应用，本身只是开辟进程，然后使用ClassLoader加载classes.dex（Java代码字节码）至进程中，执行对应的组件。同理，可以类似执行一个Apk中的代码。</p><p>插件化使Apk中的代码（Android组件）能够免安装运行，收益很大。</p><ul><li>减少安装Apk的体积，按需下载模块；</li><li>动态更新插件；</li><li>宿主和插件分开编译，提升开发效率。</li></ul><blockquote><p>拥有Native应用一样的性能，又能获取诸如Web应用一样的收益。</p></blockquote><h1 id="插件化历史"><a href="#插件化历史" class="headerlink" title="插件化历史"></a>插件化历史</h1><ul><li>静态代理，dynamic-load-apk最早使用ProxyActivity这种静态代理技术，由ProxyActivity去控制插件中PluginActivity的生命周期；that框架；</li><li>动态替换，实现原理都是上趋近于选择尽量少的Hook（但是早期没有，早期Hook了非常多Android底层源码），并通过在manifest中预埋一些组件实现对四大组件的动态插件化；</li><li>容器化框架，VirtualApp能够完全模拟App的运行环境，能够实现App的免安装运行和双开技术。Atlas是阿里的结合组件化和热修复技术的一个App基础框架，号称是一个容器化框架。</li></ul><h1 id="组件化与插件化"><a href="#组件化与插件化" class="headerlink" title="组件化与插件化"></a>组件化与插件化</h1><p>组件化，将一个App分成多个模块，每个模块都是一个组件（module），开发过程中可以让这些组件相互依赖或独立编译、调试部分组件，但是这些组件最终会合并成一个完整的Apk发布到应用市场。</p><p>插件化，将整个App拆分成很多模块，每个模块都是一个Apk（组件化的每个模块是一个lib），最终打包的时候将宿主Apk和插件Apk分开打包，只需发布宿主Apk到应用市场，插件Apk通过动态按需下发到宿主Apk。</p><h1 id="插件化用途"><a href="#插件化用途" class="headerlink" title="插件化用途"></a>插件化用途</h1><p>修复线上bug（最多）；增加新功能（相对来说，不着急）；游戏领域；ABTest等。</p><p>设想，各个业务模块提供打包好的Apk文件，放在宿主App的assets目录下。发版后，某个模块有更新，只需重新打包这个模块的代码，生成增量包，放到服务器上供用户下载。</p><h1 id="插件化技术难点"><a href="#插件化技术难点" class="headerlink" title="插件化技术难点"></a>插件化技术难点</h1><p>插件Apk运行，找到插件Apk的存放位置，然后解析加载Apk里的代码。</p><p>执行Java代码外，Android系统四大组件需要在系统中注册，具体是在Android系统的ActivityManagerService（AMS）和PackageManagerService（PMS）中注册的。必要性在于四大组件的解析和启动都需要依赖AMS和PMS。欺骗系统，使其承认一个未安装的Apk中的组件，让宿主动态加载执行插件Apk中Android组件是插件化最大的难点。</p><blockquote><p>Q：四大组件都需要插件化技术吗？</p><p>该根据App对四大组件的依赖程度，来选择合适的插件化技术。四大组件全都实现插件化固然是好的，但是如果App中主要是Activity，那么选择静态代理that框架就够了。</p></blockquote><p>另外，应用资源引用（特指R中引用的资源，layout、values、…）也是问题。设想，在宿主进程中使用反射加载了一个插件Apk后，代码中的R对应的id却无法引用到正确的资源。</p><p>All in all，做到插件化需要，</p><ul><li>加载并执行插件Apk中的代码（ClassLoader Injection）；</li><li>使系统能调用插件Apk中的组件（Runtime Container）；</li><li>正确识别插件Apk中的资源（Resource Injection）；资源合并、资源冲突。</li></ul><h1 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h1><p>使Android或iOS中的每个控件，在RN中都能找到相对应的控件。RN基于JavaScript编写，打包后放到服务器。</p><p>RN最大程度地实现了跨平台；JavaScript前端；快速迭代、快速上线。</p><h1 id="Google-Play"><a href="#Google-Play" class="headerlink" title="Google Play"></a>Google Play</h1><p>Google Play官方市场不允许插件化App的存在，审核会不通过。</p><blockquote><p>国外开发人员相对关注用户体验；Material Design；函数式编程；代码的优雅、实用、健壮、复用。存疑。</p></blockquote><h1 id="双开和虚拟机"><a href="#双开和虚拟机" class="headerlink" title="双开和虚拟机"></a>双开和虚拟机</h1><p>插件化的未来，虚拟机技术。在Android系统，也可以支持安装一个或多个虚拟机。</p><blockquote><p>双开，同时打开一个App的多个分身的技术。</p></blockquote><p>以上是问题一。</p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Plug-in</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GameS101 学习笔记（一）Transformation</title>
    <link href="/2021/07/01/GameS101-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89Transformation/"/>
    <url>/2021/07/01/GameS101-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89Transformation/</url>
    
    <content type="html"><![CDATA[<h1 id="变换基础"><a href="#变换基础" class="headerlink" title="变换基础"></a>变换基础</h1><h2 id="二维变换"><a href="#二维变换" class="headerlink" title="二维变换"></a>二维变换</h2><p>二维变换；线性变换==矩阵运算，缩放、反射、切变、旋转。</p><p>$\begin{aligned}<br>x^{\prime} &amp; =a x+b y \\<br>y^{\prime} &amp; =c x+d y \\<br>\end{aligned}$</p><p>$\begin{aligned}<br>{\left[\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime}<br>\end{array}\right] } &amp; =\left[\begin{array}{ll}<br>a &amp; b \\<br>c &amp; d<br>\end{array}\right]\left[\begin{array}{l}<br>x \\<br>y<br>\end{array}\right] \\<br>\mathbf{x}^{\prime} &amp; =\mathbf{M} \mathbf{x}<br>\end{aligned}$</p><h2 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h2><blockquote><p>Homogeneous coordinates。</p></blockquote><h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>Q：为什么要引入齐次坐标？</p><p>A：平移变换不是线性变换，无法统一到二维操作中。</p><p>$\left[\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime}<br>\end{array}\right]=\left[\begin{array}{ll}<br>a &amp; b \\<br>c &amp; d<br>\end{array}\right]\left[\begin{array}{l}<br>x \\<br>y<br>\end{array}\right]+\left[\begin{array}{l}<br>t_x \\<br>t_y<br>\end{array}\right]$</p><blockquote><p>但是不希望把平移当做一种特殊的情况去考虑。</p></blockquote><p>所以引入齐次坐标：可以把线性变换和平移（二者合起来就是仿射变换），用同一种形式去表示。</p><h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>二维的点、向量，增加一个维度。</p><p>$\begin{aligned}<br>&amp; 2 D \text { point } &amp; =(x, y, 1)^T \\<br>&amp; 2 D \text { vector } &amp; =(x, y, 0)^T<br>\end{aligned}$</p><p>二维点这样表示很”好”，增加了一个“1”的维度，可以表示平移变换，统一了线性变换和平移变换。</p><p>$\left(\begin{array}{c}<br>x^{\prime} \\<br>y^{\prime} \\<br>w^{\prime}<br>\end{array}\right)=\left(\begin{array}{ccc}<br>1 &amp; 0 &amp; t_x \\<br>0 &amp; 1 &amp; t_y \\<br>0 &amp; 0 &amp; 1<br>\end{array}\right) \cdot\left(\begin{array}{l}<br>x \\<br>y \\<br>1<br>\end{array}\right)=\left(\begin{array}{c}<br>x+t_x \\<br>y+t_y \\<br>1<br>\end{array}\right)$</p><blockquote><p>增加维度“1”、“0”的理解：</p><ol><li>向量表示一个方向，具有平移不变性，也因此向量增加的维度是“0”；向量做任何平移变换操作时，就可以保证符合平移不变性。</li><li>更深层次的理解，增加维度的“0”、“1”是有意义的。</li></ol></blockquote><p>齐次坐标下的二维点。</p><p>$\left(\begin{array}{c}<br>x \\<br>y \\<br>w<br>\end{array}\right) \text { is the } 2 \mathrm{D} \text { point }\left(\begin{array}{c}<br>x / w \\<br>y / w \\<br>1<br>\end{array}\right), w \neq 0$</p><h3 id="How"><a href="#How" class="headerlink" title="How"></a>How</h3><h4 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h4><p>$\mathbf{S}\left(s_x, s_y\right)=\left(\begin{array}{ccc}<br>s_x &amp; 0 &amp; 0 \\<br>0 &amp; s_y &amp; 0 \\<br>0 &amp; 0 &amp; 1<br>\end{array}\right)$</p><h4 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h4><p>$\mathbf{T}\left(t_x, t_y\right)=\left(\begin{array}{ccc}<br>1 &amp; 0 &amp; t_x \\<br>0 &amp; 1 &amp; t_y \\<br>0 &amp; 0 &amp; 1<br>\end{array}\right)$</p><h4 id="Rotation"><a href="#Rotation" class="headerlink" title="Rotation"></a>Rotation</h4><p>$\mathbf{R}(\alpha)=\left(\begin{array}{ccc}<br>\cos \alpha &amp; -\sin \alpha &amp; 0 \\<br>\sin \alpha &amp; \cos \alpha &amp; 0 \\<br>0 &amp; 0 &amp; 1<br>\end{array}\right)$</p><h2 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h2><blockquote><p>Affine Transformation。</p></blockquote><p>线性变换+平移变换；齐次坐标下，先线性后平移。</p><p>$\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime}<br>\end{array}\right)=\left(\begin{array}{ll}<br>a &amp; b \\<br>c &amp; d<br>\end{array}\right) \cdot\left(\begin{array}{l}<br>x \\<br>y<br>\end{array}\right)+\left(\begin{array}{l}<br>t_x \\<br>t_y<br>\end{array}\right)$</p><p>$\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime} \\<br>1<br>\end{array}\right)=\left(\begin{array}{ccc}<br>a &amp; b &amp; t_x \\<br>c &amp; d &amp; t_y \\<br>0 &amp; 0 &amp; 1<br>\end{array}\right) \cdot\left(\begin{array}{l}<br>x \\<br>y \\<br>1<br>\end{array}\right)$</p><h2 id="逆变换"><a href="#逆变换" class="headerlink" title="逆变换"></a>逆变换</h2><blockquote><p>Inverse transform。</p></blockquote><p><img src="/2021/07/01/GameS101-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89Transformation/inversetransform.png" alt></p><h2 id="组合变换"><a href="#组合变换" class="headerlink" title="组合变换"></a>组合变换</h2><p>复杂的变换都是由简单的组合而来；变换的顺序很重要；<strong>矩阵乘法无交换律</strong>。</p><blockquote><p>e.g. 一个不在原点的做旋转</p><p>先变换到原点→旋转→转换回原来位置</p></blockquote><h2 id="三维变换"><a href="#三维变换" class="headerlink" title="三维变换"></a>三维变换</h2><p>$\begin{aligned}<br>&amp; 3 D \text { point }=(x, y, z, 1)^T \\<br>&amp; 3 D \text { vector }=(x, y, z, 0)^T<br>\end{aligned}$</p><p>齐次坐标下，三维变换。</p><p>$\left(\begin{array}{l}<br>x^{\prime} \\<br>y^{\prime} \\<br>z^{\prime} \\<br>1<br>\end{array}\right)=\left(\begin{array}{lllc}<br>a &amp; b &amp; c &amp; t_x \\<br>d &amp; e &amp; f &amp; t_y \\<br>g &amp; h &amp; i &amp; t_z \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{array}\right) \cdot\left(\begin{array}{l}<br>x \\<br>y \\<br>z \\<br>1<br>\end{array}\right)$</p><h3 id="Scale-1"><a href="#Scale-1" class="headerlink" title="Scale"></a>Scale</h3><p>$\mathbf{S}\left(s_x, s_y, s_z\right)=\left(\begin{array}{cccc}<br>s_x &amp; 0 &amp; 0 &amp; 0 \\<br>0 &amp; s_y &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; s_z &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{array}\right)$</p><h3 id="Translation-1"><a href="#Translation-1" class="headerlink" title="Translation"></a>Translation</h3><p>$\mathbf{T}\left(t_x, t_y, t_z\right)=\left(\begin{array}{cccc}<br>1 &amp; 0 &amp; 0 &amp; t_x \\<br>0 &amp; 1 &amp; 0 &amp; t_y \\<br>0 &amp; 0 &amp; 1 &amp; t_z \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{array}\right)$</p><h3 id="Rotation-1"><a href="#Rotation-1" class="headerlink" title="Rotation"></a>Rotation</h3><h4 id="around-axis"><a href="#around-axis" class="headerlink" title="around axis"></a>around axis</h4><p>$\begin{aligned}<br>&amp; \mathbf{R}_x(\alpha)=\left(\begin{array}{cccc}<br>1 &amp; 0 &amp; 0 &amp; 0 \\<br>0 &amp; \cos \alpha &amp; -\sin \alpha &amp; 0 \\<br>0 &amp; \sin \alpha &amp; \cos \alpha &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{array}\right) \\<br>&amp; \mathbf{R}_y(\alpha)=\left(\begin{array}{cccc}<br>\cos \alpha &amp; 0 &amp; \sin \alpha &amp; 0 \\<br>0 &amp; 1 &amp; 0 &amp; 0 \\<br>-\sin \alpha &amp; 0 &amp; \cos \alpha &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{array}\right) \\<br>&amp; \mathbf{R}_z(\alpha)=\left(\begin{array}{cccc}<br>\cos \alpha &amp; -\sin \alpha &amp; 0 &amp; 0 \\<br>\sin \alpha &amp; \cos \alpha &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; 1 &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{array}\right)<br>\end{aligned}$</p><p><img src="/2021/07/01/GameS101-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89Transformation/rotationaroundaxis.png" alt></p><h4 id="Eular-Angle"><a href="#Eular-Angle" class="headerlink" title="Eular Angle"></a>Eular Angle</h4><p>$\mathbf{R}_{x y z}(\alpha, \beta, \gamma)=\mathbf{R}_x(\alpha) \mathbf{R}_y(\beta) \mathbf{R}_z(\gamma)$</p><p>A rotation by q about an arbitrary axis can be decomposed into the concatenation of rotations about the x, y, and z axes。</p><blockquote><p>Note that rotations do not commute。</p><p>Eular angle: composing rotations</p><ul><li>pitch(up&amp;&amp;down)</li><li>yaw(left&amp;&amp;right)</li><li>roll(rolling)</li></ul><p>As regard to a camera, only concern about it’s pitch and yaw.</p></blockquote><p><img src="/2021/07/01/GameS101-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89Transformation/flighteular.png" alt></p><h4 id="Rodrigues-Rotation"><a href="#Rodrigues-Rotation" class="headerlink" title="Rodrigues Rotation"></a>Rodrigues Rotation</h4><p>Rotation by angle $\alpha$ around axis $n$</p><p>$\mathbf{R}(\mathbf{n}, \alpha)=\cos (\alpha) \mathbf{I}+(1-\cos (\alpha)) \mathbf{n n}^T+\sin (\alpha) \underbrace{\left(\begin{array}{ccc}<br>0 &amp; -n_z &amp; n_y \\<br>n_z &amp; 0 &amp; -n_x \\<br>-n_y &amp; n_x &amp; 0<br>\end{array}\right)}_{\mathbf{N}}$</p><blockquote><p>n是旋转轴，alpha是旋转角度；默认n过原点，不是，则移到原点，再移回去。</p></blockquote><p><img src="/2021/07/01/GameS101-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89Transformation/Rrotation.png" alt></p><blockquote><ol><li>Move fixed point to origin;</li><li>Rotate;</li><li>Move fixed point back.</li></ol></blockquote><h4 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h4><p>解决欧拉角Gimbal Lock的问题。</p><h1 id="MVP变换"><a href="#MVP变换" class="headerlink" title="MVP变换"></a>MVP变换</h1>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Graphics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cpp面向对象高级编程（下） 学习笔记（一）转换函数</title>
    <link href="/2021/05/01/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/"/>
    <url>/2021/05/01/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h1><p>转换函数是类成员函数，用来将对象类型转换为其他类型。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * type 要转换成的类型</span><br><span class="hljs-comment"> * const 转换函数只是转换对象类型，并不会（也不应该）改变对象内的任何成员，设为const</span><br><span class="hljs-comment"> * &#123;&#125; 没有参数，转换不需要参数</span><br><span class="hljs-comment"> * @return 没有返回类型，返回类型就是转换成的类型</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/2021/05/01/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/conversion.png" alt></p><p>如果后面场合有把Fraction当作double使用，编译器会认为很合理（实际上认为也是合理的，才会这么做）；调用（黄色部分）即可；return type不用给出， 默认由名称里的类型给定。</p><blockquote><p>转换函数通常是const的，因为并不会改变数据。</p><p>Q：编译器如何编译<code>double d = 4 + f;</code>？</p><p>A：首先找有没有全局的<code>operator+(type, Fraction)</code>函数，找到则编译通过（type 为整型或浮点型都可以）；如果走不通，则看<code>f</code>能否转成整型或浮点型（类中是否有相应的conversion function），可以则编译通过。</p><p>只要认为合理，也可以给出转换成其他类型的转换函数。</p></blockquote><h2 id="标准库用到转换函数的地方"><a href="#标准库用到转换函数的地方" class="headerlink" title="标准库用到转换函数的地方"></a>标准库用到转换函数的地方</h2><p><img src="/2021/05/01/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/conversion2.png" alt></p><blockquote><p>bool模板偏特化。</p></blockquote><p><code>operator[]</code>对中括号做重载，取出第100个位置bool值，传回来bool，却传回蓝色的类型reference。</p><blockquote><p>设计模式：Proxy。</p></blockquote><p>合乎想像的是，蓝色类型reference果然有向bool转换的转换函数。</p><h1 id="转换构造函数"><a href="#转换构造函数" class="headerlink" title="转换构造函数"></a>转换构造函数</h1><p>non-explicit-one-argument constructor；没有explicit的可单传入实参构造函数。one-argument，只需要一个实参（其实是可以多parameter的，其他参数给出默认值即可）；non-explicit，构造函数没有加关键字explicit。</p><h2 id="转换功能"><a href="#转换功能" class="headerlink" title="转换功能"></a>转换功能</h2><p>和上述转换函数方向相反；（没有explicit的可单传入实参构造函数）可以用于把double转换为Fraction类型。</p><p><img src="/2021/05/01/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/neoa.png" alt></p><blockquote><p>Q：编译器如何编译<code>d2 = f + 4;</code>？</p><p>编译器找到Fraction重载的<code>operator+</code>函数，发现函数参数为Fraction，于是看看4可不可以转成Fraction（隐式转换），由于Fraction有一个non-explicit-one-argument constructor，因此转换成功，该行编译成功。</p></blockquote><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p>当转换函数和无explicit的可单传入实参构造函数同时出现。</p><p><img src="/2021/05/01/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/neoa2.png" alt></p><blockquote><p>Q：是否可以编译通过？</p><p>不可以！两条路径可行，所以编译器不知道走哪条路径。</p></blockquote><h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p><img src="/2021/05/01/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/eoa.png" alt></p><p>explicit的可单传入实参构造函数；explicit告诉编译器不可以把3自动变为（隐式转换为）1/3；该构造函数只能以构造函数的形式调用；这里4无法转换，报错转换失败。</p><blockquote><p>explicit只有用在构造函数前面。Cpp面向对象高级编程（下）-学习笔记（一）转换函数.md</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cpp Primer 读书笔记 第七章类</title>
    <link href="/2021/04/20/Cpp-Primer-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%B1%BB/"/>
    <url>/2021/04/20/Cpp-Primer-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="QA-1"><a href="#QA-1" class="headerlink" title="QA_1"></a>QA_1</h1><div class="table-container"><table><thead><tr><th>Q</th><th>A</th></tr></thead><tbody><tr><td>1. 类的基本思想是什么？</td><td>数据抽象、封装。</td></tr><tr><td>2. class和struct的区别？</td><td>默认访问权限不同。</td></tr><tr><td>3. 什么时候用struct？</td><td>数据成员都为public时。</td></tr><tr><td>4. 委托构造函数是什么？</td><td>借助另一个已有的构造函数定义新构造函数的一种方式。</td></tr><tr><td>5. 什么是友元？如何声明？</td><td>允许其访问类的私有成员的”东西“为类的友元。在类内声明，可以在类内任何位置声明，但是最好在开始或结束位置。声明方式为用friend来修饰一个正常的声明。</td></tr><tr><td>6. 声明友元函数、友元类要注意什么？</td><td>友元声明并不是通常意义上的访问声明。友元函数是一个普通函数，不属于类，但需要在类内表明友元关系。<br>但是，尽管友元函数的原型有在类的定义中出现过，友元函数并不是成员函数。</td></tr><tr><td>7. 声明重载函数为友元需要注意什么？</td><td>每个版本的重载都要声明一遍。</td></tr><tr><td>8. 类的什么成员必须初始化？</td><td>引用；const成员。</td></tr><tr><td>9. 类的静态成员如何声明和定义？</td><td>在类内用static声明，在类外定义和初始化，类外不加static。</td></tr><tr><td>10. const成员函数的使用需要注意什么？</td><td>const只能使用const（隐式的this指针被设置为指向常量的指针）。</td></tr></tbody></table></div><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类的基本思想：数据抽象、封装；数据抽象，依赖于接口和实现；封装，将接口和实现分离；用户只可以使用接口，无法访问实现。</p><h1 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h1><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><p>成员函数和非成员函数的本质：</p><p><strong>成员函数：类的实现的一部分；非成员函数：接口的组成部分</strong>。</p><p>成员函数：声明必须在类的内部，定义可以在内部也可以在类的外部；非成员函数：声明和定义都在类的外部。</p><p>在类的外部定义成员函数，定义要和声明匹配，类外部定义的成员的名字必须包含它所属的类名。</p><blockquote><p>该函数名，使编译器理解剩余代码位于类的作用域内。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Sales_data::avg_price</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (units_sol)<br>        <span class="hljs-keyword">return</span> revenue / units_sols;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>成员函数通过名为this的额外的隐式参数来访问调用它的那个对象；任何对类成员的直接访问都被看作this的隐式引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 编译器把total的地址传给isbn的隐式形参this</span><br>total.<span class="hljs-built_in">isbn</span>()<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 两者等价</span><br>std::string <span class="hljs-title function_">isbn</span><span class="hljs-params">()</span> const &#123;<span class="hljs-keyword">return</span> bookNo;&#125;<br>std::string <span class="hljs-title function_">isbn</span><span class="hljs-params">()</span> const &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>-&gt;bookNo;&#125;<br></code></pre></td></tr></table></figure><h2 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::string <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> bookNo;&#125;<br></code></pre></td></tr></table></figure><p>紧随参数列表之后的const关键字，作用是修改隐式this指针的类型；默认情况下，this的类型是指向类类型非常量版本的常量指针；即默认情况下不可以把this绑定到一个常量对象上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// this的类型是</span><br>Sales_data *<span class="hljs-type">const</span><br></code></pre></td></tr></table></figure><p>所以不可以在一个常量对象上调用普通的成员函数。</p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cpp面向对象高级编程（上） 学习笔记（六）内存管理</title>
    <link href="/2021/04/07/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E6%A8%A1%E6%9D%BF/"/>
    <url>/2021/04/07/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<blockquote><p>T：还没有决定是什么；使用时进行绑定；编译器会对代码进行替换。</p></blockquote><h1 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h1><p><img src="/2021/04/07/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E6%A8%A1%E6%9D%BF/template1.png" alt></p>]]></content>
    
    
    <categories>
      
      <category>Course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cpp面向对象高级编程（上） 学习笔记（六）内存管理</title>
    <link href="/2021/04/06/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2021/04/06/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h1><h2 id="对象相关"><a href="#对象相关" class="headerlink" title="对象相关"></a>对象相关</h2><blockquote><p>局部对象，定义在作用域内的对象，不再单独说明。</p></blockquote><h3 id="静态对象"><a href="#静态对象" class="headerlink" title="静态对象"></a>静态对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&#123;<br><span class="hljs-function"><span class="hljs-type">static</span> Complex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个对象前面加上static修饰符后，即变成所谓的静态对象（static object），其生命在作用域（scope）结束之后仍然存在，直到整个程序的结束。</p><h3 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>&#123;...&#125;;<br>...<br><span class="hljs-function">Complex <span class="hljs-title">c3</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义在任何作用域或者说大括号之外的对象。</p><blockquote><p><strong>一个对象的存在和消失取决于构造函数和析构函数何时被调用。</strong></p></blockquote><p>c3就是所谓的global object，其生命在整个程序结束之后才结束，也可以把它视为一种static object，其作用域是整个程序。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>对于全局对象，程序一开始，其构造函数就先被执行（比程序进入点更早）；程序即将结束前其析构函数被执行。</p><p>对于静态对象，当对象诞生时其构造函数被执行；当程序将结束时其析构函数才被执行，但比全局对象的析构函数早一步执行。</p><p>对于局部对象，当对象诞生时，其构造函数被执行；当离开作用域时，其析构函数被执行；对于new出来的局部对象，当对象诞生时其构造函数被执行，析构函数则在对象被delete时执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>&#123;...&#125;;<br>...<br>&#123;<br><span class="hljs-comment">// Complex(3)是该函数体内的临时对象，其所占用的空间从heap中new得到</span><br><span class="hljs-comment">// 也就是动态分配得到，p指向这块空间</span><br>Complex* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Complex</span>(<span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>静态全局对象和一般的全局对象的区别就是一般的全局对象在程序的其他文件中可以通过关键字extern来调用，而static声明的全局变量则只能在本文件中使用。</p></blockquote><h2 id="栈空间"><a href="#栈空间" class="headerlink" title="栈空间"></a>栈空间</h2><p><strong>stack，是存在于某作用域（scope）的一块内存空间（memory space）</strong>，例如调用函数，函数本身即会形成一个stack用来放置它所接收的参数，以及返回地址。</p><p>在函数本体（function body）内声明的任何变量，其所使用的内存块都取自上述stack。</p><h2 id="栈对象"><a href="#栈对象" class="headerlink" title="栈对象"></a>栈对象</h2><blockquote><p>以下主要说栈对象的生命周期。</p></blockquote><p>栈对象（stack object），其声明在作用域（scope）结束之际结束。这种作用域内的对象（object），又叫做local object，因为它会被自动清理（意思是析构函数被自动调用）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>&#123;...&#125;;<br>...<br>&#123;<br><span class="hljs-comment">// c1所占用的空间来自于stack</span><br><span class="hljs-function">Complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>举例，当离开作用域{}的时候，c1的生命自然就消失了， 即从栈中获得的内存，离开作用域的时候会自动释放（析构函数被自动调用）。</p><h2 id="堆空间"><a href="#堆空间" class="headerlink" title="堆空间"></a>堆空间</h2><p>Heap，所谓system heap，是指由操作系统提供的一块global内存空间，程序可动态分配（dynamic allocated）从其中获得若干区块（blocks）。new去取，去动态获得，但是同时也要兼任起动态释放的责任。</p><h2 id="堆对象"><a href="#堆对象" class="headerlink" title="堆对象"></a>堆对象</h2><p>当离开作用域{}的时候，动态分配的内存不会消失，即从堆中动态取得的内存不会自动消失，需要手动释放（delete）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>&#123;...&#125;;<br>...<br>&#123;<br>Complex *p = <span class="hljs-keyword">new</span> Complex;<br>...<br><span class="hljs-keyword">delete</span> p;<br>&#125;<br><span class="hljs-comment">// B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>&#123;...&#125;;<br>...<br>&#123;<br>Complex *p = <span class="hljs-keyword">new</span> Complex;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>A：p所指向的便是heap object，因为是动态从操作系统某个地方分配的内存，其生命周期在它被delete之际（此时默认析构函数或者手写析构函数被调用）结束。</p><p>B：会出现内存泄露（memory leak），因为当作用域结束后，<strong>p所指向的heap object仍然存在，但是指针p的生命却结束了</strong>，作用域之外再也看不到p，也就没机会delete p。</p><h1 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h1><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>先分配memory，再调用ctor。</p><p><img src="/2021/04/06/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/new.png" alt></p><p>编译器new分解为三个步骤，分配内存→指针转型→调用构造函数。</p><p>调用构造函数中，指针来调用成员函数，pc实际上是传入的隐藏参数this，是分配的内存的起始位置，构造函数中进行赋值操作。</p><h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>先调用dtor，再释放memory。</p><p><img src="/2021/04/06/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/delete.png" alt></p><p>class without point members，析构函数不做事情，马上就要delete，清理是做无用功。</p><p><img src="/2021/04/06/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/delete2.png" alt></p><p>class with point members，先调用析构函数，析构函数把字符串里动态分配的内容叉掉，其次释放内存，把字符串（是个指针）本身叉掉delete。</p><h2 id="memory-block"><a href="#memory-block" class="headerlink" title="memory block"></a>memory block</h2><p>即动态分配所得的内存块。</p><p><img src="/2021/04/06/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/block.png" alt></p><p>图中为内存结构，在VC中，分配的内存空间大小都是16的倍数，第一个图中是调试模式下，每个格表示4Bytes，Complex对象占8个字节，调试模式占32+4，cookie占4×2，计算得到的结果是52Bytes，不是16的倍数，所以补充12个Bytes的填补字节（pad部分），凑到64。</p><p>所以看似得到只是两个double的大小，但是用了64。</p><blockquote><p>cookie，记录整块给出的大小，系统回收时了解回收多大。</p></blockquote><p>最后一个byte标注是否给出（本来是40→加上标注变为41）：开头和结尾的<code>00000041</code>，其中的 <code>4</code>是64的16进制，<code>1</code>表示这块空间已经给出去了，<code>0</code>表示这块空间空闲。</p><p>如果没有debug（调试模式），就只有对象大小+cookie大小了：8+（4×2）=16。</p><h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><p>当动态分配的是数组。</p><p><img src="/2021/04/06/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/array.png" alt></p><p>最后又加了4：因为是数组，要记录这是数组。</p><p><img src="/2021/04/06/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/arraynew.png" alt></p><blockquote><p>21h代表一个16进制的数（32+1：已经使用）；3代表新创建了3个字符串。</p></blockquote><p>array new一定要搭配array delete，在使用指针新建字符数组的情况下，在手动释放内存的时候，如果<code>delete[] p;</code>写成了<code>delete p;</code>会造成内存泄露；因为3次析构函数各自负责把各自分配的动态内存叉掉，没有[]，则只会调用一次析构函数。</p><p>值得注意的是，错误用法<code>delete p;</code>导致出现的内存泄漏是String类中的指针指向的空间，而非指针本身。</p><p>如果是Complex 数组对象，因为其中没有指针，所以就算是使用<code>delete p;</code>也是没有问题的。但是为了万无一失，如果使用了array new 一定要搭配 array delete。</p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>包括静态对象和静态函数。</p><p><img src="/2021/04/06/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/static.png" alt></p><p>非static函数通过传入的this指针找到要处理的对象。如上所示：c1调用real()；c1的地址即指针就是this pointer，所以c1和c2虽然调用相同函数，但是给到不同数据。</p><p>成员函数只有一份，但是需要处理很多对象，所以需要人告诉他处理什么（this），成员函数里需要使用this（黄色），可写可不写。</p><p>static函数没有this指针，只能处理静态数据；当数据只需要一份、只能唯一值时，需要定义为静态；静态函数没有this pointer，不可以访问处理多个对象，显然只可以存取处理静态数据。</p><p><img src="/2021/04/06/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/static2.png" alt></p><p>静态数据需要在类外进行声明；调用静态函数有两种方法，通过对象或者class name调用。</p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>把构造函数放在private。</p><p><img src="/2021/04/06/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/singleton2.png" alt></p><p>有的class只希望产生一个对象；A类对象在private里已经有一个了；且A的构造函数放在private中，外界无法使用。设计静态函数getInstance，使外界可以得到唯一的A；再从这个唯一对象调用类函数。</p><p><img src="/2021/04/06/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/singleton1.png" alt></p><p>但是版本1有一个问题，即外界不需要时，A仍然存在；所以把静态自己放在getInstance中，当有人调用getInstance时，才会创建；且有人用后，该对象持续存在。</p>]]></content>
    
    
    <categories>
      
      <category>Course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cpp面向对象高级编程（上） 学习笔记（五）三大函数</title>
    <link href="/2021/04/05/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E4%B8%89%E5%A4%A7%E5%87%BD%E6%95%B0/"/>
    <url>/2021/04/05/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E4%B8%89%E5%A4%A7%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>类的分类，即类中是否有指针成员；若类中有指针，如果只是简单的拷贝，那就是指针拷贝，两个指针指向的是同一个空间，所以不能直接拷贝。因此，如果类中有指针，一定要自己写拷贝构造。</p><p>以下介绍classes with point members。</p></blockquote><h1 id="三大函数"><a href="#三大函数" class="headerlink" title="三大函数"></a>三大函数</h1><p><img src="/2021/04/05/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E4%B8%89%E5%A4%A7%E5%87%BD%E6%95%B0/image.png" alt></p><p>拷贝构造和拷贝赋值，如果没写，编译器会默认写；但是，编译器只是“忠实”逐字节拷贝，导致编译器提供的拷贝赋值只是拷贝了对象的指针，没有真正拷贝对象。</p><p><img src="/2021/04/05/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E4%B8%89%E5%A4%A7%E5%87%BD%E6%95%B0/bigthree1.png" alt></p><p>m_data指向字符串，因为不明确字母个数，动态分配；明显不可以用编译器默认的函数。</p><h1 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h1><p>接受自己类型；是构造函数。析构函数~；死亡时调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* cstr=<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp; str = <span class="hljs-number">0</span>);<br>    String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String&amp; str);<br>    ~<span class="hljs-built_in">String</span>();<br>    <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">get_cstr</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_data&#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* m_data;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-title">String::String</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* cstr=<span class="hljs-number">0</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 首先要创建字符串</span><br><span class="hljs-comment">// 检查指针是否是0</span><br>    <span class="hljs-keyword">if</span> (cstr)<br>    &#123;<br><span class="hljs-comment">// 看存进来多大+1结束符号</span><br>        m_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(cstr) + <span class="hljs-number">1</span>];<br><span class="hljs-comment">// 拷贝到开辟的空间里</span><br>        <span class="hljs-built_in">strcpy</span>(m_data, cstr);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br><span class="hljs-comment">// 放结束符号</span><br>        m_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];<br>        *m_data = <span class="hljs-string">&#x27;\0&#x27;</span>;  <span class="hljs-comment">//这里也许可以这样写：*m_data=&#x27;&#x27;;(网友观点)</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 对象死亡之前调用</span><br><span class="hljs-keyword">inline</span><br>String::~<span class="hljs-built_in">String</span>()<br>&#123;<br><span class="hljs-comment">// 释放动态分配的内存</span><br>    <span class="hljs-keyword">delete</span>[] m_data;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/04/05/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E4%B8%89%E5%A4%A7%E5%87%BD%E6%95%B0/bigthree2.png" alt></p><blockquote><p>得到字符串长度的方法：结束符号、前置长度。cpp采用结束符号，在为字符串分配内存的时候，都要多分配一个字节，用来存放结束符’\0’。</p></blockquote><p>检查传进来是否是空值；放置。存在指针，做了动态分配，对象死亡前析构函数必须释放分配的动态内存。s1、s2、p这三个字符串都会调用<code>String(const char* str = 0)</code>这个构造函数，离开作用域之后都会调用析构函数；s1和s2离开作用域自动调用析构函数；p是指针，delete释放掉。</p><h1 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h1><p>操作符重载；赋值动作，且参数为自己类型。</p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p><img src="/2021/04/05/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E4%B8%89%E5%A4%A7%E5%87%BD%E6%95%B0/bigthree3.png" alt></p><p>classes with point members必须有拷贝构造函数和拷贝赋值操作。以上并不是想要的，希望有相同内容，且操作很危险。首先，b的内存泄露，其次。</p><p>这是<strong>浅拷贝</strong>，执行<code>b=a;</code>后，本来是想把a的字符串值赋给b，但是这样只会让b指向同一块内存（所包含的内容），还会造成这样一个后果，假如改变a，b也会跟着改变，因为它们指向相同的内容。</p><p>此时b叫做a的别名（alias），在编程里面，别名的存在是一件危险的事情。</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p><img src="/2021/04/05/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E4%B8%89%E5%A4%A7%E5%87%BD%E6%95%B0/bigthree4.png" alt></p><p>传进来参数，不会去改动，所以用const修饰参数；<code>String s2(s1)</code>：以s1为蓝本创建s2；分配空间，把内容拷贝过去。</p><h1 id="拷贝赋值函数"><a href="#拷贝赋值函数" class="headerlink" title="拷贝赋值函数"></a>拷贝赋值函数</h1><p><img src="/2021/04/05/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E4%B8%89%E5%A4%A7%E5%87%BD%E6%95%B0/bigthree5.png" alt></p><blockquote><p>左边清空，创建和右边一样大的空间，拷贝。</p><p>第2行里面的&amp;代表对象的引用，第4行里面的&amp;代表取地址。</p></blockquote><h2 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">String s2 = s1;<br></code></pre></td></tr></table></figure><p>首先检测自我赋值（有可能看起来不像，但是确实是，例如指针名称变动），如果没有检测，会出现不好的结果。</p><p>检测：首先对象自己s2是会有this pointer传进来的，str是右边s1传进来内容；看是否相等，自己赋值给自己直接return。</p><blockquote><p>不检测自我赋值，不好的结果。</p><p><img src="/2021/04/05/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E4%B8%89%E5%A4%A7%E5%87%BD%E6%95%B0/bad.png" alt></p><p>拷贝赋值操作语句：<code>a=b;</code>如果指针a和b本来就指向同一块内存空间，杀掉a之后，相当于把b指向的内容也杀掉了，所以没办法做第2步了。</p></blockquote><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p><img src="/2021/04/05/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E4%B8%89%E5%A4%A7%E5%87%BD%E6%95%B0/bigthree6.png" alt></p><p>杀掉自己（右边内容）；开辟和赋值过来的对象一样大小的空间；字符串复制（到左边）。</p>]]></content>
    
    
    <categories>
      
      <category>Course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cpp面向对象高级编程（上） 学习笔记（四）操作符重载</title>
    <link href="/2021/04/04/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <url>/2021/04/04/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h1><blockquote><p>可以重载为成员函数或者是非成员函数。</p></blockquote><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><p>在C++里面，操作符是一种函数，这是C++的一大特点。</p><p><img src="/2021/04/04/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/operator1.png" alt></p><blockquote><p>操作符重载的原因：因为函数库中没有两个复数直接相加的函数，只有实数和实数相加的函数。</p></blockquote><p>对于成员函数+=：c2调用了+=（+=作用在c2身上），c2需要写出函数来进行正确调用；c2就是this，或者说this此时就指向了c2（this是一个指针），c2的地址传入了this。</p><blockquote><p>任何函数都隐藏this参数。</p><p>_doapl：再次调用 _dopal；也许是其他地方也要使用，所以写成单独的方法。</p></blockquote><h2 id="非成员函数"><a href="#非成员函数" class="headerlink" title="非成员函数"></a>非成员函数</h2><blockquote><p>无隐含参数this（指针）。</p><p><strong>类外区域</strong>，主要有成员函数、全局函数。</p><p><img src="/2021/04/04/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/outclassbody.png" alt></p><blockquote><p>两个全局函数（没有class的名称），目的是取得复数的实部、虚部。</p></blockquote></blockquote><p>为了应付用户的3种可能用法，需要在类区域（class body）外写3个对应的处理加法的函数；以下123仅用作标识。</p><p><img src="/2021/04/04/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/operator2.png" alt></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="尽量return-by-reference"><a href="#尽量return-by-reference" class="headerlink" title="尽量return by reference"></a>尽量return by reference</h2><p>写一个函数一般考量两个点，这两点影响着程序执行的效率：参数传递要不要by reference；返回值传递要不要by reference。</p><p>如果return by reference，传递者无需知道接收端是以by reference还是by value的形式接受object。</p><p><img src="/2021/04/04/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/return.png" alt></p><p>返回<code>*ths</code>（也就是一个object、返回值），接收用complex&amp;接收；但是其实<code>*ths</code>处不需要管接收用什么接收。</p><blockquote><p>当然还是引用接收好，快。</p></blockquote><h2 id="返回值是写void还是写一个具体类型"><a href="#返回值是写void还是写一个具体类型" class="headerlink" title="返回值是写void还是写一个具体类型"></a>返回值是写void还是写一个具体类型</h2><p><img src="/2021/04/04/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/returnwhat.png" alt></p><p>返回值是写void还是写一个具体类型；如果使用者只是这样调用+=这个重载函数：c2+=c1，那么返回类型complex&amp;写成void是没有问题的。</p><p>但如果这样调用：c3+=c2+=c1，返回void类型的话，就有问题了；希望c1先加到c2上，再将上述操作的返回值加到c3上。</p><h1 id="临时对象"><a href="#临时对象" class="headerlink" title="临时对象"></a>临时对象</h1><blockquote><p>temp object。</p></blockquote><p><img src="/2021/04/04/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/temp.png" alt></p><p>这些函数绝对不可以return by reference，因为，它们返回的必定是个local object，出去就不存在了，所以一定要return by value。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// （类名后面+小括号）</span><br><span class="hljs-built_in">typename</span>();<br></code></pre></td></tr></table></figure><p>这是一个特殊语法，是创建临时对象的特殊语法。举例，函数体中的complex()就是在创建临时对象，临时对象的生命周期就是这创建的那一行，到下一行生命就结束了。</p><p><img src="/2021/04/04/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/operator3.png" alt></p><blockquote><p>第一个正号操作，返回的是原来的东西，没有产生新的东西（新的local object，而下面代码中取反的操作产生了新的东西），那完全可以retrun by reference啊，这个是标准库里面的东西，那么厉害的人会注意不到这一点吗？有可能。这里其实可以retrun by reference。complex后面可以加个&amp;。（错误观点！）</p></blockquote><p>因为传入的参数是const类型的引用，如果将返回值改成引用，相当于将const类型转换为非const类型，这在编译上是通不过的。</p><h1 id="输出操作符重载"><a href="#输出操作符重载" class="headerlink" title="输出操作符重载"></a>输出操作符重载</h1><blockquote><p>单独拿出来，举例。</p></blockquote><p><img src="/2021/04/04/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/output.png" alt></p><blockquote><p>运算符永远是作用在左边的对象上，没有作用在右边上的。</p></blockquote><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>参数传递，均是pass by reference；x没有改变，const，但是os传进来需要改变，每一次输出都在改变状态，不可以const；“&lt;&lt;”是双目运算符，需要提供2个参数。</p><h2 id="返回值传递"><a href="#返回值传递" class="headerlink" title="返回值传递"></a>返回值传递</h2><p>返回值传递，return by reference；如果不是连续输出，函数的返回值类型可以设计成void，如果使用连续输出，函数的返回值类型不能是void类型；返回类型前不可以加”const”，因为连续输出的时候被丢到屏幕上的东西一直在变，即每有一个新的输出变量“os”的状态就会发生变化（也是由于这个原因，ostream&amp; os的前面不可以加const修饰符），相当于一个变量的值一直在发生变化。</p><h2 id="成员函数-1"><a href="#成员函数-1" class="headerlink" title="成员函数"></a>成员函数</h2><p>&lt;&lt;不可以写成成员函数，操作符重载一定左边上，正常使用习惯是&lt;&lt;作用到左边的cout身上；如果写成成员函数，<code>c1 &lt;&lt; cout;</code>，不符合使用习惯。</p><blockquote><p>任何一个操作都可以设置为成员函数或者全局函数；看情况。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cpp面向对象高级编程（上） 学习笔记（三）参数传递</title>
    <link href="/2021/04/03/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"/>
    <url>/2021/04/03/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</url>
    
    <content type="html"><![CDATA[<h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><h2 id="参数传递-1"><a href="#参数传递-1" class="headerlink" title="参数传递"></a>参数传递</h2><blockquote><p>pass by value vs. pass by reference（to const）</p></blockquote><p><img src="/2021/04/03/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/pass.png" alt></p><p>pass by value，压到函数的栈中（整包传过去），尽量不要，字节数（可能比较大）不定；pass by reference，C可以传指针，C++传reference（引用在底层就是指针）。</p><blockquote><p>引用，方法内改变则会影响原值，如果只是为了传输的速度，不希望进行改变，就用pass by reference to const。</p><p>一般来说，基础数据类型传值，自定义类型传引用。</p></blockquote><h2 id="返回值传递"><a href="#返回值传递" class="headerlink" title="返回值传递"></a>返回值传递</h2><blockquote><p>pass by value or pass by reference(to const)</p></blockquote><p><img src="/2021/04/03/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/returnby.png" alt></p><p>同上，考虑到效率，pass by reference。</p><h2 id="不能返回局部变量的引用"><a href="#不能返回局部变量的引用" class="headerlink" title="不能返回局部变量的引用"></a>不能返回局部变量的引用</h2><p>函数之间在进行参数传递和值传递的时候，都是要尽量传递引用；但是有一种情况不能传递引用，这就是值被赋给一个函数内的临时变量的时候，因为临时变量的生命周期只在函数内，不在函数外。</p><p>举例，ths本来就在，是非临时变量，所以可以传引用。</p><p><img src="/2021/04/03/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/cannot.png" alt></p><h1 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h1><p>声明后，可以自由取得该声明所在类的私有变量。</p><p><img src="/2021/04/03/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/friend1.png" alt></p><p><img src="/2021/04/03/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/friend2.png" alt></p>]]></content>
    
    
    <categories>
      
      <category>Course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cpp面向对象高级编程（上） 学习笔记（二）构造函数</title>
    <link href="/2021/04/02/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <url>/2021/04/02/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>C++在利用类名创建一个对象的时候，有一个函数会被自动调用，这个函数就是构造函数。</p><p>构造函数的特点：</p><ul><li>没有返回值类型，也不需要有；</li><li>构造函数的函数名必须和类名一致；</li><li>构造函数的参数可以有默认值；</li><li>用创建实例的时候传递进来的参数值去初始化私有变量；只有构造函数才有初始列表，使用初始列表进行数据的初始化比使用赋值进行值的设定的效率更高。</li></ul><p><img src="/2021/04/02/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/ctor.png" alt></p><blockquote><p>本类中没有指针变量，一般这种没有指针的类多半不需要写析构函数。</p></blockquote><h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><blockquote><p>构造函数可以有很多个。</p></blockquote><p>重载（overloading），创建对象可以多种构造方法。</p><blockquote><p>Q：为什么可以有同名函数？</p><p>编译器编译后的函数名称不同。</p></blockquote><p><img src="/2021/04/02/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/overloading.png" alt></p><h2 id="构造函数的重载"><a href="#构造函数的重载" class="headerlink" title="构造函数的重载"></a>构造函数的重载</h2><p>在使用类创建对象的时候，有多少个想法就可以创建多少个”<strong>形状不同</strong>“的构造函数，形状不同指的是函数参数个数不同。</p><h2 id="非构造函数的重载"><a href="#非构造函数的重载" class="headerlink" title="非构造函数的重载"></a>非构造函数的重载</h2><p>编译器会把它们编译成名字不同的函数。</p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>构造函数放在private区，不能被外界直接调用的；也就是无法在外界创造对象；单例模式。</p><p><img src="/2021/04/02/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/singleton1.png" alt></p><p>Singleton单键（外界只可以用一份）；构造函数位于private中；外界不可以创建，外界需要（自己在内部准备了一份），外界需要通过A的getInstance取到该单个对象。</p><p><img src="/2021/04/02/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/singleton2.png" alt></p><h1 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h1><blockquote><p>const member functions。</p></blockquote><p><img src="/2021/04/02/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/const.png" alt></p><p>const修饰成员函数，要在如上图的位置；修饰不会改变数据内容的函数；const对象一定只能调用const方法。</p><blockquote><p>关于不会改变数据内容的函数加const的解释，上面这两个函数只是把函数的实部和虚部拿出来，并不是写，不写就不会改变私有数据，所以可以定义成常量成员函数。</p></blockquote><h2 id="const函数"><a href="#const函数" class="headerlink" title="const函数"></a>const函数</h2><p>所谓常量成员函数就是不改变私有数据的成员函数，表面上看的话就是函数名和作用域之间加上const修饰符的函数，加const就意味着不打算改变私有数据。</p><p>换而言之，不改变私有数据就一定要加上const；能加就加，因为不加的话可能会产生不希望的后果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">const</span> complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>举例，这里const表示创建复数对象的时候，数据不可以被改变；但是假如调用函数real()的时候，real()函数前面没有加const，就会产生矛盾，因为没有用const修饰的函数意味着进来的数据有可能被改变。</p><h2 id="const成员"><a href="#const成员" class="headerlink" title="const成员"></a>const成员</h2><p>const修饰成员函数其实修饰的是隐式参数this指针，因此（由对象产生的）传入参数需要和this指针匹配，即const对象所调用的方法传入的是const对象指针，而非对象指针。也因此，const对象不可以调用非const成员函数。</p>]]></content>
    
    
    <categories>
      
      <category>Course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cpp面向对象高级编程（上） 学习笔记（一）头文件</title>
    <link href="/2021/04/01/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    <url>/2021/04/01/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%A4%B4%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="C-vs-C"><a href="#C-vs-C" class="headerlink" title="C vs. C++"></a>C vs. C++</h1><h2 id="C-vs-C-1"><a href="#C-vs-C-1" class="headerlink" title="C vs. C++"></a>C vs. C++</h2><p>C面向过程而C++面向对象。</p><blockquote><p>C++面向对象的关键：类的引入；类的封装性、继承性、多态性简化了程序编写，提到了代码重用率。</p></blockquote><p>C的目的：比汇编方便易用，同时不要损失汇编的表达能力；因此简单容易编译，灵活贴近底层。</p><p>C++的目的：提高编程人员的生产率，哪怕代价是增加编译器的复杂度；提高编程人员生产率的方法有如下几种：提高抽象层次、支持模块化编程、自动化代码生成。</p><blockquote><p>C++不仅仅是面向对象，其目的也在于支持泛型编程。</p></blockquote><h2 id="Object-Oriented"><a href="#Object-Oriented" class="headerlink" title="Object Oriented"></a>Object Oriented</h2><p>Object Based：面对的是单一的class的设计；Object Oriented：面对的是多重classes的设计，classes和classes之间的关系。</p><p>Classes的两个经典分类：Class without pointer members、Class with pointer member。</p><p><img src="/2021/04/01/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%A4%B4%E6%96%87%E4%BB%B6/classes.png" alt></p><blockquote><p>String数据内部只有一个指针，采用动态分配内存，该指针就指向动态分配的内存。</p></blockquote><h2 id="C-programs"><a href="#C-programs" class="headerlink" title="C++ programs"></a>C++ programs</h2><p><img src="/2021/04/01/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%A4%B4%E6%96%87%E4%BB%B6/programs.png" alt></p><blockquote><p>延伸文件名不一定是.h或.cpp，也可能是.hpp（头文件和主程序放在一个文件中实现）。</p></blockquote><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>向左cout“丢”（&lt;&lt;）即可</p><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><h2 id="防范式声明"><a href="#防范式声明" class="headerlink" title="防范式声明"></a>防范式声明</h2><p>防止此头文件被重复包含。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _COMPLEX_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _COMPLEX_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="Header布局"><a href="#Header布局" class="headerlink" title="Header布局"></a>Header布局</h2><p><img src="/2021/04/01/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%A4%B4%E6%96%87%E4%BB%B6/headerlayout.png" alt></p><h1 id="后续内容"><a href="#后续内容" class="headerlink" title="后续内容"></a>后续内容</h1><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>如果把私有数据的类型写死了，定义示例的时候，数据类型受到限制。所以需要写一个模板类（含模板的类）。T写成什么都可以。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span>(T r = <span class="hljs-number">0</span>, T i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span>(r), <span class="hljs-built_in">im</span>(i)<br>    &#123;<br>    &#125;<br>    complex &amp;<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> complex &amp;);<br>    <span class="hljs-function">T <span class="hljs-title">real</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125;<br>    <span class="hljs-function">T <span class="hljs-title">imag</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    T re, im;<br><br>    <span class="hljs-keyword">friend</span> complex &amp;__doapl(complex *, <span class="hljs-type">const</span> complex &amp;);<br>&#125;;<br><br>&#123;<br>    <span class="hljs-function">complex&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2.5</span>, <span class="hljs-number">1.5</span>)</span></span>;<br>    <span class="hljs-function">complex&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>)</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><blockquote><p>使用时绑定类型。</p></blockquote><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-type">double</span> i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">re</span>(r), <span class="hljs-built_in">im</span>(i) &#123;&#125;<br>    complex &amp;<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> complex &amp;);<br>    complex &amp;<span class="hljs-keyword">operator</span>-=(<span class="hljs-type">const</span> complex &amp;);<br>    complex &amp;<span class="hljs-keyword">operator</span>*=(<span class="hljs-type">const</span> complex &amp;);<br>    complex &amp;<span class="hljs-keyword">operator</span>/=(<span class="hljs-type">const</span> complex &amp;);<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">real</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">imag</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> re, im;<br><br>    <span class="hljs-keyword">friend</span> complex &amp;__doapl(complex *, <span class="hljs-type">const</span> complex &amp;);<br>    <span class="hljs-keyword">friend</span> complex &amp;__doami(complex *, <span class="hljs-type">const</span> complex &amp;);<br>    <span class="hljs-keyword">friend</span> complex &amp;__doaml(complex *, <span class="hljs-type">const</span> complex &amp;);<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">imag</span><span class="hljs-params">(<span class="hljs-type">const</span> complex &amp;x)</span> </span>&#123; <span class="hljs-keyword">return</span> x.<span class="hljs-built_in">imag</span>(); &#125;<br></code></pre></td></tr></table></figure><p><strong>inline</strong>；快（但是最后是否inline由编译器决定）；复杂时还是需要定义在外部。</p><p>函数在class body内完成，自动称为inline候选人。</p><h2 id="访问级别"><a href="#访问级别" class="headerlink" title="访问级别"></a>访问级别</h2><p>数据部分一般private；如果函数是要被外界调用的就放在public，若不打算被外界调用则放在private。即分为public给外界使用、private处理内部数据。</p><blockquote><p>尽量使外界通过方法“拿”数据，而不是直接访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// bad</span><br>cout &lt;&lt; c1.re;<br>cout &lt;&lt; c1.im;<br><span class="hljs-comment">// good</span><br>cout &lt;&lt; c1.<span class="hljs-built_in">real</span>();<br>cout &lt;&lt; c1.<span class="hljs-built_in">imag</span>();<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>Course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Map</title>
    <link href="/2019/07/01/Map/"/>
    <url>/2019/07/01/Map/</url>
    
    <content type="html"><![CDATA[<blockquote><p>模板</p><p><code>&#123;% post_link %&#125;</code></p></blockquote><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="C-primer"><a href="#C-primer" class="headerlink" title="C++ primer"></a>C++ primer</h2><blockquote><p>简单笔记，记重点，QA用来快速复习。</p></blockquote><ul><li><a href="/2021/04/20/Cpp-Primer-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%B1%BB/" title="Cpp Primer 读书笔记 第七章类">Cpp-Primer-读书笔记-第七章类</a></li></ul><h2 id="HJ"><a href="#HJ" class="headerlink" title="HJ"></a>HJ</h2><h3 id="Cpp面向对象高级编程（上）"><a href="#Cpp面向对象高级编程（上）" class="headerlink" title="Cpp面向对象高级编程（上）"></a>Cpp面向对象高级编程（上）</h3><ul><li><a href="/2021/04/01/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%A4%B4%E6%96%87%E4%BB%B6/" title="Cpp面向对象高级编程（上） 学习笔记（一）头文件">Cpp面向对象高级编程（上）-学习笔记（一）头文件</a></li><li><a href="/2021/04/02/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" title="Cpp面向对象高级编程（上） 学习笔记（二）构造函数">Cpp面向对象高级编程（上）-学习笔记（二）构造函数</a></li><li><a href="/2021/04/03/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/" title="Cpp面向对象高级编程（上） 学习笔记（三）参数传递">Cpp面向对象高级编程（上）-学习笔记（三）参数传递</a></li><li><a href="/2021/04/04/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/" title="Cpp面向对象高级编程（上） 学习笔记（四）操作符重载">Cpp面向对象高级编程（上）-学习笔记（四）操作符重载</a></li><li><a href="/2021/04/05/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E4%B8%89%E5%A4%A7%E5%87%BD%E6%95%B0/" title="Cpp面向对象高级编程（上） 学习笔记（五）三大函数">Cpp面向对象高级编程（上）-学习笔记（五）三大函数</a></li><li><a href="/2021/04/06/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="Cpp面向对象高级编程（上） 学习笔记（六）内存管理">Cpp面向对象高级编程（上）-学习笔记（六）内存管理</a></li></ul><h3 id="Cpp面向对象高级编程（下）"><a href="#Cpp面向对象高级编程（下）" class="headerlink" title="Cpp面向对象高级编程（下）"></a>Cpp面向对象高级编程（下）</h3><ul><li><a href="/2021/05/01/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/" title="Cpp面向对象高级编程（下） 学习笔记（一）转换函数">Cpp面向对象高级编程（下）-学习笔记（一）转换函数</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Map</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
